#[allow(clippy::type_complexity)]

/**

Generated by the following Solidity interface...
```solidity
interface LiquidExchange {
    event PriceChange(uint256 price);
    event Swap(address tokenIn, address tokenOut, uint256 amountIn, uint256 amountOut, address to);

    constructor(address arbiterTokenX_, address arbiterTokenY_, uint256 price_);

    function admin() external view returns (address);
    function arbiterTokenX() external view returns (address);
    function arbiterTokenY() external view returns (address);
    function price() external view returns (uint256);
    function setPrice(uint256 _price) external;
    function swap(address tokenIn, uint256 amountIn) external;
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [
      {
        "name": "arbiterTokenX_",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "arbiterTokenY_",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "price_",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "admin",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "arbiterTokenX",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "arbiterTokenY",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "price",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "setPrice",
    "inputs": [
      {
        "name": "_price",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "swap",
    "inputs": [
      {
        "name": "tokenIn",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "amountIn",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "event",
    "name": "PriceChange",
    "inputs": [
      {
        "name": "price",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Swap",
    "inputs": [
      {
        "name": "tokenIn",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "tokenOut",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "amountIn",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "amountOut",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "to",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  }
]
```*/
#[allow(non_camel_case_types, non_snake_case, clippy::style)]
pub mod LiquidExchange {
    use alloy::sol_types as alloy_sol_types;

    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x6080604052348015600f57600080fd5b506040516105d13803806105d1833981016040819052602c916089565b600080546001600160a01b03199081163317909155600180546001600160a01b03958616908316179055600280549390941692169190911790915560035560c0565b80516001600160a01b0381168114608457600080fd5b919050565b600080600060608486031215609d57600080fd5b60a484606e565b925060b060208501606e565b9150604084015190509250925092565b610502806100cf6000396000f3fe608060405234801561001057600080fd5b50600436106100625760003560e01c80633b2049481461006757806391b7f5ed14610097578063a035b1fe146100ac578063d004f0f7146100c3578063d0c472ec146100d6578063f851a440146100e9575b600080fd5b60015461007a906001600160a01b031681565b6040516001600160a01b0390911681526020015b60405180910390f35b6100aa6100a5366004610459565b6100fc565b005b6100b560035481565b60405190815260200161008e565b6100aa6100d1366004610472565b6101a0565b60025461007a906001600160a01b031681565b60005461007a906001600160a01b031681565b6000546001600160a01b031633146101655760405162461bcd60e51b815260206004820152602160248201527f4f6e6c792061646d696e2063616e2063616c6c20746869732066756e6374696f6044820152603760f91b60648201526084015b60405180910390fd5b60038190556040518181527ff347ee99503bf19c028bd6b18f3c676e82a9bb5b2bb5225aebe0fd62fd6a0d199060200160405180910390a150565b60015460009081906001600160a01b03908116908516036101e057506002546003546001600160a01b03909116906101d990849061040e565b915061024c565b6002546001600160a01b039081169085160361021457506001546003546001600160a01b03909116906101d990849061042a565b60405162461bcd60e51b815260206004820152600d60248201526c24b73b30b634b2103a37b5b2b760991b604482015260640161015c565b6040516323b872dd60e01b8152336004820152306024820152604481018490526001600160a01b038516906323b872dd906064016020604051808303816000875af115801561029f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102c391906104aa565b6103015760405162461bcd60e51b815260206004820152600f60248201526e151c985b9cd9995c8819985a5b1959608a1b604482015260640161015c565b60405163a9059cbb60e01b8152336004820152602481018390526001600160a01b0382169063a9059cbb906044016020604051808303816000875af115801561034e573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061037291906104aa565b6103b05760405162461bcd60e51b815260206004820152600f60248201526e151c985b9cd9995c8819985a5b1959608a1b604482015260640161015c565b604080516001600160a01b03808716825283166020820152908101849052606081018390523360808201527fb39c9bc43f811e1a7ce159c5f147458fdb80266bf23c17322013316e27e086d09060a00160405180910390a150505050565b60006104238383670de0b6b3a764000061043b565b9392505050565b600061042383670de0b6b3a7640000845b600082600019048411830215820261045257600080fd5b5091020490565b60006020828403121561046b57600080fd5b5035919050565b6000806040838503121561048557600080fd5b82356001600160a01b038116811461049c57600080fd5b946020939093013593505050565b6000602082840312156104bc57600080fd5b8151801515811461042357600080fdfea2646970667358221220026041555962859b339c7c22e07468ebf4c8b3b54d1c2f1d36aaea41f6bc4c5c64736f6c634300081a0033
    /// ```
    #[rustfmt::skip]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4\x80\x15`\x0FW`\0\x80\xFD[P`@Qa\x05\xD18\x03\x80a\x05\xD1\x839\x81\x01`@\x81\x90R`,\x91`\x89V[`\0\x80T`\x01`\x01`\xA0\x1B\x03\x19\x90\x81\x163\x17\x90\x91U`\x01\x80T`\x01`\x01`\xA0\x1B\x03\x95\x86\x16\x90\x83\x16\x17\x90U`\x02\x80T\x93\x90\x94\x16\x92\x16\x91\x90\x91\x17\x90\x91U`\x03U`\xC0V[\x80Q`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14`\x84W`\0\x80\xFD[\x91\x90PV[`\0\x80`\0``\x84\x86\x03\x12\x15`\x9DW`\0\x80\xFD[`\xA4\x84`nV[\x92P`\xB0` \x85\x01`nV[\x91P`@\x84\x01Q\x90P\x92P\x92P\x92V[a\x05\x02\x80a\0\xCF`\09`\0\xF3\xFE`\x80`@R4\x80\x15a\0\x10W`\0\x80\xFD[P`\x046\x10a\0bW`\x005`\xE0\x1C\x80c; IH\x14a\0gW\x80c\x91\xB7\xF5\xED\x14a\0\x97W\x80c\xA05\xB1\xFE\x14a\0\xACW\x80c\xD0\x04\xF0\xF7\x14a\0\xC3W\x80c\xD0\xC4r\xEC\x14a\0\xD6W\x80c\xF8Q\xA4@\x14a\0\xE9W[`\0\x80\xFD[`\x01Ta\0z\x90`\x01`\x01`\xA0\x1B\x03\x16\x81V[`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x01[`@Q\x80\x91\x03\x90\xF3[a\0\xAAa\0\xA56`\x04a\x04YV[a\0\xFCV[\0[a\0\xB5`\x03T\x81V[`@Q\x90\x81R` \x01a\0\x8EV[a\0\xAAa\0\xD16`\x04a\x04rV[a\x01\xA0V[`\x02Ta\0z\x90`\x01`\x01`\xA0\x1B\x03\x16\x81V[`\0Ta\0z\x90`\x01`\x01`\xA0\x1B\x03\x16\x81V[`\0T`\x01`\x01`\xA0\x1B\x03\x163\x14a\x01eW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`!`$\x82\x01R\x7FOnly admin can call this functio`D\x82\x01R`7`\xF9\x1B`d\x82\x01R`\x84\x01[`@Q\x80\x91\x03\x90\xFD[`\x03\x81\x90U`@Q\x81\x81R\x7F\xF3G\xEE\x99P;\xF1\x9C\x02\x8B\xD6\xB1\x8F<gn\x82\xA9\xBB[+\xB5\"Z\xEB\xE0\xFDb\xFDj\r\x19\x90` \x01`@Q\x80\x91\x03\x90\xA1PV[`\x01T`\0\x90\x81\x90`\x01`\x01`\xA0\x1B\x03\x90\x81\x16\x90\x85\x16\x03a\x01\xE0WP`\x02T`\x03T`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x90a\x01\xD9\x90\x84\x90a\x04\x0EV[\x91Pa\x02LV[`\x02T`\x01`\x01`\xA0\x1B\x03\x90\x81\x16\x90\x85\x16\x03a\x02\x14WP`\x01T`\x03T`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x90a\x01\xD9\x90\x84\x90a\x04*V[`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\r`$\x82\x01Rl$\xB7;0\xB64\xB2\x10:7\xB5\xB2\xB7`\x99\x1B`D\x82\x01R`d\x01a\x01\\V[`@Qc#\xB8r\xDD`\xE0\x1B\x81R3`\x04\x82\x01R0`$\x82\x01R`D\x81\x01\x84\x90R`\x01`\x01`\xA0\x1B\x03\x85\x16\x90c#\xB8r\xDD\x90`d\x01` `@Q\x80\x83\x03\x81`\0\x87Z\xF1\x15\x80\x15a\x02\x9FW=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x02\xC3\x91\x90a\x04\xAAV[a\x03\x01W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x0F`$\x82\x01Rn\x15\x1C\x98[\x9C\xD9\x99\\\x88\x19\x98Z[\x19Y`\x8A\x1B`D\x82\x01R`d\x01a\x01\\V[`@Qc\xA9\x05\x9C\xBB`\xE0\x1B\x81R3`\x04\x82\x01R`$\x81\x01\x83\x90R`\x01`\x01`\xA0\x1B\x03\x82\x16\x90c\xA9\x05\x9C\xBB\x90`D\x01` `@Q\x80\x83\x03\x81`\0\x87Z\xF1\x15\x80\x15a\x03NW=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x03r\x91\x90a\x04\xAAV[a\x03\xB0W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x0F`$\x82\x01Rn\x15\x1C\x98[\x9C\xD9\x99\\\x88\x19\x98Z[\x19Y`\x8A\x1B`D\x82\x01R`d\x01a\x01\\V[`@\x80Q`\x01`\x01`\xA0\x1B\x03\x80\x87\x16\x82R\x83\x16` \x82\x01R\x90\x81\x01\x84\x90R``\x81\x01\x83\x90R3`\x80\x82\x01R\x7F\xB3\x9C\x9B\xC4?\x81\x1E\x1A|\xE1Y\xC5\xF1GE\x8F\xDB\x80&k\xF2<\x172 \x131n'\xE0\x86\xD0\x90`\xA0\x01`@Q\x80\x91\x03\x90\xA1PPPPV[`\0a\x04#\x83\x83g\r\xE0\xB6\xB3\xA7d\0\0a\x04;V[\x93\x92PPPV[`\0a\x04#\x83g\r\xE0\xB6\xB3\xA7d\0\0\x84[`\0\x82`\0\x19\x04\x84\x11\x83\x02\x15\x82\x02a\x04RW`\0\x80\xFD[P\x91\x02\x04\x90V[`\0` \x82\x84\x03\x12\x15a\x04kW`\0\x80\xFD[P5\x91\x90PV[`\0\x80`@\x83\x85\x03\x12\x15a\x04\x85W`\0\x80\xFD[\x825`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\x04\x9CW`\0\x80\xFD[\x94` \x93\x90\x93\x015\x93PPPV[`\0` \x82\x84\x03\x12\x15a\x04\xBCW`\0\x80\xFD[\x81Q\x80\x15\x15\x81\x14a\x04#W`\0\x80\xFD\xFE\xA2dipfsX\"\x12 \x02`AUYb\x85\x9B3\x9C|\"\xE0th\xEB\xF4\xC8\xB3\xB5M\x1C/\x1D6\xAA\xEAA\xF6\xBCL\\dsolcC\0\x08\x1A\x003",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x608060405234801561001057600080fd5b50600436106100625760003560e01c80633b2049481461006757806391b7f5ed14610097578063a035b1fe146100ac578063d004f0f7146100c3578063d0c472ec146100d6578063f851a440146100e9575b600080fd5b60015461007a906001600160a01b031681565b6040516001600160a01b0390911681526020015b60405180910390f35b6100aa6100a5366004610459565b6100fc565b005b6100b560035481565b60405190815260200161008e565b6100aa6100d1366004610472565b6101a0565b60025461007a906001600160a01b031681565b60005461007a906001600160a01b031681565b6000546001600160a01b031633146101655760405162461bcd60e51b815260206004820152602160248201527f4f6e6c792061646d696e2063616e2063616c6c20746869732066756e6374696f6044820152603760f91b60648201526084015b60405180910390fd5b60038190556040518181527ff347ee99503bf19c028bd6b18f3c676e82a9bb5b2bb5225aebe0fd62fd6a0d199060200160405180910390a150565b60015460009081906001600160a01b03908116908516036101e057506002546003546001600160a01b03909116906101d990849061040e565b915061024c565b6002546001600160a01b039081169085160361021457506001546003546001600160a01b03909116906101d990849061042a565b60405162461bcd60e51b815260206004820152600d60248201526c24b73b30b634b2103a37b5b2b760991b604482015260640161015c565b6040516323b872dd60e01b8152336004820152306024820152604481018490526001600160a01b038516906323b872dd906064016020604051808303816000875af115801561029f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102c391906104aa565b6103015760405162461bcd60e51b815260206004820152600f60248201526e151c985b9cd9995c8819985a5b1959608a1b604482015260640161015c565b60405163a9059cbb60e01b8152336004820152602481018390526001600160a01b0382169063a9059cbb906044016020604051808303816000875af115801561034e573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061037291906104aa565b6103b05760405162461bcd60e51b815260206004820152600f60248201526e151c985b9cd9995c8819985a5b1959608a1b604482015260640161015c565b604080516001600160a01b03808716825283166020820152908101849052606081018390523360808201527fb39c9bc43f811e1a7ce159c5f147458fdb80266bf23c17322013316e27e086d09060a00160405180910390a150505050565b60006104238383670de0b6b3a764000061043b565b9392505050565b600061042383670de0b6b3a7640000845b600082600019048411830215820261045257600080fd5b5091020490565b60006020828403121561046b57600080fd5b5035919050565b6000806040838503121561048557600080fd5b82356001600160a01b038116811461049c57600080fd5b946020939093013593505050565b6000602082840312156104bc57600080fd5b8151801515811461042357600080fdfea2646970667358221220026041555962859b339c7c22e07468ebf4c8b3b54d1c2f1d36aaea41f6bc4c5c64736f6c634300081a0033
    /// ```
    #[rustfmt::skip]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4\x80\x15a\0\x10W`\0\x80\xFD[P`\x046\x10a\0bW`\x005`\xE0\x1C\x80c; IH\x14a\0gW\x80c\x91\xB7\xF5\xED\x14a\0\x97W\x80c\xA05\xB1\xFE\x14a\0\xACW\x80c\xD0\x04\xF0\xF7\x14a\0\xC3W\x80c\xD0\xC4r\xEC\x14a\0\xD6W\x80c\xF8Q\xA4@\x14a\0\xE9W[`\0\x80\xFD[`\x01Ta\0z\x90`\x01`\x01`\xA0\x1B\x03\x16\x81V[`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x01[`@Q\x80\x91\x03\x90\xF3[a\0\xAAa\0\xA56`\x04a\x04YV[a\0\xFCV[\0[a\0\xB5`\x03T\x81V[`@Q\x90\x81R` \x01a\0\x8EV[a\0\xAAa\0\xD16`\x04a\x04rV[a\x01\xA0V[`\x02Ta\0z\x90`\x01`\x01`\xA0\x1B\x03\x16\x81V[`\0Ta\0z\x90`\x01`\x01`\xA0\x1B\x03\x16\x81V[`\0T`\x01`\x01`\xA0\x1B\x03\x163\x14a\x01eW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`!`$\x82\x01R\x7FOnly admin can call this functio`D\x82\x01R`7`\xF9\x1B`d\x82\x01R`\x84\x01[`@Q\x80\x91\x03\x90\xFD[`\x03\x81\x90U`@Q\x81\x81R\x7F\xF3G\xEE\x99P;\xF1\x9C\x02\x8B\xD6\xB1\x8F<gn\x82\xA9\xBB[+\xB5\"Z\xEB\xE0\xFDb\xFDj\r\x19\x90` \x01`@Q\x80\x91\x03\x90\xA1PV[`\x01T`\0\x90\x81\x90`\x01`\x01`\xA0\x1B\x03\x90\x81\x16\x90\x85\x16\x03a\x01\xE0WP`\x02T`\x03T`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x90a\x01\xD9\x90\x84\x90a\x04\x0EV[\x91Pa\x02LV[`\x02T`\x01`\x01`\xA0\x1B\x03\x90\x81\x16\x90\x85\x16\x03a\x02\x14WP`\x01T`\x03T`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x90a\x01\xD9\x90\x84\x90a\x04*V[`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\r`$\x82\x01Rl$\xB7;0\xB64\xB2\x10:7\xB5\xB2\xB7`\x99\x1B`D\x82\x01R`d\x01a\x01\\V[`@Qc#\xB8r\xDD`\xE0\x1B\x81R3`\x04\x82\x01R0`$\x82\x01R`D\x81\x01\x84\x90R`\x01`\x01`\xA0\x1B\x03\x85\x16\x90c#\xB8r\xDD\x90`d\x01` `@Q\x80\x83\x03\x81`\0\x87Z\xF1\x15\x80\x15a\x02\x9FW=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x02\xC3\x91\x90a\x04\xAAV[a\x03\x01W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x0F`$\x82\x01Rn\x15\x1C\x98[\x9C\xD9\x99\\\x88\x19\x98Z[\x19Y`\x8A\x1B`D\x82\x01R`d\x01a\x01\\V[`@Qc\xA9\x05\x9C\xBB`\xE0\x1B\x81R3`\x04\x82\x01R`$\x81\x01\x83\x90R`\x01`\x01`\xA0\x1B\x03\x82\x16\x90c\xA9\x05\x9C\xBB\x90`D\x01` `@Q\x80\x83\x03\x81`\0\x87Z\xF1\x15\x80\x15a\x03NW=`\0\x80>=`\0\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x03r\x91\x90a\x04\xAAV[a\x03\xB0W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x0F`$\x82\x01Rn\x15\x1C\x98[\x9C\xD9\x99\\\x88\x19\x98Z[\x19Y`\x8A\x1B`D\x82\x01R`d\x01a\x01\\V[`@\x80Q`\x01`\x01`\xA0\x1B\x03\x80\x87\x16\x82R\x83\x16` \x82\x01R\x90\x81\x01\x84\x90R``\x81\x01\x83\x90R3`\x80\x82\x01R\x7F\xB3\x9C\x9B\xC4?\x81\x1E\x1A|\xE1Y\xC5\xF1GE\x8F\xDB\x80&k\xF2<\x172 \x131n'\xE0\x86\xD0\x90`\xA0\x01`@Q\x80\x91\x03\x90\xA1PPPPV[`\0a\x04#\x83\x83g\r\xE0\xB6\xB3\xA7d\0\0a\x04;V[\x93\x92PPPV[`\0a\x04#\x83g\r\xE0\xB6\xB3\xA7d\0\0\x84[`\0\x82`\0\x19\x04\x84\x11\x83\x02\x15\x82\x02a\x04RW`\0\x80\xFD[P\x91\x02\x04\x90V[`\0` \x82\x84\x03\x12\x15a\x04kW`\0\x80\xFD[P5\x91\x90PV[`\0\x80`@\x83\x85\x03\x12\x15a\x04\x85W`\0\x80\xFD[\x825`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\x04\x9CW`\0\x80\xFD[\x94` \x93\x90\x93\x015\x93PPPV[`\0` \x82\x84\x03\x12\x15a\x04\xBCW`\0\x80\xFD[\x81Q\x80\x15\x15\x81\x14a\x04#W`\0\x80\xFD\xFE\xA2dipfsX\"\x12 \x02`AUYb\x85\x9B3\x9C|\"\xE0th\xEB\xF4\xC8\xB3\xB5M\x1C/\x1D6\xAA\xEAA\xF6\xBCL\\dsolcC\0\x08\x1A\x003",
    );
    /**Event with signature `PriceChange(uint256)` and selector `0xf347ee99503bf19c028bd6b18f3c676e82a9bb5b2bb5225aebe0fd62fd6a0d19`.
    ```solidity
    event PriceChange(uint256 price);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    #[derive(Clone)]
    pub struct PriceChange {
        #[allow(missing_docs)]
        pub price: alloy::sol_types::private::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for PriceChange {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "PriceChange(uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 =
                alloy_sol_types::private::B256::new([
                    243u8, 71u8, 238u8, 153u8, 80u8, 59u8, 241u8, 156u8, 2u8, 139u8, 214u8, 177u8,
                    143u8, 60u8, 103u8, 110u8, 130u8, 169u8, 187u8, 91u8, 43u8, 181u8, 34u8, 90u8,
                    235u8, 224u8, 253u8, 98u8, 253u8, 106u8, 13u8, 25u8,
                ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { price: data.0 }
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.price,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH,)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(Self::SIGNATURE_HASH);
                Ok(())
            }
        }
        impl From<&PriceChange> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &PriceChange) -> alloy_sol_types::private::LogData {
                let topics = alloy_sol_types::SolEvent::encode_topics(this)
                    .into_iter()
                    .map(|t| t.into())
                    .collect();
                let data = alloy_sol_types::SolEvent::encode_data(this).into();
                alloy_sol_types::private::LogData::new_unchecked(topics, data)
            }
        }
    };
    /**Event with signature `Swap(address,address,uint256,uint256,address)` and selector `0xb39c9bc43f811e1a7ce159c5f147458fdb80266bf23c17322013316e27e086d0`.
    ```solidity
    event Swap(address tokenIn, address tokenOut, uint256 amountIn, uint256 amountOut, address to);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    #[derive(Clone)]
    pub struct Swap {
        #[allow(missing_docs)]
        pub tokenIn: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub tokenOut: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amountIn: alloy::sol_types::private::U256,
        #[allow(missing_docs)]
        pub amountOut: alloy::sol_types::private::U256,
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Swap {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            type DataToken<'a> = <Self::DataTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Swap(address,address,uint256,uint256,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 =
                alloy_sol_types::private::B256::new([
                    179u8, 156u8, 155u8, 196u8, 63u8, 129u8, 30u8, 26u8, 124u8, 225u8, 89u8, 197u8,
                    241u8, 71u8, 69u8, 143u8, 219u8, 128u8, 38u8, 107u8, 242u8, 60u8, 23u8, 50u8,
                    32u8, 19u8, 49u8, 110u8, 39u8, 224u8, 134u8, 208u8,
                ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    tokenIn: data.0,
                    tokenOut: data.1,
                    amountIn: data.2,
                    amountOut: data.3,
                    to: data.4,
                }
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.tokenIn,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.tokenOut,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.amountIn,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.amountOut,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH,)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(Self::SIGNATURE_HASH);
                Ok(())
            }
        }
        impl From<&Swap> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Swap) -> alloy_sol_types::private::LogData {
                let topics = alloy_sol_types::SolEvent::encode_topics(this)
                    .into_iter()
                    .map(|t| t.into())
                    .collect();
                let data = alloy_sol_types::SolEvent::encode_data(this).into();
                alloy_sol_types::private::LogData::new_unchecked(topics, data)
            }
        }
    };
    /**Constructor`.
    ```solidity
    constructor(address arbiterTokenX_, address arbiterTokenY_, uint256 price_);
    ```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct constructorCall {
        pub arbiterTokenX_: alloy::sol_types::private::Address,
        pub arbiterTokenY_: alloy::sol_types::private::Address,
        pub price_: alloy::sol_types::private::U256,
    }
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    (value.arbiterTokenX_, value.arbiterTokenY_, value.price_)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        arbiterTokenX_: tuple.0,
                        arbiterTokenY_: tuple.1,
                        price_: tuple.2,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new(tuple: <Self::Parameters<'_> as alloy_sol_types::SolType>::RustType) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.arbiterTokenX_,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.arbiterTokenY_,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.price_,
                    ),
                )
            }
        }
    };
    /**Function with signature `admin()` and selector `0xf851a440`.
    ```solidity
    function admin() external view returns (address);
    ```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct adminCall {}
    ///Container type for the return parameters of the [`admin()`](adminCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct adminReturn {
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<adminCall> for UnderlyingRustTuple<'_> {
                fn from(value: adminCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for adminCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<adminReturn> for UnderlyingRustTuple<'_> {
                fn from(value: adminReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for adminReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for adminCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = adminReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "admin()";
            const SELECTOR: [u8; 4] = [248u8, 81u8, 164u8, 64u8];
            #[inline]
            fn new(tuple: <Self::Parameters<'_> as alloy_sol_types::SolType>::RustType) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `arbiterTokenX()` and selector `0x3b204948`.
    ```solidity
    function arbiterTokenX() external view returns (address);
    ```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct arbiterTokenXCall {}
    ///Container type for the return parameters of the [`arbiterTokenX()`](arbiterTokenXCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct arbiterTokenXReturn {
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<arbiterTokenXCall> for UnderlyingRustTuple<'_> {
                fn from(value: arbiterTokenXCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for arbiterTokenXCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<arbiterTokenXReturn> for UnderlyingRustTuple<'_> {
                fn from(value: arbiterTokenXReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for arbiterTokenXReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for arbiterTokenXCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = arbiterTokenXReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "arbiterTokenX()";
            const SELECTOR: [u8; 4] = [59u8, 32u8, 73u8, 72u8];
            #[inline]
            fn new(tuple: <Self::Parameters<'_> as alloy_sol_types::SolType>::RustType) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `arbiterTokenY()` and selector `0xd0c472ec`.
    ```solidity
    function arbiterTokenY() external view returns (address);
    ```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct arbiterTokenYCall {}
    ///Container type for the return parameters of the [`arbiterTokenY()`](arbiterTokenYCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct arbiterTokenYReturn {
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<arbiterTokenYCall> for UnderlyingRustTuple<'_> {
                fn from(value: arbiterTokenYCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for arbiterTokenYCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<arbiterTokenYReturn> for UnderlyingRustTuple<'_> {
                fn from(value: arbiterTokenYReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for arbiterTokenYReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for arbiterTokenYCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = arbiterTokenYReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "arbiterTokenY()";
            const SELECTOR: [u8; 4] = [208u8, 196u8, 114u8, 236u8];
            #[inline]
            fn new(tuple: <Self::Parameters<'_> as alloy_sol_types::SolType>::RustType) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `price()` and selector `0xa035b1fe`.
    ```solidity
    function price() external view returns (uint256);
    ```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct priceCall {}
    ///Container type for the return parameters of the [`price()`](priceCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct priceReturn {
        pub _0: alloy::sol_types::private::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<priceCall> for UnderlyingRustTuple<'_> {
                fn from(value: priceCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for priceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<priceReturn> for UnderlyingRustTuple<'_> {
                fn from(value: priceReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for priceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for priceCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = priceReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "price()";
            const SELECTOR: [u8; 4] = [160u8, 53u8, 177u8, 254u8];
            #[inline]
            fn new(tuple: <Self::Parameters<'_> as alloy_sol_types::SolType>::RustType) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `setPrice(uint256)` and selector `0x91b7f5ed`.
    ```solidity
    function setPrice(uint256 _price) external;
    ```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct setPriceCall {
        pub _price: alloy::sol_types::private::U256,
    }
    ///Container type for the return parameters of the [`setPrice(uint256)`](setPriceCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct setPriceReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setPriceCall> for UnderlyingRustTuple<'_> {
                fn from(value: setPriceCall) -> Self {
                    (value._price,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setPriceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _price: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setPriceReturn> for UnderlyingRustTuple<'_> {
                fn from(value: setPriceReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setPriceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setPriceCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = setPriceReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setPrice(uint256)";
            const SELECTOR: [u8; 4] = [145u8, 183u8, 245u8, 237u8];
            #[inline]
            fn new(tuple: <Self::Parameters<'_> as alloy_sol_types::SolType>::RustType) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self._price,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `swap(address,uint256)` and selector `0xd004f0f7`.
    ```solidity
    function swap(address tokenIn, uint256 amountIn) external;
    ```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct swapCall {
        pub tokenIn: alloy::sol_types::private::Address,
        pub amountIn: alloy::sol_types::private::U256,
    }
    ///Container type for the return parameters of the [`swap(address,uint256)`](swapCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct swapReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<swapCall> for UnderlyingRustTuple<'_> {
                fn from(value: swapCall) -> Self {
                    (value.tokenIn, value.amountIn)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for swapCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        tokenIn: tuple.0,
                        amountIn: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<swapReturn> for UnderlyingRustTuple<'_> {
                fn from(value: swapReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for swapReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for swapCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = swapReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "swap(address,uint256)";
            const SELECTOR: [u8; 4] = [208u8, 4u8, 240u8, 247u8];
            #[inline]
            fn new(tuple: <Self::Parameters<'_> as alloy_sol_types::SolType>::RustType) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.tokenIn,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.amountIn,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    ///Container for all the [`LiquidExchange`](self) function calls.
    pub enum LiquidExchangeCalls {
        admin(adminCall),
        arbiterTokenX(arbiterTokenXCall),
        arbiterTokenY(arbiterTokenYCall),
        price(priceCall),
        setPrice(setPriceCall),
        swap(swapCall),
    }
    #[automatically_derived]
    impl LiquidExchangeCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [59u8, 32u8, 73u8, 72u8],
            [145u8, 183u8, 245u8, 237u8],
            [160u8, 53u8, 177u8, 254u8],
            [208u8, 4u8, 240u8, 247u8],
            [208u8, 196u8, 114u8, 236u8],
            [248u8, 81u8, 164u8, 64u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for LiquidExchangeCalls {
        const NAME: &'static str = "LiquidExchangeCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 6usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::admin(_) => <adminCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::arbiterTokenX(_) => <arbiterTokenXCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::arbiterTokenY(_) => <arbiterTokenYCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::price(_) => <priceCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::setPrice(_) => <setPriceCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::swap(_) => <swapCall as alloy_sol_types::SolCall>::SELECTOR,
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(unsafe_code, non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            )
                -> alloy_sol_types::Result<LiquidExchangeCalls>] = &[
                {
                    fn arbiterTokenX(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<LiquidExchangeCalls> {
                        <arbiterTokenXCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(LiquidExchangeCalls::arbiterTokenX)
                    }
                    arbiterTokenX
                },
                {
                    fn setPrice(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<LiquidExchangeCalls> {
                        <setPriceCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(LiquidExchangeCalls::setPrice)
                    }
                    setPrice
                },
                {
                    fn price(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<LiquidExchangeCalls> {
                        <priceCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(LiquidExchangeCalls::price)
                    }
                    price
                },
                {
                    fn swap(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<LiquidExchangeCalls> {
                        <swapCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(LiquidExchangeCalls::swap)
                    }
                    swap
                },
                {
                    fn arbiterTokenY(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<LiquidExchangeCalls> {
                        <arbiterTokenYCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(LiquidExchangeCalls::arbiterTokenY)
                    }
                    arbiterTokenY
                },
                {
                    fn admin(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<LiquidExchangeCalls> {
                        <adminCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(LiquidExchangeCalls::admin)
                    }
                    admin
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(alloy_sol_types::Error::unknown_selector(
                    <Self as alloy_sol_types::SolInterface>::NAME,
                    selector,
                ));
            };
            (unsafe { DECODE_SHIMS.get_unchecked(idx) })(data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::admin(inner) => {
                    <adminCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::arbiterTokenX(inner) => {
                    <arbiterTokenXCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::arbiterTokenY(inner) => {
                    <arbiterTokenYCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::price(inner) => {
                    <priceCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::setPrice(inner) => {
                    <setPriceCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::swap(inner) => {
                    <swapCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::admin(inner) => {
                    <adminCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::arbiterTokenX(inner) => {
                    <arbiterTokenXCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::arbiterTokenY(inner) => {
                    <arbiterTokenYCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::price(inner) => {
                    <priceCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::setPrice(inner) => {
                    <setPriceCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::swap(inner) => {
                    <swapCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
            }
        }
    }
    ///Container for all the [`LiquidExchange`](self) events.
    pub enum LiquidExchangeEvents {
        PriceChange(PriceChange),
        Swap(Swap),
    }
    #[automatically_derived]
    impl LiquidExchangeEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                179u8, 156u8, 155u8, 196u8, 63u8, 129u8, 30u8, 26u8, 124u8, 225u8, 89u8, 197u8,
                241u8, 71u8, 69u8, 143u8, 219u8, 128u8, 38u8, 107u8, 242u8, 60u8, 23u8, 50u8, 32u8,
                19u8, 49u8, 110u8, 39u8, 224u8, 134u8, 208u8,
            ],
            [
                243u8, 71u8, 238u8, 153u8, 80u8, 59u8, 241u8, 156u8, 2u8, 139u8, 214u8, 177u8,
                143u8, 60u8, 103u8, 110u8, 130u8, 169u8, 187u8, 91u8, 43u8, 181u8, 34u8, 90u8,
                235u8, 224u8, 253u8, 98u8, 253u8, 106u8, 13u8, 25u8,
            ],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for LiquidExchangeEvents {
        const NAME: &'static str = "LiquidExchangeEvents";
        const COUNT: usize = 2usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(<PriceChange as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <PriceChange as alloy_sol_types::SolEvent>::decode_raw_log(
                        topics, data, validate,
                    )
                    .map(Self::PriceChange)
                }
                Some(<Swap as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Swap as alloy_sol_types::SolEvent>::decode_raw_log(topics, data, validate)
                        .map(Self::Swap)
                }
                _ => alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                    name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                    log: alloy_sol_types::private::Box::new(
                        alloy_sol_types::private::LogData::new_unchecked(
                            topics.to_vec(),
                            data.to_vec().into(),
                        ),
                    ),
                }),
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`LiquidExchange`](self) contract instance.

    See the [wrapper's documentation](`LiquidExchangeInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> LiquidExchangeInstance<T, P, N> {
        LiquidExchangeInstance::<T, P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

    Returns a new instance of the contract, if the deployment was successful.

    For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        arbiterTokenX_: alloy::sol_types::private::Address,
        arbiterTokenY_: alloy::sol_types::private::Address,
        price_: alloy::sol_types::private::U256,
    ) -> impl ::core::future::Future<Output = alloy_contract::Result<LiquidExchangeInstance<T, P, N>>>
    {
        LiquidExchangeInstance::<T, P, N>::deploy(provider, arbiterTokenX_, arbiterTokenY_, price_)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
    and constructor arguments, if any.

    This is a simple wrapper around creating a `RawCallBuilder` with the data set to
    the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        arbiterTokenX_: alloy::sol_types::private::Address,
        arbiterTokenY_: alloy::sol_types::private::Address,
        price_: alloy::sol_types::private::U256,
    ) -> alloy_contract::RawCallBuilder<T, P, N> {
        LiquidExchangeInstance::<T, P, N>::deploy_builder(
            provider,
            arbiterTokenX_,
            arbiterTokenY_,
            price_,
        )
    }
    /**A [`LiquidExchange`](self) instance.

    Contains type-safe methods for interacting with an on-chain instance of the
    [`LiquidExchange`](self) contract located at a given `address`, using a given
    provider `P`.

    If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
    documentation on how to provide it), the `deploy` and `deploy_builder` methods can
    be used to deploy a new instance of the contract.

    See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct LiquidExchangeInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for LiquidExchangeInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("LiquidExchangeInstance")
                .field(&self.address)
                .finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
            T: alloy_contract::private::Transport + ::core::clone::Clone,
            P: alloy_contract::private::Provider<T, N>,
            N: alloy_contract::private::Network,
        > LiquidExchangeInstance<T, P, N>
    {
        /**Creates a new wrapper around an on-chain [`LiquidExchange`](self) contract instance.

        See the [wrapper's documentation](`LiquidExchangeInstance`) for more details.*/
        #[inline]
        pub const fn new(address: alloy_sol_types::private::Address, provider: P) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

        Returns a new instance of the contract, if the deployment was successful.

        For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
            arbiterTokenX_: alloy::sol_types::private::Address,
            arbiterTokenY_: alloy::sol_types::private::Address,
            price_: alloy::sol_types::private::U256,
        ) -> alloy_contract::Result<LiquidExchangeInstance<T, P, N>> {
            let call_builder =
                Self::deploy_builder(provider, arbiterTokenX_, arbiterTokenY_, price_);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
        and constructor arguments, if any.

        This is a simple wrapper around creating a `RawCallBuilder` with the data set to
        the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(
            provider: P,
            arbiterTokenX_: alloy::sol_types::private::Address,
            arbiterTokenY_: alloy::sol_types::private::Address,
            price_: alloy::sol_types::private::U256,
        ) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                [
                    &BYTECODE[..],
                    &alloy_sol_types::SolConstructor::abi_encode(&constructorCall {
                        arbiterTokenX_,
                        arbiterTokenY_,
                        price_,
                    })[..],
                ]
                .concat()
                .into(),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> LiquidExchangeInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> LiquidExchangeInstance<T, P, N> {
            LiquidExchangeInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
            T: alloy_contract::private::Transport + ::core::clone::Clone,
            P: alloy_contract::private::Provider<T, N>,
            N: alloy_contract::private::Network,
        > LiquidExchangeInstance<T, P, N>
    {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`admin`] function.
        pub fn admin(&self) -> alloy_contract::SolCallBuilder<T, &P, adminCall, N> {
            self.call_builder(&adminCall {})
        }
        ///Creates a new call builder for the [`arbiterTokenX`] function.
        pub fn arbiterTokenX(&self) -> alloy_contract::SolCallBuilder<T, &P, arbiterTokenXCall, N> {
            self.call_builder(&arbiterTokenXCall {})
        }
        ///Creates a new call builder for the [`arbiterTokenY`] function.
        pub fn arbiterTokenY(&self) -> alloy_contract::SolCallBuilder<T, &P, arbiterTokenYCall, N> {
            self.call_builder(&arbiterTokenYCall {})
        }
        ///Creates a new call builder for the [`price`] function.
        pub fn price(&self) -> alloy_contract::SolCallBuilder<T, &P, priceCall, N> {
            self.call_builder(&priceCall {})
        }
        ///Creates a new call builder for the [`setPrice`] function.
        pub fn setPrice(
            &self,
            _price: alloy::sol_types::private::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, setPriceCall, N> {
            self.call_builder(&setPriceCall { _price })
        }
        ///Creates a new call builder for the [`swap`] function.
        pub fn swap(
            &self,
            tokenIn: alloy::sol_types::private::Address,
            amountIn: alloy::sol_types::private::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, swapCall, N> {
            self.call_builder(&swapCall { tokenIn, amountIn })
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
            T: alloy_contract::private::Transport + ::core::clone::Clone,
            P: alloy_contract::private::Provider<T, N>,
            N: alloy_contract::private::Network,
        > LiquidExchangeInstance<T, P, N>
    {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`PriceChange`] event.
        pub fn PriceChange_filter(&self) -> alloy_contract::Event<T, &P, PriceChange, N> {
            self.event_filter::<PriceChange>()
        }
        ///Creates a new event filter for the [`Swap`] event.
        pub fn Swap_filter(&self) -> alloy_contract::Event<T, &P, Swap, N> {
            self.event_filter::<Swap>()
        }
    }
}
