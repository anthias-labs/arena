/**

Generated by the following Solidity interface...
```solidity
interface MockHooks {
    type BalanceDelta is int256;
    type BeforeSwapDelta is int256;
    type Currency is address;
    type PoolId is bytes32;
    struct ModifyLiquidityParams {
        int24 tickLower;
        int24 tickUpper;
        int256 liquidityDelta;
        bytes32 salt;
    }
    struct PoolKey {
        Currency currency0;
        Currency currency1;
        uint24 fee;
        int24 tickSpacing;
        address hooks;
    }
    struct SwapParams {
        bool zeroForOne;
        int256 amountSpecified;
        uint160 sqrtPriceLimitX96;
    }

    function afterAddLiquidity(address, PoolKey memory, ModifyLiquidityParams memory, BalanceDelta, bytes memory hookData) external returns (bytes4, BalanceDelta);
    function afterAddLiquidityData() external view returns (bytes memory);
    function afterDonate(address, PoolKey memory, uint256, uint256, bytes memory hookData) external returns (bytes4);
    function afterDonateData() external view returns (bytes memory);
    function afterInitialize(address, PoolKey memory, uint160, int24, bytes memory hookData) external returns (bytes4);
    function afterInitializeData() external view returns (bytes memory);
    function afterRemoveLiquidity(address, PoolKey memory, ModifyLiquidityParams memory, BalanceDelta, bytes memory hookData) external returns (bytes4, BalanceDelta);
    function afterRemoveLiquidityData() external view returns (bytes memory);
    function afterSwap(address, PoolKey memory, SwapParams memory, BalanceDelta, bytes memory hookData) external returns (bytes4, int128);
    function afterSwapData() external view returns (bytes memory);
    function beforeAddLiquidity(address, PoolKey memory, ModifyLiquidityParams memory, bytes memory hookData) external returns (bytes4);
    function beforeAddLiquidityData() external view returns (bytes memory);
    function beforeDonate(address, PoolKey memory, uint256, uint256, bytes memory hookData) external returns (bytes4);
    function beforeDonateData() external view returns (bytes memory);
    function beforeInitialize(address, PoolKey memory, uint160, bytes memory hookData) external returns (bytes4);
    function beforeInitializeData() external view returns (bytes memory);
    function beforeRemoveLiquidity(address, PoolKey memory, ModifyLiquidityParams memory, bytes memory hookData) external returns (bytes4);
    function beforeRemoveLiquidityData() external view returns (bytes memory);
    function beforeSwap(address, PoolKey memory, SwapParams memory, bytes memory hookData) external returns (bytes4, BeforeSwapDelta, uint24);
    function beforeSwapData() external view returns (bytes memory);
    function lpFees(PoolId) external view returns (uint16);
    function returnValues(bytes4) external view returns (bytes4);
    function setReturnValue(bytes4 key, bytes4 value) external;
    function setlpFee(PoolKey memory key, uint16 value) external;
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "function",
    "name": "afterAddLiquidity",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct PoolKey",
        "components": [
          {
            "name": "currency0",
            "type": "address",
            "internalType": "Currency"
          },
          {
            "name": "currency1",
            "type": "address",
            "internalType": "Currency"
          },
          {
            "name": "fee",
            "type": "uint24",
            "internalType": "uint24"
          },
          {
            "name": "tickSpacing",
            "type": "int24",
            "internalType": "int24"
          },
          {
            "name": "hooks",
            "type": "address",
            "internalType": "contract IHooks"
          }
        ]
      },
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct IPoolManager.ModifyLiquidityParams",
        "components": [
          {
            "name": "tickLower",
            "type": "int24",
            "internalType": "int24"
          },
          {
            "name": "tickUpper",
            "type": "int24",
            "internalType": "int24"
          },
          {
            "name": "liquidityDelta",
            "type": "int256",
            "internalType": "int256"
          },
          {
            "name": "salt",
            "type": "bytes32",
            "internalType": "bytes32"
          }
        ]
      },
      {
        "name": "",
        "type": "int256",
        "internalType": "BalanceDelta"
      },
      {
        "name": "hookData",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes4",
        "internalType": "bytes4"
      },
      {
        "name": "",
        "type": "int256",
        "internalType": "BalanceDelta"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "afterAddLiquidityData",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "afterDonate",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct PoolKey",
        "components": [
          {
            "name": "currency0",
            "type": "address",
            "internalType": "Currency"
          },
          {
            "name": "currency1",
            "type": "address",
            "internalType": "Currency"
          },
          {
            "name": "fee",
            "type": "uint24",
            "internalType": "uint24"
          },
          {
            "name": "tickSpacing",
            "type": "int24",
            "internalType": "int24"
          },
          {
            "name": "hooks",
            "type": "address",
            "internalType": "contract IHooks"
          }
        ]
      },
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "hookData",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes4",
        "internalType": "bytes4"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "afterDonateData",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "afterInitialize",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct PoolKey",
        "components": [
          {
            "name": "currency0",
            "type": "address",
            "internalType": "Currency"
          },
          {
            "name": "currency1",
            "type": "address",
            "internalType": "Currency"
          },
          {
            "name": "fee",
            "type": "uint24",
            "internalType": "uint24"
          },
          {
            "name": "tickSpacing",
            "type": "int24",
            "internalType": "int24"
          },
          {
            "name": "hooks",
            "type": "address",
            "internalType": "contract IHooks"
          }
        ]
      },
      {
        "name": "",
        "type": "uint160",
        "internalType": "uint160"
      },
      {
        "name": "",
        "type": "int24",
        "internalType": "int24"
      },
      {
        "name": "hookData",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes4",
        "internalType": "bytes4"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "afterInitializeData",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "afterRemoveLiquidity",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct PoolKey",
        "components": [
          {
            "name": "currency0",
            "type": "address",
            "internalType": "Currency"
          },
          {
            "name": "currency1",
            "type": "address",
            "internalType": "Currency"
          },
          {
            "name": "fee",
            "type": "uint24",
            "internalType": "uint24"
          },
          {
            "name": "tickSpacing",
            "type": "int24",
            "internalType": "int24"
          },
          {
            "name": "hooks",
            "type": "address",
            "internalType": "contract IHooks"
          }
        ]
      },
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct IPoolManager.ModifyLiquidityParams",
        "components": [
          {
            "name": "tickLower",
            "type": "int24",
            "internalType": "int24"
          },
          {
            "name": "tickUpper",
            "type": "int24",
            "internalType": "int24"
          },
          {
            "name": "liquidityDelta",
            "type": "int256",
            "internalType": "int256"
          },
          {
            "name": "salt",
            "type": "bytes32",
            "internalType": "bytes32"
          }
        ]
      },
      {
        "name": "",
        "type": "int256",
        "internalType": "BalanceDelta"
      },
      {
        "name": "hookData",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes4",
        "internalType": "bytes4"
      },
      {
        "name": "",
        "type": "int256",
        "internalType": "BalanceDelta"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "afterRemoveLiquidityData",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "afterSwap",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct PoolKey",
        "components": [
          {
            "name": "currency0",
            "type": "address",
            "internalType": "Currency"
          },
          {
            "name": "currency1",
            "type": "address",
            "internalType": "Currency"
          },
          {
            "name": "fee",
            "type": "uint24",
            "internalType": "uint24"
          },
          {
            "name": "tickSpacing",
            "type": "int24",
            "internalType": "int24"
          },
          {
            "name": "hooks",
            "type": "address",
            "internalType": "contract IHooks"
          }
        ]
      },
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct IPoolManager.SwapParams",
        "components": [
          {
            "name": "zeroForOne",
            "type": "bool",
            "internalType": "bool"
          },
          {
            "name": "amountSpecified",
            "type": "int256",
            "internalType": "int256"
          },
          {
            "name": "sqrtPriceLimitX96",
            "type": "uint160",
            "internalType": "uint160"
          }
        ]
      },
      {
        "name": "",
        "type": "int256",
        "internalType": "BalanceDelta"
      },
      {
        "name": "hookData",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes4",
        "internalType": "bytes4"
      },
      {
        "name": "",
        "type": "int128",
        "internalType": "int128"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "afterSwapData",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "beforeAddLiquidity",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct PoolKey",
        "components": [
          {
            "name": "currency0",
            "type": "address",
            "internalType": "Currency"
          },
          {
            "name": "currency1",
            "type": "address",
            "internalType": "Currency"
          },
          {
            "name": "fee",
            "type": "uint24",
            "internalType": "uint24"
          },
          {
            "name": "tickSpacing",
            "type": "int24",
            "internalType": "int24"
          },
          {
            "name": "hooks",
            "type": "address",
            "internalType": "contract IHooks"
          }
        ]
      },
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct IPoolManager.ModifyLiquidityParams",
        "components": [
          {
            "name": "tickLower",
            "type": "int24",
            "internalType": "int24"
          },
          {
            "name": "tickUpper",
            "type": "int24",
            "internalType": "int24"
          },
          {
            "name": "liquidityDelta",
            "type": "int256",
            "internalType": "int256"
          },
          {
            "name": "salt",
            "type": "bytes32",
            "internalType": "bytes32"
          }
        ]
      },
      {
        "name": "hookData",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes4",
        "internalType": "bytes4"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "beforeAddLiquidityData",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "beforeDonate",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct PoolKey",
        "components": [
          {
            "name": "currency0",
            "type": "address",
            "internalType": "Currency"
          },
          {
            "name": "currency1",
            "type": "address",
            "internalType": "Currency"
          },
          {
            "name": "fee",
            "type": "uint24",
            "internalType": "uint24"
          },
          {
            "name": "tickSpacing",
            "type": "int24",
            "internalType": "int24"
          },
          {
            "name": "hooks",
            "type": "address",
            "internalType": "contract IHooks"
          }
        ]
      },
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "hookData",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes4",
        "internalType": "bytes4"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "beforeDonateData",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "beforeInitialize",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct PoolKey",
        "components": [
          {
            "name": "currency0",
            "type": "address",
            "internalType": "Currency"
          },
          {
            "name": "currency1",
            "type": "address",
            "internalType": "Currency"
          },
          {
            "name": "fee",
            "type": "uint24",
            "internalType": "uint24"
          },
          {
            "name": "tickSpacing",
            "type": "int24",
            "internalType": "int24"
          },
          {
            "name": "hooks",
            "type": "address",
            "internalType": "contract IHooks"
          }
        ]
      },
      {
        "name": "",
        "type": "uint160",
        "internalType": "uint160"
      },
      {
        "name": "hookData",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes4",
        "internalType": "bytes4"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "beforeInitializeData",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "beforeRemoveLiquidity",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct PoolKey",
        "components": [
          {
            "name": "currency0",
            "type": "address",
            "internalType": "Currency"
          },
          {
            "name": "currency1",
            "type": "address",
            "internalType": "Currency"
          },
          {
            "name": "fee",
            "type": "uint24",
            "internalType": "uint24"
          },
          {
            "name": "tickSpacing",
            "type": "int24",
            "internalType": "int24"
          },
          {
            "name": "hooks",
            "type": "address",
            "internalType": "contract IHooks"
          }
        ]
      },
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct IPoolManager.ModifyLiquidityParams",
        "components": [
          {
            "name": "tickLower",
            "type": "int24",
            "internalType": "int24"
          },
          {
            "name": "tickUpper",
            "type": "int24",
            "internalType": "int24"
          },
          {
            "name": "liquidityDelta",
            "type": "int256",
            "internalType": "int256"
          },
          {
            "name": "salt",
            "type": "bytes32",
            "internalType": "bytes32"
          }
        ]
      },
      {
        "name": "hookData",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes4",
        "internalType": "bytes4"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "beforeRemoveLiquidityData",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "beforeSwap",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct PoolKey",
        "components": [
          {
            "name": "currency0",
            "type": "address",
            "internalType": "Currency"
          },
          {
            "name": "currency1",
            "type": "address",
            "internalType": "Currency"
          },
          {
            "name": "fee",
            "type": "uint24",
            "internalType": "uint24"
          },
          {
            "name": "tickSpacing",
            "type": "int24",
            "internalType": "int24"
          },
          {
            "name": "hooks",
            "type": "address",
            "internalType": "contract IHooks"
          }
        ]
      },
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct IPoolManager.SwapParams",
        "components": [
          {
            "name": "zeroForOne",
            "type": "bool",
            "internalType": "bool"
          },
          {
            "name": "amountSpecified",
            "type": "int256",
            "internalType": "int256"
          },
          {
            "name": "sqrtPriceLimitX96",
            "type": "uint160",
            "internalType": "uint160"
          }
        ]
      },
      {
        "name": "hookData",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes4",
        "internalType": "bytes4"
      },
      {
        "name": "",
        "type": "int256",
        "internalType": "BeforeSwapDelta"
      },
      {
        "name": "",
        "type": "uint24",
        "internalType": "uint24"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "beforeSwapData",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "lpFees",
    "inputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "PoolId"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint16",
        "internalType": "uint16"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "returnValues",
    "inputs": [
      {
        "name": "",
        "type": "bytes4",
        "internalType": "bytes4"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes4",
        "internalType": "bytes4"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "setReturnValue",
    "inputs": [
      {
        "name": "key",
        "type": "bytes4",
        "internalType": "bytes4"
      },
      {
        "name": "value",
        "type": "bytes4",
        "internalType": "bytes4"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setlpFee",
    "inputs": [
      {
        "name": "key",
        "type": "tuple",
        "internalType": "struct PoolKey",
        "components": [
          {
            "name": "currency0",
            "type": "address",
            "internalType": "Currency"
          },
          {
            "name": "currency1",
            "type": "address",
            "internalType": "Currency"
          },
          {
            "name": "fee",
            "type": "uint24",
            "internalType": "uint24"
          },
          {
            "name": "tickSpacing",
            "type": "int24",
            "internalType": "int24"
          },
          {
            "name": "hooks",
            "type": "address",
            "internalType": "contract IHooks"
          }
        ]
      },
      {
        "name": "value",
        "type": "uint16",
        "internalType": "uint16"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  }
]
```*/
#[allow(non_camel_case_types, non_snake_case, clippy::style)]
pub mod MockHooks {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x60808060405234601557612f07908161001a8239f35b5f80fdfe60806040526004361015610011575f80fd5b5f3560e01c80630a2d582714612a4a57806317bd6123146129fe57806321d0ee701461272d578063259982e51461245c5780633440d820146121155780634d081c7e1461205257806350cd07eb14611f92578063542e936914611ecf578063575e24b414611b335780635941b5bb14611a735780635a2a81001461179b578063622e60de146116d857806370b28eda146116155780637a3385f5146114fc5780637e472fb2146114395780638db2b65214611132578063a2bc94ad1461109e578063a910f80f14610d4a578063af57c18414610c87578063b47b2fb1146108f2578063b6a8b0fa14610620578063b85164661461055d578063db6d76a2146104475763e1b4af6914610121575f80fd5b346104435761012f36612e30565b93509350505067ffffffffffffffff81116104165761014f600954612b0d565b601f8111610379575b505f601f82116001146102c15781925f926102b6575b50507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8260011b9260031b1c1916176009555b7fe1b4af69000000000000000000000000000000000000000000000000000000005f52600a6020527f3e1cff7e09cc4cb604c0c017add856c5756522d5e4dfc08fa794b6e2e9f5c0e95460e01b7fffffffff00000000000000000000000000000000000000000000000000000000166102625760207fe1b4af69000000000000000000000000000000000000000000000000000000005b7fffffffff0000000000000000000000000000000000000000000000000000000060405191168152f35b7fe1b4af69000000000000000000000000000000000000000000000000000000005f52600a60209081527f3e1cff7e09cc4cb604c0c017add856c5756522d5e4dfc08fa794b6e2e9f5c0e95460e01b610238565b013590505f8061016e565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08216927f6e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7af915f5b85811061036157508360019510610329575b505050811b016009556101a1565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60f88560031b161c199101351690555f808061031b565b90926020600181928686013581550194019101610309565b601f820160051c7f6e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7af0190602083106103ee575b601f0160051c7f6e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7af01905b8181106103e35750610158565b5f81556001016103d6565b7f6e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7af91506103ac565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b5f80fd5b34610443575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610443576040515f60025461048581612b0d565b808452906001811690811561051b57506001146104bd575b6104b9836104ad81850382612b5e565b60405191829182612b9f565b0390f35b60025f9081527f405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace939250905b808210610501575090915081016020016104ad61049d565b9192600181602092548385880101520191019092916104e9565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff001660208086019190915291151560051b840190910191506104ad905061049d565b34610443575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610443576040515f60035461059b81612b0d565b808452906001811690811561051b57506001146105c2576104b9836104ad81850382612b5e565b60035f9081527fc2575a0e9e593c00f959f8c92f12db2869c3395a3b0502d05e2516446f71f85b939250905b808210610606575090915081016020016104ad61049d565b9192600181602092548385880101520191019092916105ee565b346104435761062e36612e30565b93509350505067ffffffffffffffff81116104165761064e600854612b0d565b601f8111610855575b505f601f821160011461079d5781925f92610792575b50507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8260011b9260031b1c1916176008555b7fb6a8b0fa000000000000000000000000000000000000000000000000000000005f52600a6020527fc020f4cb7a0ae9ba5c590fbb2728bbab87fc8f068a74c7042ca3f2f27cc519f75460e01b7fffffffff000000000000000000000000000000000000000000000000000000001661073e576040517fb6a8b0fa000000000000000000000000000000000000000000000000000000008152602090f35b7fb6a8b0fa000000000000000000000000000000000000000000000000000000005f52600a60209081527fc020f4cb7a0ae9ba5c590fbb2728bbab87fc8f068a74c7042ca3f2f27cc519f75460e01b610238565b01359050828061066d565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08216927ff3f7a9fe364faab93b216da50a3214154f22a0a2b415b23a84c8169e8b636ee3915f5b85811061083d57508360019510610805575b505050811b016008556106a0565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60f88560031b161c199101351690558280806107f7565b909260206001819286860135815501940191016107e5565b601f820160051c7ff3f7a9fe364faab93b216da50a3214154f22a0a2b415b23a84c8169e8b636ee30190602083106108ca575b601f0160051c7ff3f7a9fe364faab93b216da50a3214154f22a0a2b415b23a84c8169e8b636ee301905b8181106108bf5750610657565b5f81556001016108b2565b7ff3f7a9fe364faab93b216da50a3214154f22a0a2b415b23a84c8169e8b636ee39150610888565b34610443576101607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126104435761092a612be7565b5060a07fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffdc3601126104435760607fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff3c360112610443576101443567ffffffffffffffff8111610443576109a0903690600401612c0a565b67ffffffffffffffff8111610416576109ba600754612b0d565b601f8111610bea575b505f601f8211600114610b325781925f92610b27575b50507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8260011b9260031b1c1916176007555b7fb47b2fb1000000000000000000000000000000000000000000000000000000005f52600a6020527f2491b1a3e05eb915595dd2d17535e9dd4280b7e1dc3e97bd1382883e4c8628635460e01b7fffffffff0000000000000000000000000000000000000000000000000000000016610ad25760407fb47b2fb1000000000000000000000000000000000000000000000000000000005b7fffffffff000000000000000000000000000000000000000000000000000000008251911681525f6020820152f35b7fb47b2fb1000000000000000000000000000000000000000000000000000000005f52600a6020527f2491b1a3e05eb915595dd2d17535e9dd4280b7e1dc3e97bd1382883e4c8628635460409060e01b610aa3565b0135905082806109d9565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08216927fa66cc928b5edb82af9bd49922954155ab7b0942694bea4ce44661d9a8736c688915f5b858110610bd257508360019510610b9a575b505050811b01600755610a0c565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60f88560031b161c19910135169055828080610b8c565b90926020600181928686013581550194019101610b7a565b601f820160051c7fa66cc928b5edb82af9bd49922954155ab7b0942694bea4ce44661d9a8736c688019060208310610c5f575b601f0160051c7fa66cc928b5edb82af9bd49922954155ab7b0942694bea4ce44661d9a8736c68801905b818110610c5457506109c3565b5f8155600101610c47565b7fa66cc928b5edb82af9bd49922954155ab7b0942694bea4ce44661d9a8736c6889150610c1d565b34610443575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610443576040515f600854610cc581612b0d565b808452906001811690811561051b5750600114610cec576104b9836104ad81850382612b5e565b60085f9081527ff3f7a9fe364faab93b216da50a3214154f22a0a2b415b23a84c8169e8b636ee3939250905b808210610d30575090915081016020016104ad61049d565b919260018160209254838588010152019101909291610d18565b34610443576101207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261044357610d82612be7565b5060a07fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffdc36011261044357610db5612d03565b50610dbe612e20565b506101043567ffffffffffffffff811161044357610de0903690600401612c0a565b67ffffffffffffffff811161041657610dfa600154612b0d565b601f8111611001575b505f601f8211600114610f495781925f92610f3e575b50507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8260011b9260031b1c1916176001555b7fa910f80f000000000000000000000000000000000000000000000000000000005f52600a6020527f6bf6b3c2668cbe141e73f2947fc4a61f0fa3dd095e3438f5f144c8e9814d390b5460e01b7fffffffff0000000000000000000000000000000000000000000000000000000016610eea576040517fa910f80f000000000000000000000000000000000000000000000000000000008152602090f35b7fa910f80f000000000000000000000000000000000000000000000000000000005f52600a60209081527f6bf6b3c2668cbe141e73f2947fc4a61f0fa3dd095e3438f5f144c8e9814d390b5460e01b610238565b013590508280610e19565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08216927fb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6915f5b858110610fe957508360019510610fb1575b505050811b01600155610e4c565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60f88560031b161c19910135169055828080610fa3565b90926020600181928686013581550194019101610f91565b601f820160051c7fb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6019060208310611076575b601f0160051c7fb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf601905b81811061106b5750610e03565b5f815560010161105e565b7fb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf69150611034565b346104435760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610443577fffffffff000000000000000000000000000000000000000000000000000000006110f6612d26565b165f52600a602052602060405f205460e01b7fffffffff0000000000000000000000000000000000000000000000000000000060405191168152f35b346104435761114036612d55565b93509350505067ffffffffffffffff811161041657611160600554612b0d565b601f811161139c575b505f601f82116001146112e45781925f926112d9575b50507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8260011b9260031b1c1916176005555b7f8db2b652000000000000000000000000000000000000000000000000000000005f52600a6020527faf2d1eda278984c26a26b0c3e4f6b3c0be70f0f53825d8b865bc101b251f22405460e01b7fffffffff0000000000000000000000000000000000000000000000000000000016611283576104b97f8db2b652000000000000000000000000000000000000000000000000000000005b604080517fffffffff0000000000000000000000000000000000000000000000000000000090921682525f602083015290918291820190565b7f8db2b652000000000000000000000000000000000000000000000000000000005f52600a6020527faf2d1eda278984c26a26b0c3e4f6b3c0be70f0f53825d8b865bc101b251f2240546104b99060e01b61124a565b01359050828061117f565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08216927f036b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db0915f5b8581106113845750836001951061134c575b505050811b016005556111b2565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60f88560031b161c1991013516905582808061133e565b9092602060018192868601358155019401910161132c565b601f820160051c7f036b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db0019060208310611411575b601f0160051c7f036b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db001905b8181106114065750611169565b5f81556001016113f9565b7f036b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db091506113cf565b34610443575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610443576040515f60055461147781612b0d565b808452906001811690811561051b575060011461149e576104b9836104ad81850382612b5e565b60055f9081527f036b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db0939250905b8082106114e2575090915081016020016104ad61049d565b9192600181602092548385880101520191019092916114ca565b34610443577ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360160c081126104435760a0136104435760a43561ffff81168091036104435760405160a0810181811067ffffffffffffffff82111761041657604052611567612be7565b815260243573ffffffffffffffffffffffffffffffffffffffff8116810361044357602082015260443562ffffff811681036104435760408201526064358060020b81036104435760608201526084359073ffffffffffffffffffffffffffffffffffffffff821682036104435760a0916080820152205f52600b60205260405f20907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00008254161790555f80f35b34610443575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610443576040515f60095461165381612b0d565b808452906001811690811561051b575060011461167a576104b9836104ad81850382612b5e565b60095f9081527f6e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7af939250905b8082106116be575090915081016020016104ad61049d565b9192600181602092548385880101520191019092916116a6565b34610443575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610443576040515f60075461171681612b0d565b808452906001811690811561051b575060011461173d576104b9836104ad81850382612b5e565b60075f9081527fa66cc928b5edb82af9bd49922954155ab7b0942694bea4ce44661d9a8736c688939250905b808210611781575090915081016020016104ad61049d565b919260018160209254838588010152019101909291611769565b34610443576117a936612d55565b93509350505067ffffffffffffffff8111610416576117c9600354612b0d565b601f81116119d6575b505f601f821160011461191e5781925f92611913575b50507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8260011b9260031b1c1916176003555b7f5a2a8100000000000000000000000000000000000000000000000000000000005f52600a6020527fe758c549c0b8d2032eb1bd311ad4675db345bff5f7b6ad36aafb50c20921730c5460e01b7fffffffff00000000000000000000000000000000000000000000000000000000166118bd57604080517f5a2a81000000000000000000000000000000000000000000000000000000000081525f6020820152f35b7f5a2a8100000000000000000000000000000000000000000000000000000000005f52600a6020527fe758c549c0b8d2032eb1bd311ad4675db345bff5f7b6ad36aafb50c20921730c546104b99060e01b61124a565b0135905082806117e8565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08216927fc2575a0e9e593c00f959f8c92f12db2869c3395a3b0502d05e2516446f71f85b915f5b8581106119be57508360019510611986575b505050811b0160035561181b565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60f88560031b161c19910135169055828080611978565b90926020600181928686013581550194019101611966565b601f820160051c7fc2575a0e9e593c00f959f8c92f12db2869c3395a3b0502d05e2516446f71f85b019060208310611a4b575b601f0160051c7fc2575a0e9e593c00f959f8c92f12db2869c3395a3b0502d05e2516446f71f85b01905b818110611a4057506117d2565b5f8155600101611a33565b7fc2575a0e9e593c00f959f8c92f12db2869c3395a3b0502d05e2516446f71f85b9150611a09565b346104435760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261044357611aaa612d26565b602435907fffffffff0000000000000000000000000000000000000000000000000000000082168203610443577fffffffff00000000000000000000000000000000000000000000000000000000165f52600a60205260405f209060e01c7fffffffffffffffffffffffffffffffffffffffffffffffffffffffff000000008254161790555f80f35b34610443576101407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261044357611b6b612be7565b5060a07fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffdc3601126104435760607fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff3c360112610443576101243567ffffffffffffffff811161044357611be1903690600401612c0a565b67ffffffffffffffff811161041657611bfb600654612b0d565b601f8111611e32575b505f601f8211600114611d7a5781925f92611d6f575b50507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8260011b9260031b1c1916176006555b7f575e24b4000000000000000000000000000000000000000000000000000000005f52600a6020527f8f4f5a3132b3286a8e7a4ddb5cd55fe3b98d5fc42a66d217eae1c84b873ebaf25460e01b7fffffffff0000000000000000000000000000000000000000000000000000000016611d1a5760607f575e24b4000000000000000000000000000000000000000000000000000000005b7fffffffff00000000000000000000000000000000000000000000000000000000604051911681525f60208201525f6040820152f35b7f575e24b4000000000000000000000000000000000000000000000000000000005f52600a6020527f8f4f5a3132b3286a8e7a4ddb5cd55fe3b98d5fc42a66d217eae1c84b873ebaf25460609060e01b611ce4565b013590508280611c1a565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08216927ff652222313e28459528d920b65115c16c04f3efc82aaedc97be59f3f377c0d3f915f5b858110611e1a57508360019510611de2575b505050811b01600655611c4d565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60f88560031b161c19910135169055828080611dd4565b90926020600181928686013581550194019101611dc2565b601f820160051c7ff652222313e28459528d920b65115c16c04f3efc82aaedc97be59f3f377c0d3f019060208310611ea7575b601f0160051c7ff652222313e28459528d920b65115c16c04f3efc82aaedc97be59f3f377c0d3f01905b818110611e9c5750611c04565b5f8155600101611e8f565b7ff652222313e28459528d920b65115c16c04f3efc82aaedc97be59f3f377c0d3f9150611e65565b34610443575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610443576040515f600654611f0d81612b0d565b808452906001811690811561051b5750600114611f34576104b9836104ad81850382612b5e565b60065f9081527ff652222313e28459528d920b65115c16c04f3efc82aaedc97be59f3f377c0d3f939250905b808210611f78575090915081016020016104ad61049d565b919260018160209254838588010152019101909291611f60565b34610443575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610443576040515f8054611fcf81612b0d565b808452906001811690811561051b5750600114611ff6576104b9836104ad81850382612b5e565b5f8080527f290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563939250905b808210612038575090915081016020016104ad61049d565b919260018160209254838588010152019101909291612020565b34610443575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610443576040515f60045461209081612b0d565b808452906001811690811561051b57506001146120b7576104b9836104ad81850382612b5e565b60045f9081527f8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd19b939250905b8082106120fb575090915081016020016104ad61049d565b9192600181602092548385880101520191019092916120e3565b34610443576101007ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126104435761214d612be7565b5060a07fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffdc36011261044357612180612d03565b5060e43567ffffffffffffffff8111610443576121a1903690600401612c0a565b67ffffffffffffffff8111610416576121ba5f54612b0d565b601f81116123bf575b505f601f82116001146123085781925f926122fd575b50507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8260011b9260031b1c1916175f555b7f3440d820000000000000000000000000000000000000000000000000000000005f52600a6020527f6f932b1d2c5ebee2a67a1e9784cf9684c2c9b84dcc0b9f7509ef70b3f6375d355460e01b7fffffffff00000000000000000000000000000000000000000000000000000000166122a9576040517f3440d820000000000000000000000000000000000000000000000000000000008152602090f35b7f3440d820000000000000000000000000000000000000000000000000000000005f52600a60209081527f6f932b1d2c5ebee2a67a1e9784cf9684c2c9b84dcc0b9f7509ef70b3f6375d355460e01b610238565b0135905082806121d9565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08216927f290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563915f5b8581106123a75750836001951061236f575b505050811b015f5561220b565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60f88560031b161c19910135169055828080612362565b90926020600181928686013581550194019101612350565b601f820160051c7f290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563019060208310612434575b601f0160051c7f290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e56301905b81811061242957506121c3565b5f815560010161241c565b7f290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e56391506123f2565b346104435761246a36612c38565b925092505067ffffffffffffffff811161041657612489600254612b0d565b601f8111612690575b505f601f82116001146125d85781925f926125cd575b50507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8260011b9260031b1c1916176002555b7f259982e5000000000000000000000000000000000000000000000000000000005f52600a6020527fc3eb8857b979a39a232f594aca1feb3d3a12b1f808751651f517ed9effc532795460e01b7fffffffff0000000000000000000000000000000000000000000000000000000016612579576040517f259982e5000000000000000000000000000000000000000000000000000000008152602090f35b7f259982e5000000000000000000000000000000000000000000000000000000005f52600a60209081527fc3eb8857b979a39a232f594aca1feb3d3a12b1f808751651f517ed9effc532795460e01b610238565b0135905082806124a8565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08216927f405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace915f5b85811061267857508360019510612640575b505050811b016002556124db565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60f88560031b161c19910135169055828080612632565b90926020600181928686013581550194019101612620565b601f820160051c7f405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace019060208310612705575b601f0160051c7f405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace01905b8181106126fa5750612492565b5f81556001016126ed565b7f405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace91506126c3565b346104435761273b36612c38565b925092505067ffffffffffffffff81116104165761275a600454612b0d565b601f8111612961575b505f601f82116001146128a95781925f9261289e575b50507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8260011b9260031b1c1916176004555b7f21d0ee70000000000000000000000000000000000000000000000000000000005f52600a6020527f3ca76996c4de3804eeab337bff8d944de8de2379662c8666e6ffe7bfa23a1b435460e01b7fffffffff000000000000000000000000000000000000000000000000000000001661284a576040517f21d0ee70000000000000000000000000000000000000000000000000000000008152602090f35b7f21d0ee70000000000000000000000000000000000000000000000000000000005f52600a60209081527f3ca76996c4de3804eeab337bff8d944de8de2379662c8666e6ffe7bfa23a1b435460e01b610238565b013590508280612779565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08216927f8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd19b915f5b85811061294957508360019510612911575b505050811b016004556127ac565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60f88560031b161c19910135169055828080612903565b909260206001819286860135815501940191016128f1565b601f820160051c7f8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd19b0190602083106129d6575b601f0160051c7f8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd19b01905b8181106129cb5750612763565b5f81556001016129be565b7f8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd19b9150612994565b346104435760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610443576004355f52600b602052602061ffff60405f205416604051908152f35b34610443575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610443576040515f600154612a8881612b0d565b808452906001811690811561051b5750600114612aaf576104b9836104ad81850382612b5e565b60015f9081527fb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6939250905b808210612af3575090915081016020016104ad61049d565b919260018160209254838588010152019101909291612adb565b90600182811c92168015612b54575b6020831014612b2757565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602260045260245ffd5b91607f1691612b1c565b90601f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0910116810190811067ffffffffffffffff82111761041657604052565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f602060409481855280519182918282880152018686015e5f8582860101520116010190565b6004359073ffffffffffffffffffffffffffffffffffffffff8216820361044357565b9181601f840112156104435782359167ffffffffffffffff8311610443576020838186019501011161044357565b906101607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc8301126104435760043573ffffffffffffffffffffffffffffffffffffffff81168103610443579160a07fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffdc8201126104435760249160807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff3c8301126104435760c491610144359067ffffffffffffffff821161044357612cff91600401612c0a565b9091565b60c4359073ffffffffffffffffffffffffffffffffffffffff8216820361044357565b600435907fffffffff000000000000000000000000000000000000000000000000000000008216820361044357565b6101807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc8201126104435760043573ffffffffffffffffffffffffffffffffffffffff81168103610443579160a07fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffdc8301126104435760249160807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff3c8201126104435760c4916101443591610164359067ffffffffffffffff821161044357612cff91600401612c0a565b60e435908160020b820361044357565b6101207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc8201126104435760043573ffffffffffffffffffffffffffffffffffffffff81168103610443579160a07fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffdc8301126104435760249160c4359160e43591610104359067ffffffffffffffff821161044357612cff91600401612c0a56fea26469706673582212206697e62ca0632d49458cbced7fba63af5cf63d8cb0640fddf69567718473e3a764736f6c634300081a0033
    /// ```
    #[rustfmt::skip]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80\x80`@R4`\x15Wa/\x07\x90\x81a\0\x1A\x829\xF3[_\x80\xFD\xFE`\x80`@R`\x046\x10\x15a\0\x11W_\x80\xFD[_5`\xE0\x1C\x80c\n-X'\x14a*JW\x80c\x17\xBDa#\x14a)\xFEW\x80c!\xD0\xEEp\x14a'-W\x80c%\x99\x82\xE5\x14a$\\W\x80c4@\xD8 \x14a!\x15W\x80cM\x08\x1C~\x14a RW\x80cP\xCD\x07\xEB\x14a\x1F\x92W\x80cT.\x93i\x14a\x1E\xCFW\x80cW^$\xB4\x14a\x1B3W\x80cYA\xB5\xBB\x14a\x1AsW\x80cZ*\x81\0\x14a\x17\x9BW\x80cb.`\xDE\x14a\x16\xD8W\x80cp\xB2\x8E\xDA\x14a\x16\x15W\x80cz3\x85\xF5\x14a\x14\xFCW\x80c~G/\xB2\x14a\x149W\x80c\x8D\xB2\xB6R\x14a\x112W\x80c\xA2\xBC\x94\xAD\x14a\x10\x9EW\x80c\xA9\x10\xF8\x0F\x14a\rJW\x80c\xAFW\xC1\x84\x14a\x0C\x87W\x80c\xB4{/\xB1\x14a\x08\xF2W\x80c\xB6\xA8\xB0\xFA\x14a\x06 W\x80c\xB8Qdf\x14a\x05]W\x80c\xDBmv\xA2\x14a\x04GWc\xE1\xB4\xAFi\x14a\x01!W_\x80\xFD[4a\x04CWa\x01/6a.0V[\x93P\x93PPPg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x04\x16Wa\x01O`\tTa+\rV[`\x1F\x81\x11a\x03yW[P_`\x1F\x82\x11`\x01\x14a\x02\xC1W\x81\x92_\x92a\x02\xB6W[PP\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82`\x01\x1B\x92`\x03\x1B\x1C\x19\x16\x17`\tU[\x7F\xE1\xB4\xAFi\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\n` R\x7F>\x1C\xFF~\t\xCCL\xB6\x04\xC0\xC0\x17\xAD\xD8V\xC5ue\"\xD5\xE4\xDF\xC0\x8F\xA7\x94\xB6\xE2\xE9\xF5\xC0\xE9T`\xE0\x1B\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16a\x02bW` \x7F\xE1\xB4\xAFi\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0[\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`@Q\x91\x16\x81R\xF3[\x7F\xE1\xB4\xAFi\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\n` \x90\x81R\x7F>\x1C\xFF~\t\xCCL\xB6\x04\xC0\xC0\x17\xAD\xD8V\xC5ue\"\xD5\xE4\xDF\xC0\x8F\xA7\x94\xB6\xE2\xE9\xF5\xC0\xE9T`\xE0\x1Ba\x028V[\x015\x90P_\x80a\x01nV[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x82\x16\x92\x7Fn\x15@\x17\x1Bl\x0C\x96\x0Bq\xA7\x02\r\x9F`\x07\x7Fj\xF91\xA8\xBB\xF5\x90\xDA\x02#\xDA\xCFu\xC7\xAF\x91_[\x85\x81\x10a\x03aWP\x83`\x01\x95\x10a\x03)W[PPP\x81\x1B\x01`\tUa\x01\xA1V[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\xF8\x85`\x03\x1B\x16\x1C\x19\x91\x015\x16\x90U_\x80\x80a\x03\x1BV[\x90\x92` `\x01\x81\x92\x86\x86\x015\x81U\x01\x94\x01\x91\x01a\x03\tV[`\x1F\x82\x01`\x05\x1C\x7Fn\x15@\x17\x1Bl\x0C\x96\x0Bq\xA7\x02\r\x9F`\x07\x7Fj\xF91\xA8\xBB\xF5\x90\xDA\x02#\xDA\xCFu\xC7\xAF\x01\x90` \x83\x10a\x03\xEEW[`\x1F\x01`\x05\x1C\x7Fn\x15@\x17\x1Bl\x0C\x96\x0Bq\xA7\x02\r\x9F`\x07\x7Fj\xF91\xA8\xBB\xF5\x90\xDA\x02#\xDA\xCFu\xC7\xAF\x01\x90[\x81\x81\x10a\x03\xE3WPa\x01XV[_\x81U`\x01\x01a\x03\xD6V[\x7Fn\x15@\x17\x1Bl\x0C\x96\x0Bq\xA7\x02\r\x9F`\x07\x7Fj\xF91\xA8\xBB\xF5\x90\xDA\x02#\xDA\xCFu\xC7\xAF\x91Pa\x03\xACV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`A`\x04R`$_\xFD[_\x80\xFD[4a\x04CW_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x04CW`@Q_`\x02Ta\x04\x85\x81a+\rV[\x80\x84R\x90`\x01\x81\x16\x90\x81\x15a\x05\x1BWP`\x01\x14a\x04\xBDW[a\x04\xB9\x83a\x04\xAD\x81\x85\x03\x82a+^V[`@Q\x91\x82\x91\x82a+\x9FV[\x03\x90\xF3[`\x02_\x90\x81R\x7F@W\x87\xFA\x12\xA8#\xE0\xF2\xB7c\x1C\xC4\x1B;\xA8\x82\x8B3!\xCA\x81\x11\x11\xFAu\xCD:\xA3\xBBZ\xCE\x93\x92P\x90[\x80\x82\x10a\x05\x01WP\x90\x91P\x81\x01` \x01a\x04\xADa\x04\x9DV[\x91\x92`\x01\x81` \x92T\x83\x85\x88\x01\x01R\x01\x91\x01\x90\x92\x91a\x04\xE9V[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\x16` \x80\x86\x01\x91\x90\x91R\x91\x15\x15`\x05\x1B\x84\x01\x90\x91\x01\x91Pa\x04\xAD\x90Pa\x04\x9DV[4a\x04CW_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x04CW`@Q_`\x03Ta\x05\x9B\x81a+\rV[\x80\x84R\x90`\x01\x81\x16\x90\x81\x15a\x05\x1BWP`\x01\x14a\x05\xC2Wa\x04\xB9\x83a\x04\xAD\x81\x85\x03\x82a+^V[`\x03_\x90\x81R\x7F\xC2WZ\x0E\x9EY<\0\xF9Y\xF8\xC9/\x12\xDB(i\xC39Z;\x05\x02\xD0^%\x16Doq\xF8[\x93\x92P\x90[\x80\x82\x10a\x06\x06WP\x90\x91P\x81\x01` \x01a\x04\xADa\x04\x9DV[\x91\x92`\x01\x81` \x92T\x83\x85\x88\x01\x01R\x01\x91\x01\x90\x92\x91a\x05\xEEV[4a\x04CWa\x06.6a.0V[\x93P\x93PPPg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x04\x16Wa\x06N`\x08Ta+\rV[`\x1F\x81\x11a\x08UW[P_`\x1F\x82\x11`\x01\x14a\x07\x9DW\x81\x92_\x92a\x07\x92W[PP\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82`\x01\x1B\x92`\x03\x1B\x1C\x19\x16\x17`\x08U[\x7F\xB6\xA8\xB0\xFA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\n` R\x7F\xC0 \xF4\xCBz\n\xE9\xBA\\Y\x0F\xBB'(\xBB\xAB\x87\xFC\x8F\x06\x8At\xC7\x04,\xA3\xF2\xF2|\xC5\x19\xF7T`\xE0\x1B\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16a\x07>W`@Q\x7F\xB6\xA8\xB0\xFA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` \x90\xF3[\x7F\xB6\xA8\xB0\xFA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\n` \x90\x81R\x7F\xC0 \xF4\xCBz\n\xE9\xBA\\Y\x0F\xBB'(\xBB\xAB\x87\xFC\x8F\x06\x8At\xC7\x04,\xA3\xF2\xF2|\xC5\x19\xF7T`\xE0\x1Ba\x028V[\x015\x90P\x82\x80a\x06mV[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x82\x16\x92\x7F\xF3\xF7\xA9\xFE6O\xAA\xB9;!m\xA5\n2\x14\x15O\"\xA0\xA2\xB4\x15\xB2:\x84\xC8\x16\x9E\x8Bcn\xE3\x91_[\x85\x81\x10a\x08=WP\x83`\x01\x95\x10a\x08\x05W[PPP\x81\x1B\x01`\x08Ua\x06\xA0V[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\xF8\x85`\x03\x1B\x16\x1C\x19\x91\x015\x16\x90U\x82\x80\x80a\x07\xF7V[\x90\x92` `\x01\x81\x92\x86\x86\x015\x81U\x01\x94\x01\x91\x01a\x07\xE5V[`\x1F\x82\x01`\x05\x1C\x7F\xF3\xF7\xA9\xFE6O\xAA\xB9;!m\xA5\n2\x14\x15O\"\xA0\xA2\xB4\x15\xB2:\x84\xC8\x16\x9E\x8Bcn\xE3\x01\x90` \x83\x10a\x08\xCAW[`\x1F\x01`\x05\x1C\x7F\xF3\xF7\xA9\xFE6O\xAA\xB9;!m\xA5\n2\x14\x15O\"\xA0\xA2\xB4\x15\xB2:\x84\xC8\x16\x9E\x8Bcn\xE3\x01\x90[\x81\x81\x10a\x08\xBFWPa\x06WV[_\x81U`\x01\x01a\x08\xB2V[\x7F\xF3\xF7\xA9\xFE6O\xAA\xB9;!m\xA5\n2\x14\x15O\"\xA0\xA2\xB4\x15\xB2:\x84\xC8\x16\x9E\x8Bcn\xE3\x91Pa\x08\x88V[4a\x04CWa\x01`\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x04CWa\t*a+\xE7V[P`\xA0\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xDC6\x01\x12a\x04CW``\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF<6\x01\x12a\x04CWa\x01D5g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x04CWa\t\xA0\x906\x90`\x04\x01a,\nV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x04\x16Wa\t\xBA`\x07Ta+\rV[`\x1F\x81\x11a\x0B\xEAW[P_`\x1F\x82\x11`\x01\x14a\x0B2W\x81\x92_\x92a\x0B'W[PP\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82`\x01\x1B\x92`\x03\x1B\x1C\x19\x16\x17`\x07U[\x7F\xB4{/\xB1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\n` R\x7F$\x91\xB1\xA3\xE0^\xB9\x15Y]\xD2\xD1u5\xE9\xDDB\x80\xB7\xE1\xDC>\x97\xBD\x13\x82\x88>L\x86(cT`\xE0\x1B\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16a\n\xD2W`@\x7F\xB4{/\xB1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0[\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82Q\x91\x16\x81R_` \x82\x01R\xF3[\x7F\xB4{/\xB1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\n` R\x7F$\x91\xB1\xA3\xE0^\xB9\x15Y]\xD2\xD1u5\xE9\xDDB\x80\xB7\xE1\xDC>\x97\xBD\x13\x82\x88>L\x86(cT`@\x90`\xE0\x1Ba\n\xA3V[\x015\x90P\x82\x80a\t\xD9V[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x82\x16\x92\x7F\xA6l\xC9(\xB5\xED\xB8*\xF9\xBDI\x92)T\x15Z\xB7\xB0\x94&\x94\xBE\xA4\xCEDf\x1D\x9A\x876\xC6\x88\x91_[\x85\x81\x10a\x0B\xD2WP\x83`\x01\x95\x10a\x0B\x9AW[PPP\x81\x1B\x01`\x07Ua\n\x0CV[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\xF8\x85`\x03\x1B\x16\x1C\x19\x91\x015\x16\x90U\x82\x80\x80a\x0B\x8CV[\x90\x92` `\x01\x81\x92\x86\x86\x015\x81U\x01\x94\x01\x91\x01a\x0BzV[`\x1F\x82\x01`\x05\x1C\x7F\xA6l\xC9(\xB5\xED\xB8*\xF9\xBDI\x92)T\x15Z\xB7\xB0\x94&\x94\xBE\xA4\xCEDf\x1D\x9A\x876\xC6\x88\x01\x90` \x83\x10a\x0C_W[`\x1F\x01`\x05\x1C\x7F\xA6l\xC9(\xB5\xED\xB8*\xF9\xBDI\x92)T\x15Z\xB7\xB0\x94&\x94\xBE\xA4\xCEDf\x1D\x9A\x876\xC6\x88\x01\x90[\x81\x81\x10a\x0CTWPa\t\xC3V[_\x81U`\x01\x01a\x0CGV[\x7F\xA6l\xC9(\xB5\xED\xB8*\xF9\xBDI\x92)T\x15Z\xB7\xB0\x94&\x94\xBE\xA4\xCEDf\x1D\x9A\x876\xC6\x88\x91Pa\x0C\x1DV[4a\x04CW_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x04CW`@Q_`\x08Ta\x0C\xC5\x81a+\rV[\x80\x84R\x90`\x01\x81\x16\x90\x81\x15a\x05\x1BWP`\x01\x14a\x0C\xECWa\x04\xB9\x83a\x04\xAD\x81\x85\x03\x82a+^V[`\x08_\x90\x81R\x7F\xF3\xF7\xA9\xFE6O\xAA\xB9;!m\xA5\n2\x14\x15O\"\xA0\xA2\xB4\x15\xB2:\x84\xC8\x16\x9E\x8Bcn\xE3\x93\x92P\x90[\x80\x82\x10a\r0WP\x90\x91P\x81\x01` \x01a\x04\xADa\x04\x9DV[\x91\x92`\x01\x81` \x92T\x83\x85\x88\x01\x01R\x01\x91\x01\x90\x92\x91a\r\x18V[4a\x04CWa\x01 \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x04CWa\r\x82a+\xE7V[P`\xA0\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xDC6\x01\x12a\x04CWa\r\xB5a-\x03V[Pa\r\xBEa. V[Pa\x01\x045g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x04CWa\r\xE0\x906\x90`\x04\x01a,\nV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x04\x16Wa\r\xFA`\x01Ta+\rV[`\x1F\x81\x11a\x10\x01W[P_`\x1F\x82\x11`\x01\x14a\x0FIW\x81\x92_\x92a\x0F>W[PP\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82`\x01\x1B\x92`\x03\x1B\x1C\x19\x16\x17`\x01U[\x7F\xA9\x10\xF8\x0F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\n` R\x7Fk\xF6\xB3\xC2f\x8C\xBE\x14\x1Es\xF2\x94\x7F\xC4\xA6\x1F\x0F\xA3\xDD\t^48\xF5\xF1D\xC8\xE9\x81M9\x0BT`\xE0\x1B\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16a\x0E\xEAW`@Q\x7F\xA9\x10\xF8\x0F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` \x90\xF3[\x7F\xA9\x10\xF8\x0F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\n` \x90\x81R\x7Fk\xF6\xB3\xC2f\x8C\xBE\x14\x1Es\xF2\x94\x7F\xC4\xA6\x1F\x0F\xA3\xDD\t^48\xF5\xF1D\xC8\xE9\x81M9\x0BT`\xE0\x1Ba\x028V[\x015\x90P\x82\x80a\x0E\x19V[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x82\x16\x92\x7F\xB1\x0E-Rv\x12\x07;&\xEE\xCD\xFDq~j2\x0C\xF4KJ\xFA\xC2\xB0s-\x9F\xCB\xE2\xB7\xFA\x0C\xF6\x91_[\x85\x81\x10a\x0F\xE9WP\x83`\x01\x95\x10a\x0F\xB1W[PPP\x81\x1B\x01`\x01Ua\x0ELV[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\xF8\x85`\x03\x1B\x16\x1C\x19\x91\x015\x16\x90U\x82\x80\x80a\x0F\xA3V[\x90\x92` `\x01\x81\x92\x86\x86\x015\x81U\x01\x94\x01\x91\x01a\x0F\x91V[`\x1F\x82\x01`\x05\x1C\x7F\xB1\x0E-Rv\x12\x07;&\xEE\xCD\xFDq~j2\x0C\xF4KJ\xFA\xC2\xB0s-\x9F\xCB\xE2\xB7\xFA\x0C\xF6\x01\x90` \x83\x10a\x10vW[`\x1F\x01`\x05\x1C\x7F\xB1\x0E-Rv\x12\x07;&\xEE\xCD\xFDq~j2\x0C\xF4KJ\xFA\xC2\xB0s-\x9F\xCB\xE2\xB7\xFA\x0C\xF6\x01\x90[\x81\x81\x10a\x10kWPa\x0E\x03V[_\x81U`\x01\x01a\x10^V[\x7F\xB1\x0E-Rv\x12\x07;&\xEE\xCD\xFDq~j2\x0C\xF4KJ\xFA\xC2\xB0s-\x9F\xCB\xE2\xB7\xFA\x0C\xF6\x91Pa\x104V[4a\x04CW` \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x04CW\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x10\xF6a-&V[\x16_R`\n` R` `@_ T`\xE0\x1B\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`@Q\x91\x16\x81R\xF3[4a\x04CWa\x11@6a-UV[\x93P\x93PPPg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x04\x16Wa\x11``\x05Ta+\rV[`\x1F\x81\x11a\x13\x9CW[P_`\x1F\x82\x11`\x01\x14a\x12\xE4W\x81\x92_\x92a\x12\xD9W[PP\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82`\x01\x1B\x92`\x03\x1B\x1C\x19\x16\x17`\x05U[\x7F\x8D\xB2\xB6R\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\n` R\x7F\xAF-\x1E\xDA'\x89\x84\xC2j&\xB0\xC3\xE4\xF6\xB3\xC0\xBEp\xF0\xF58%\xD8\xB8e\xBC\x10\x1B%\x1F\"@T`\xE0\x1B\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16a\x12\x83Wa\x04\xB9\x7F\x8D\xB2\xB6R\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0[`@\x80Q\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\x92\x16\x82R_` \x83\x01R\x90\x91\x82\x91\x82\x01\x90V[\x7F\x8D\xB2\xB6R\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\n` R\x7F\xAF-\x1E\xDA'\x89\x84\xC2j&\xB0\xC3\xE4\xF6\xB3\xC0\xBEp\xF0\xF58%\xD8\xB8e\xBC\x10\x1B%\x1F\"@Ta\x04\xB9\x90`\xE0\x1Ba\x12JV[\x015\x90P\x82\x80a\x11\x7FV[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x82\x16\x92\x7F\x03kc\x84\xB5\xEC\xA7\x91\xC6'a\x15-\x0Cy\xBB\x06\x04\xC1\x04\xA5\xFBoN\xB0p?1T\xBB=\xB0\x91_[\x85\x81\x10a\x13\x84WP\x83`\x01\x95\x10a\x13LW[PPP\x81\x1B\x01`\x05Ua\x11\xB2V[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\xF8\x85`\x03\x1B\x16\x1C\x19\x91\x015\x16\x90U\x82\x80\x80a\x13>V[\x90\x92` `\x01\x81\x92\x86\x86\x015\x81U\x01\x94\x01\x91\x01a\x13,V[`\x1F\x82\x01`\x05\x1C\x7F\x03kc\x84\xB5\xEC\xA7\x91\xC6'a\x15-\x0Cy\xBB\x06\x04\xC1\x04\xA5\xFBoN\xB0p?1T\xBB=\xB0\x01\x90` \x83\x10a\x14\x11W[`\x1F\x01`\x05\x1C\x7F\x03kc\x84\xB5\xEC\xA7\x91\xC6'a\x15-\x0Cy\xBB\x06\x04\xC1\x04\xA5\xFBoN\xB0p?1T\xBB=\xB0\x01\x90[\x81\x81\x10a\x14\x06WPa\x11iV[_\x81U`\x01\x01a\x13\xF9V[\x7F\x03kc\x84\xB5\xEC\xA7\x91\xC6'a\x15-\x0Cy\xBB\x06\x04\xC1\x04\xA5\xFBoN\xB0p?1T\xBB=\xB0\x91Pa\x13\xCFV[4a\x04CW_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x04CW`@Q_`\x05Ta\x14w\x81a+\rV[\x80\x84R\x90`\x01\x81\x16\x90\x81\x15a\x05\x1BWP`\x01\x14a\x14\x9EWa\x04\xB9\x83a\x04\xAD\x81\x85\x03\x82a+^V[`\x05_\x90\x81R\x7F\x03kc\x84\xB5\xEC\xA7\x91\xC6'a\x15-\x0Cy\xBB\x06\x04\xC1\x04\xA5\xFBoN\xB0p?1T\xBB=\xB0\x93\x92P\x90[\x80\x82\x10a\x14\xE2WP\x90\x91P\x81\x01` \x01a\x04\xADa\x04\x9DV[\x91\x92`\x01\x81` \x92T\x83\x85\x88\x01\x01R\x01\x91\x01\x90\x92\x91a\x14\xCAV[4a\x04CW\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01`\xC0\x81\x12a\x04CW`\xA0\x13a\x04CW`\xA45a\xFF\xFF\x81\x16\x80\x91\x03a\x04CW`@Q`\xA0\x81\x01\x81\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x04\x16W`@Ra\x15ga+\xE7V[\x81R`$5s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x81\x03a\x04CW` \x82\x01R`D5b\xFF\xFF\xFF\x81\x16\x81\x03a\x04CW`@\x82\x01R`d5\x80`\x02\x0B\x81\x03a\x04CW``\x82\x01R`\x845\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x82\x03a\x04CW`\xA0\x91`\x80\x82\x01R _R`\x0B` R`@_ \x90\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\x82T\x16\x17\x90U_\x80\xF3[4a\x04CW_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x04CW`@Q_`\tTa\x16S\x81a+\rV[\x80\x84R\x90`\x01\x81\x16\x90\x81\x15a\x05\x1BWP`\x01\x14a\x16zWa\x04\xB9\x83a\x04\xAD\x81\x85\x03\x82a+^V[`\t_\x90\x81R\x7Fn\x15@\x17\x1Bl\x0C\x96\x0Bq\xA7\x02\r\x9F`\x07\x7Fj\xF91\xA8\xBB\xF5\x90\xDA\x02#\xDA\xCFu\xC7\xAF\x93\x92P\x90[\x80\x82\x10a\x16\xBEWP\x90\x91P\x81\x01` \x01a\x04\xADa\x04\x9DV[\x91\x92`\x01\x81` \x92T\x83\x85\x88\x01\x01R\x01\x91\x01\x90\x92\x91a\x16\xA6V[4a\x04CW_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x04CW`@Q_`\x07Ta\x17\x16\x81a+\rV[\x80\x84R\x90`\x01\x81\x16\x90\x81\x15a\x05\x1BWP`\x01\x14a\x17=Wa\x04\xB9\x83a\x04\xAD\x81\x85\x03\x82a+^V[`\x07_\x90\x81R\x7F\xA6l\xC9(\xB5\xED\xB8*\xF9\xBDI\x92)T\x15Z\xB7\xB0\x94&\x94\xBE\xA4\xCEDf\x1D\x9A\x876\xC6\x88\x93\x92P\x90[\x80\x82\x10a\x17\x81WP\x90\x91P\x81\x01` \x01a\x04\xADa\x04\x9DV[\x91\x92`\x01\x81` \x92T\x83\x85\x88\x01\x01R\x01\x91\x01\x90\x92\x91a\x17iV[4a\x04CWa\x17\xA96a-UV[\x93P\x93PPPg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x04\x16Wa\x17\xC9`\x03Ta+\rV[`\x1F\x81\x11a\x19\xD6W[P_`\x1F\x82\x11`\x01\x14a\x19\x1EW\x81\x92_\x92a\x19\x13W[PP\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82`\x01\x1B\x92`\x03\x1B\x1C\x19\x16\x17`\x03U[\x7FZ*\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\n` R\x7F\xE7X\xC5I\xC0\xB8\xD2\x03.\xB1\xBD1\x1A\xD4g]\xB3E\xBF\xF5\xF7\xB6\xAD6\xAA\xFBP\xC2\t!s\x0CT`\xE0\x1B\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16a\x18\xBDW`@\x80Q\x7FZ*\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R_` \x82\x01R\xF3[\x7FZ*\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\n` R\x7F\xE7X\xC5I\xC0\xB8\xD2\x03.\xB1\xBD1\x1A\xD4g]\xB3E\xBF\xF5\xF7\xB6\xAD6\xAA\xFBP\xC2\t!s\x0CTa\x04\xB9\x90`\xE0\x1Ba\x12JV[\x015\x90P\x82\x80a\x17\xE8V[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x82\x16\x92\x7F\xC2WZ\x0E\x9EY<\0\xF9Y\xF8\xC9/\x12\xDB(i\xC39Z;\x05\x02\xD0^%\x16Doq\xF8[\x91_[\x85\x81\x10a\x19\xBEWP\x83`\x01\x95\x10a\x19\x86W[PPP\x81\x1B\x01`\x03Ua\x18\x1BV[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\xF8\x85`\x03\x1B\x16\x1C\x19\x91\x015\x16\x90U\x82\x80\x80a\x19xV[\x90\x92` `\x01\x81\x92\x86\x86\x015\x81U\x01\x94\x01\x91\x01a\x19fV[`\x1F\x82\x01`\x05\x1C\x7F\xC2WZ\x0E\x9EY<\0\xF9Y\xF8\xC9/\x12\xDB(i\xC39Z;\x05\x02\xD0^%\x16Doq\xF8[\x01\x90` \x83\x10a\x1AKW[`\x1F\x01`\x05\x1C\x7F\xC2WZ\x0E\x9EY<\0\xF9Y\xF8\xC9/\x12\xDB(i\xC39Z;\x05\x02\xD0^%\x16Doq\xF8[\x01\x90[\x81\x81\x10a\x1A@WPa\x17\xD2V[_\x81U`\x01\x01a\x1A3V[\x7F\xC2WZ\x0E\x9EY<\0\xF9Y\xF8\xC9/\x12\xDB(i\xC39Z;\x05\x02\xD0^%\x16Doq\xF8[\x91Pa\x1A\tV[4a\x04CW`@\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x04CWa\x1A\xAAa-&V[`$5\x90\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x16\x82\x03a\x04CW\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16_R`\n` R`@_ \x90`\xE0\x1C\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\x82T\x16\x17\x90U_\x80\xF3[4a\x04CWa\x01@\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x04CWa\x1Bka+\xE7V[P`\xA0\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xDC6\x01\x12a\x04CW``\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF<6\x01\x12a\x04CWa\x01$5g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x04CWa\x1B\xE1\x906\x90`\x04\x01a,\nV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x04\x16Wa\x1B\xFB`\x06Ta+\rV[`\x1F\x81\x11a\x1E2W[P_`\x1F\x82\x11`\x01\x14a\x1DzW\x81\x92_\x92a\x1DoW[PP\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82`\x01\x1B\x92`\x03\x1B\x1C\x19\x16\x17`\x06U[\x7FW^$\xB4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\n` R\x7F\x8FOZ12\xB3(j\x8EzM\xDB\\\xD5_\xE3\xB9\x8D_\xC4*f\xD2\x17\xEA\xE1\xC8K\x87>\xBA\xF2T`\xE0\x1B\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16a\x1D\x1AW``\x7FW^$\xB4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0[\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`@Q\x91\x16\x81R_` \x82\x01R_`@\x82\x01R\xF3[\x7FW^$\xB4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\n` R\x7F\x8FOZ12\xB3(j\x8EzM\xDB\\\xD5_\xE3\xB9\x8D_\xC4*f\xD2\x17\xEA\xE1\xC8K\x87>\xBA\xF2T``\x90`\xE0\x1Ba\x1C\xE4V[\x015\x90P\x82\x80a\x1C\x1AV[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x82\x16\x92\x7F\xF6R\"#\x13\xE2\x84YR\x8D\x92\x0Be\x11\\\x16\xC0O>\xFC\x82\xAA\xED\xC9{\xE5\x9F?7|\r?\x91_[\x85\x81\x10a\x1E\x1AWP\x83`\x01\x95\x10a\x1D\xE2W[PPP\x81\x1B\x01`\x06Ua\x1CMV[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\xF8\x85`\x03\x1B\x16\x1C\x19\x91\x015\x16\x90U\x82\x80\x80a\x1D\xD4V[\x90\x92` `\x01\x81\x92\x86\x86\x015\x81U\x01\x94\x01\x91\x01a\x1D\xC2V[`\x1F\x82\x01`\x05\x1C\x7F\xF6R\"#\x13\xE2\x84YR\x8D\x92\x0Be\x11\\\x16\xC0O>\xFC\x82\xAA\xED\xC9{\xE5\x9F?7|\r?\x01\x90` \x83\x10a\x1E\xA7W[`\x1F\x01`\x05\x1C\x7F\xF6R\"#\x13\xE2\x84YR\x8D\x92\x0Be\x11\\\x16\xC0O>\xFC\x82\xAA\xED\xC9{\xE5\x9F?7|\r?\x01\x90[\x81\x81\x10a\x1E\x9CWPa\x1C\x04V[_\x81U`\x01\x01a\x1E\x8FV[\x7F\xF6R\"#\x13\xE2\x84YR\x8D\x92\x0Be\x11\\\x16\xC0O>\xFC\x82\xAA\xED\xC9{\xE5\x9F?7|\r?\x91Pa\x1EeV[4a\x04CW_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x04CW`@Q_`\x06Ta\x1F\r\x81a+\rV[\x80\x84R\x90`\x01\x81\x16\x90\x81\x15a\x05\x1BWP`\x01\x14a\x1F4Wa\x04\xB9\x83a\x04\xAD\x81\x85\x03\x82a+^V[`\x06_\x90\x81R\x7F\xF6R\"#\x13\xE2\x84YR\x8D\x92\x0Be\x11\\\x16\xC0O>\xFC\x82\xAA\xED\xC9{\xE5\x9F?7|\r?\x93\x92P\x90[\x80\x82\x10a\x1FxWP\x90\x91P\x81\x01` \x01a\x04\xADa\x04\x9DV[\x91\x92`\x01\x81` \x92T\x83\x85\x88\x01\x01R\x01\x91\x01\x90\x92\x91a\x1F`V[4a\x04CW_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x04CW`@Q_\x80Ta\x1F\xCF\x81a+\rV[\x80\x84R\x90`\x01\x81\x16\x90\x81\x15a\x05\x1BWP`\x01\x14a\x1F\xF6Wa\x04\xB9\x83a\x04\xAD\x81\x85\x03\x82a+^V[_\x80\x80R\x7F)\r\xEC\xD9T\x8Bb\xA8\xD6\x03E\xA9\x888o\xC8K\xA6\xBC\x95H@\x08\xF66/\x93\x16\x0E\xF3\xE5c\x93\x92P\x90[\x80\x82\x10a 8WP\x90\x91P\x81\x01` \x01a\x04\xADa\x04\x9DV[\x91\x92`\x01\x81` \x92T\x83\x85\x88\x01\x01R\x01\x91\x01\x90\x92\x91a  V[4a\x04CW_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x04CW`@Q_`\x04Ta \x90\x81a+\rV[\x80\x84R\x90`\x01\x81\x16\x90\x81\x15a\x05\x1BWP`\x01\x14a \xB7Wa\x04\xB9\x83a\x04\xAD\x81\x85\x03\x82a+^V[`\x04_\x90\x81R\x7F\x8A5\xAC\xFB\xC1_\xF8\x1A9\xAE}4O\xD7\t\xF2\x8E\x86\0\xB4\xAA\x8Ce\xC6\xB6K\xFE\x7F\xE3k\xD1\x9B\x93\x92P\x90[\x80\x82\x10a \xFBWP\x90\x91P\x81\x01` \x01a\x04\xADa\x04\x9DV[\x91\x92`\x01\x81` \x92T\x83\x85\x88\x01\x01R\x01\x91\x01\x90\x92\x91a \xE3V[4a\x04CWa\x01\0\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x04CWa!Ma+\xE7V[P`\xA0\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xDC6\x01\x12a\x04CWa!\x80a-\x03V[P`\xE45g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x04CWa!\xA1\x906\x90`\x04\x01a,\nV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x04\x16Wa!\xBA_Ta+\rV[`\x1F\x81\x11a#\xBFW[P_`\x1F\x82\x11`\x01\x14a#\x08W\x81\x92_\x92a\"\xFDW[PP\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82`\x01\x1B\x92`\x03\x1B\x1C\x19\x16\x17_U[\x7F4@\xD8 \0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\n` R\x7Fo\x93+\x1D,^\xBE\xE2\xA6z\x1E\x97\x84\xCF\x96\x84\xC2\xC9\xB8M\xCC\x0B\x9Fu\t\xEFp\xB3\xF67]5T`\xE0\x1B\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16a\"\xA9W`@Q\x7F4@\xD8 \0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` \x90\xF3[\x7F4@\xD8 \0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\n` \x90\x81R\x7Fo\x93+\x1D,^\xBE\xE2\xA6z\x1E\x97\x84\xCF\x96\x84\xC2\xC9\xB8M\xCC\x0B\x9Fu\t\xEFp\xB3\xF67]5T`\xE0\x1Ba\x028V[\x015\x90P\x82\x80a!\xD9V[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x82\x16\x92\x7F)\r\xEC\xD9T\x8Bb\xA8\xD6\x03E\xA9\x888o\xC8K\xA6\xBC\x95H@\x08\xF66/\x93\x16\x0E\xF3\xE5c\x91_[\x85\x81\x10a#\xA7WP\x83`\x01\x95\x10a#oW[PPP\x81\x1B\x01_Ua\"\x0BV[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\xF8\x85`\x03\x1B\x16\x1C\x19\x91\x015\x16\x90U\x82\x80\x80a#bV[\x90\x92` `\x01\x81\x92\x86\x86\x015\x81U\x01\x94\x01\x91\x01a#PV[`\x1F\x82\x01`\x05\x1C\x7F)\r\xEC\xD9T\x8Bb\xA8\xD6\x03E\xA9\x888o\xC8K\xA6\xBC\x95H@\x08\xF66/\x93\x16\x0E\xF3\xE5c\x01\x90` \x83\x10a$4W[`\x1F\x01`\x05\x1C\x7F)\r\xEC\xD9T\x8Bb\xA8\xD6\x03E\xA9\x888o\xC8K\xA6\xBC\x95H@\x08\xF66/\x93\x16\x0E\xF3\xE5c\x01\x90[\x81\x81\x10a$)WPa!\xC3V[_\x81U`\x01\x01a$\x1CV[\x7F)\r\xEC\xD9T\x8Bb\xA8\xD6\x03E\xA9\x888o\xC8K\xA6\xBC\x95H@\x08\xF66/\x93\x16\x0E\xF3\xE5c\x91Pa#\xF2V[4a\x04CWa$j6a,8V[\x92P\x92PPg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x04\x16Wa$\x89`\x02Ta+\rV[`\x1F\x81\x11a&\x90W[P_`\x1F\x82\x11`\x01\x14a%\xD8W\x81\x92_\x92a%\xCDW[PP\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82`\x01\x1B\x92`\x03\x1B\x1C\x19\x16\x17`\x02U[\x7F%\x99\x82\xE5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\n` R\x7F\xC3\xEB\x88W\xB9y\xA3\x9A#/YJ\xCA\x1F\xEB=:\x12\xB1\xF8\x08u\x16Q\xF5\x17\xED\x9E\xFF\xC52yT`\xE0\x1B\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16a%yW`@Q\x7F%\x99\x82\xE5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` \x90\xF3[\x7F%\x99\x82\xE5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\n` \x90\x81R\x7F\xC3\xEB\x88W\xB9y\xA3\x9A#/YJ\xCA\x1F\xEB=:\x12\xB1\xF8\x08u\x16Q\xF5\x17\xED\x9E\xFF\xC52yT`\xE0\x1Ba\x028V[\x015\x90P\x82\x80a$\xA8V[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x82\x16\x92\x7F@W\x87\xFA\x12\xA8#\xE0\xF2\xB7c\x1C\xC4\x1B;\xA8\x82\x8B3!\xCA\x81\x11\x11\xFAu\xCD:\xA3\xBBZ\xCE\x91_[\x85\x81\x10a&xWP\x83`\x01\x95\x10a&@W[PPP\x81\x1B\x01`\x02Ua$\xDBV[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\xF8\x85`\x03\x1B\x16\x1C\x19\x91\x015\x16\x90U\x82\x80\x80a&2V[\x90\x92` `\x01\x81\x92\x86\x86\x015\x81U\x01\x94\x01\x91\x01a& V[`\x1F\x82\x01`\x05\x1C\x7F@W\x87\xFA\x12\xA8#\xE0\xF2\xB7c\x1C\xC4\x1B;\xA8\x82\x8B3!\xCA\x81\x11\x11\xFAu\xCD:\xA3\xBBZ\xCE\x01\x90` \x83\x10a'\x05W[`\x1F\x01`\x05\x1C\x7F@W\x87\xFA\x12\xA8#\xE0\xF2\xB7c\x1C\xC4\x1B;\xA8\x82\x8B3!\xCA\x81\x11\x11\xFAu\xCD:\xA3\xBBZ\xCE\x01\x90[\x81\x81\x10a&\xFAWPa$\x92V[_\x81U`\x01\x01a&\xEDV[\x7F@W\x87\xFA\x12\xA8#\xE0\xF2\xB7c\x1C\xC4\x1B;\xA8\x82\x8B3!\xCA\x81\x11\x11\xFAu\xCD:\xA3\xBBZ\xCE\x91Pa&\xC3V[4a\x04CWa';6a,8V[\x92P\x92PPg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x04\x16Wa'Z`\x04Ta+\rV[`\x1F\x81\x11a)aW[P_`\x1F\x82\x11`\x01\x14a(\xA9W\x81\x92_\x92a(\x9EW[PP\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82`\x01\x1B\x92`\x03\x1B\x1C\x19\x16\x17`\x04U[\x7F!\xD0\xEEp\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\n` R\x7F<\xA7i\x96\xC4\xDE8\x04\xEE\xAB3{\xFF\x8D\x94M\xE8\xDE#yf,\x86f\xE6\xFF\xE7\xBF\xA2:\x1BCT`\xE0\x1B\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16a(JW`@Q\x7F!\xD0\xEEp\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` \x90\xF3[\x7F!\xD0\xEEp\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\n` \x90\x81R\x7F<\xA7i\x96\xC4\xDE8\x04\xEE\xAB3{\xFF\x8D\x94M\xE8\xDE#yf,\x86f\xE6\xFF\xE7\xBF\xA2:\x1BCT`\xE0\x1Ba\x028V[\x015\x90P\x82\x80a'yV[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x82\x16\x92\x7F\x8A5\xAC\xFB\xC1_\xF8\x1A9\xAE}4O\xD7\t\xF2\x8E\x86\0\xB4\xAA\x8Ce\xC6\xB6K\xFE\x7F\xE3k\xD1\x9B\x91_[\x85\x81\x10a)IWP\x83`\x01\x95\x10a)\x11W[PPP\x81\x1B\x01`\x04Ua'\xACV[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\xF8\x85`\x03\x1B\x16\x1C\x19\x91\x015\x16\x90U\x82\x80\x80a)\x03V[\x90\x92` `\x01\x81\x92\x86\x86\x015\x81U\x01\x94\x01\x91\x01a(\xF1V[`\x1F\x82\x01`\x05\x1C\x7F\x8A5\xAC\xFB\xC1_\xF8\x1A9\xAE}4O\xD7\t\xF2\x8E\x86\0\xB4\xAA\x8Ce\xC6\xB6K\xFE\x7F\xE3k\xD1\x9B\x01\x90` \x83\x10a)\xD6W[`\x1F\x01`\x05\x1C\x7F\x8A5\xAC\xFB\xC1_\xF8\x1A9\xAE}4O\xD7\t\xF2\x8E\x86\0\xB4\xAA\x8Ce\xC6\xB6K\xFE\x7F\xE3k\xD1\x9B\x01\x90[\x81\x81\x10a)\xCBWPa'cV[_\x81U`\x01\x01a)\xBEV[\x7F\x8A5\xAC\xFB\xC1_\xF8\x1A9\xAE}4O\xD7\t\xF2\x8E\x86\0\xB4\xAA\x8Ce\xC6\xB6K\xFE\x7F\xE3k\xD1\x9B\x91Pa)\x94V[4a\x04CW` \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x04CW`\x045_R`\x0B` R` a\xFF\xFF`@_ T\x16`@Q\x90\x81R\xF3[4a\x04CW_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x04CW`@Q_`\x01Ta*\x88\x81a+\rV[\x80\x84R\x90`\x01\x81\x16\x90\x81\x15a\x05\x1BWP`\x01\x14a*\xAFWa\x04\xB9\x83a\x04\xAD\x81\x85\x03\x82a+^V[`\x01_\x90\x81R\x7F\xB1\x0E-Rv\x12\x07;&\xEE\xCD\xFDq~j2\x0C\xF4KJ\xFA\xC2\xB0s-\x9F\xCB\xE2\xB7\xFA\x0C\xF6\x93\x92P\x90[\x80\x82\x10a*\xF3WP\x90\x91P\x81\x01` \x01a\x04\xADa\x04\x9DV[\x91\x92`\x01\x81` \x92T\x83\x85\x88\x01\x01R\x01\x91\x01\x90\x92\x91a*\xDBV[\x90`\x01\x82\x81\x1C\x92\x16\x80\x15a+TW[` \x83\x10\x14a+'WV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\"`\x04R`$_\xFD[\x91`\x7F\x16\x91a+\x1CV[\x90`\x1F\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x91\x01\x16\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x04\x16W`@RV[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0`\x1F` `@\x94\x81\x85R\x80Q\x91\x82\x91\x82\x82\x88\x01R\x01\x86\x86\x01^_\x85\x82\x86\x01\x01R\x01\x16\x01\x01\x90V[`\x045\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x82\x03a\x04CWV[\x91\x81`\x1F\x84\x01\x12\x15a\x04CW\x825\x91g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11a\x04CW` \x83\x81\x86\x01\x95\x01\x01\x11a\x04CWV[\x90a\x01`\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC\x83\x01\x12a\x04CW`\x045s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x81\x03a\x04CW\x91`\xA0\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xDC\x82\x01\x12a\x04CW`$\x91`\x80\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF<\x83\x01\x12a\x04CW`\xC4\x91a\x01D5\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x04CWa,\xFF\x91`\x04\x01a,\nV[\x90\x91V[`\xC45\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x82\x03a\x04CWV[`\x045\x90\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x16\x82\x03a\x04CWV[a\x01\x80\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC\x82\x01\x12a\x04CW`\x045s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x81\x03a\x04CW\x91`\xA0\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xDC\x83\x01\x12a\x04CW`$\x91`\x80\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF<\x82\x01\x12a\x04CW`\xC4\x91a\x01D5\x91a\x01d5\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x04CWa,\xFF\x91`\x04\x01a,\nV[`\xE45\x90\x81`\x02\x0B\x82\x03a\x04CWV[a\x01 \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC\x82\x01\x12a\x04CW`\x045s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x81\x03a\x04CW\x91`\xA0\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xDC\x83\x01\x12a\x04CW`$\x91`\xC45\x91`\xE45\x91a\x01\x045\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x04CWa,\xFF\x91`\x04\x01a,\nV\xFE\xA2dipfsX\"\x12 f\x97\xE6,\xA0c-IE\x8C\xBC\xED\x7F\xBAc\xAF\\\xF6=\x8C\xB0d\x0F\xDD\xF6\x95gq\x84s\xE3\xA7dsolcC\0\x08\x1A\x003",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x60806040526004361015610011575f80fd5b5f3560e01c80630a2d582714612a4a57806317bd6123146129fe57806321d0ee701461272d578063259982e51461245c5780633440d820146121155780634d081c7e1461205257806350cd07eb14611f92578063542e936914611ecf578063575e24b414611b335780635941b5bb14611a735780635a2a81001461179b578063622e60de146116d857806370b28eda146116155780637a3385f5146114fc5780637e472fb2146114395780638db2b65214611132578063a2bc94ad1461109e578063a910f80f14610d4a578063af57c18414610c87578063b47b2fb1146108f2578063b6a8b0fa14610620578063b85164661461055d578063db6d76a2146104475763e1b4af6914610121575f80fd5b346104435761012f36612e30565b93509350505067ffffffffffffffff81116104165761014f600954612b0d565b601f8111610379575b505f601f82116001146102c15781925f926102b6575b50507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8260011b9260031b1c1916176009555b7fe1b4af69000000000000000000000000000000000000000000000000000000005f52600a6020527f3e1cff7e09cc4cb604c0c017add856c5756522d5e4dfc08fa794b6e2e9f5c0e95460e01b7fffffffff00000000000000000000000000000000000000000000000000000000166102625760207fe1b4af69000000000000000000000000000000000000000000000000000000005b7fffffffff0000000000000000000000000000000000000000000000000000000060405191168152f35b7fe1b4af69000000000000000000000000000000000000000000000000000000005f52600a60209081527f3e1cff7e09cc4cb604c0c017add856c5756522d5e4dfc08fa794b6e2e9f5c0e95460e01b610238565b013590505f8061016e565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08216927f6e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7af915f5b85811061036157508360019510610329575b505050811b016009556101a1565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60f88560031b161c199101351690555f808061031b565b90926020600181928686013581550194019101610309565b601f820160051c7f6e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7af0190602083106103ee575b601f0160051c7f6e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7af01905b8181106103e35750610158565b5f81556001016103d6565b7f6e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7af91506103ac565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b5f80fd5b34610443575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610443576040515f60025461048581612b0d565b808452906001811690811561051b57506001146104bd575b6104b9836104ad81850382612b5e565b60405191829182612b9f565b0390f35b60025f9081527f405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace939250905b808210610501575090915081016020016104ad61049d565b9192600181602092548385880101520191019092916104e9565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff001660208086019190915291151560051b840190910191506104ad905061049d565b34610443575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610443576040515f60035461059b81612b0d565b808452906001811690811561051b57506001146105c2576104b9836104ad81850382612b5e565b60035f9081527fc2575a0e9e593c00f959f8c92f12db2869c3395a3b0502d05e2516446f71f85b939250905b808210610606575090915081016020016104ad61049d565b9192600181602092548385880101520191019092916105ee565b346104435761062e36612e30565b93509350505067ffffffffffffffff81116104165761064e600854612b0d565b601f8111610855575b505f601f821160011461079d5781925f92610792575b50507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8260011b9260031b1c1916176008555b7fb6a8b0fa000000000000000000000000000000000000000000000000000000005f52600a6020527fc020f4cb7a0ae9ba5c590fbb2728bbab87fc8f068a74c7042ca3f2f27cc519f75460e01b7fffffffff000000000000000000000000000000000000000000000000000000001661073e576040517fb6a8b0fa000000000000000000000000000000000000000000000000000000008152602090f35b7fb6a8b0fa000000000000000000000000000000000000000000000000000000005f52600a60209081527fc020f4cb7a0ae9ba5c590fbb2728bbab87fc8f068a74c7042ca3f2f27cc519f75460e01b610238565b01359050828061066d565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08216927ff3f7a9fe364faab93b216da50a3214154f22a0a2b415b23a84c8169e8b636ee3915f5b85811061083d57508360019510610805575b505050811b016008556106a0565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60f88560031b161c199101351690558280806107f7565b909260206001819286860135815501940191016107e5565b601f820160051c7ff3f7a9fe364faab93b216da50a3214154f22a0a2b415b23a84c8169e8b636ee30190602083106108ca575b601f0160051c7ff3f7a9fe364faab93b216da50a3214154f22a0a2b415b23a84c8169e8b636ee301905b8181106108bf5750610657565b5f81556001016108b2565b7ff3f7a9fe364faab93b216da50a3214154f22a0a2b415b23a84c8169e8b636ee39150610888565b34610443576101607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126104435761092a612be7565b5060a07fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffdc3601126104435760607fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff3c360112610443576101443567ffffffffffffffff8111610443576109a0903690600401612c0a565b67ffffffffffffffff8111610416576109ba600754612b0d565b601f8111610bea575b505f601f8211600114610b325781925f92610b27575b50507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8260011b9260031b1c1916176007555b7fb47b2fb1000000000000000000000000000000000000000000000000000000005f52600a6020527f2491b1a3e05eb915595dd2d17535e9dd4280b7e1dc3e97bd1382883e4c8628635460e01b7fffffffff0000000000000000000000000000000000000000000000000000000016610ad25760407fb47b2fb1000000000000000000000000000000000000000000000000000000005b7fffffffff000000000000000000000000000000000000000000000000000000008251911681525f6020820152f35b7fb47b2fb1000000000000000000000000000000000000000000000000000000005f52600a6020527f2491b1a3e05eb915595dd2d17535e9dd4280b7e1dc3e97bd1382883e4c8628635460409060e01b610aa3565b0135905082806109d9565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08216927fa66cc928b5edb82af9bd49922954155ab7b0942694bea4ce44661d9a8736c688915f5b858110610bd257508360019510610b9a575b505050811b01600755610a0c565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60f88560031b161c19910135169055828080610b8c565b90926020600181928686013581550194019101610b7a565b601f820160051c7fa66cc928b5edb82af9bd49922954155ab7b0942694bea4ce44661d9a8736c688019060208310610c5f575b601f0160051c7fa66cc928b5edb82af9bd49922954155ab7b0942694bea4ce44661d9a8736c68801905b818110610c5457506109c3565b5f8155600101610c47565b7fa66cc928b5edb82af9bd49922954155ab7b0942694bea4ce44661d9a8736c6889150610c1d565b34610443575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610443576040515f600854610cc581612b0d565b808452906001811690811561051b5750600114610cec576104b9836104ad81850382612b5e565b60085f9081527ff3f7a9fe364faab93b216da50a3214154f22a0a2b415b23a84c8169e8b636ee3939250905b808210610d30575090915081016020016104ad61049d565b919260018160209254838588010152019101909291610d18565b34610443576101207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261044357610d82612be7565b5060a07fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffdc36011261044357610db5612d03565b50610dbe612e20565b506101043567ffffffffffffffff811161044357610de0903690600401612c0a565b67ffffffffffffffff811161041657610dfa600154612b0d565b601f8111611001575b505f601f8211600114610f495781925f92610f3e575b50507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8260011b9260031b1c1916176001555b7fa910f80f000000000000000000000000000000000000000000000000000000005f52600a6020527f6bf6b3c2668cbe141e73f2947fc4a61f0fa3dd095e3438f5f144c8e9814d390b5460e01b7fffffffff0000000000000000000000000000000000000000000000000000000016610eea576040517fa910f80f000000000000000000000000000000000000000000000000000000008152602090f35b7fa910f80f000000000000000000000000000000000000000000000000000000005f52600a60209081527f6bf6b3c2668cbe141e73f2947fc4a61f0fa3dd095e3438f5f144c8e9814d390b5460e01b610238565b013590508280610e19565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08216927fb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6915f5b858110610fe957508360019510610fb1575b505050811b01600155610e4c565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60f88560031b161c19910135169055828080610fa3565b90926020600181928686013581550194019101610f91565b601f820160051c7fb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6019060208310611076575b601f0160051c7fb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf601905b81811061106b5750610e03565b5f815560010161105e565b7fb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf69150611034565b346104435760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610443577fffffffff000000000000000000000000000000000000000000000000000000006110f6612d26565b165f52600a602052602060405f205460e01b7fffffffff0000000000000000000000000000000000000000000000000000000060405191168152f35b346104435761114036612d55565b93509350505067ffffffffffffffff811161041657611160600554612b0d565b601f811161139c575b505f601f82116001146112e45781925f926112d9575b50507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8260011b9260031b1c1916176005555b7f8db2b652000000000000000000000000000000000000000000000000000000005f52600a6020527faf2d1eda278984c26a26b0c3e4f6b3c0be70f0f53825d8b865bc101b251f22405460e01b7fffffffff0000000000000000000000000000000000000000000000000000000016611283576104b97f8db2b652000000000000000000000000000000000000000000000000000000005b604080517fffffffff0000000000000000000000000000000000000000000000000000000090921682525f602083015290918291820190565b7f8db2b652000000000000000000000000000000000000000000000000000000005f52600a6020527faf2d1eda278984c26a26b0c3e4f6b3c0be70f0f53825d8b865bc101b251f2240546104b99060e01b61124a565b01359050828061117f565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08216927f036b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db0915f5b8581106113845750836001951061134c575b505050811b016005556111b2565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60f88560031b161c1991013516905582808061133e565b9092602060018192868601358155019401910161132c565b601f820160051c7f036b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db0019060208310611411575b601f0160051c7f036b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db001905b8181106114065750611169565b5f81556001016113f9565b7f036b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db091506113cf565b34610443575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610443576040515f60055461147781612b0d565b808452906001811690811561051b575060011461149e576104b9836104ad81850382612b5e565b60055f9081527f036b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db0939250905b8082106114e2575090915081016020016104ad61049d565b9192600181602092548385880101520191019092916114ca565b34610443577ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360160c081126104435760a0136104435760a43561ffff81168091036104435760405160a0810181811067ffffffffffffffff82111761041657604052611567612be7565b815260243573ffffffffffffffffffffffffffffffffffffffff8116810361044357602082015260443562ffffff811681036104435760408201526064358060020b81036104435760608201526084359073ffffffffffffffffffffffffffffffffffffffff821682036104435760a0916080820152205f52600b60205260405f20907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00008254161790555f80f35b34610443575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610443576040515f60095461165381612b0d565b808452906001811690811561051b575060011461167a576104b9836104ad81850382612b5e565b60095f9081527f6e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7af939250905b8082106116be575090915081016020016104ad61049d565b9192600181602092548385880101520191019092916116a6565b34610443575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610443576040515f60075461171681612b0d565b808452906001811690811561051b575060011461173d576104b9836104ad81850382612b5e565b60075f9081527fa66cc928b5edb82af9bd49922954155ab7b0942694bea4ce44661d9a8736c688939250905b808210611781575090915081016020016104ad61049d565b919260018160209254838588010152019101909291611769565b34610443576117a936612d55565b93509350505067ffffffffffffffff8111610416576117c9600354612b0d565b601f81116119d6575b505f601f821160011461191e5781925f92611913575b50507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8260011b9260031b1c1916176003555b7f5a2a8100000000000000000000000000000000000000000000000000000000005f52600a6020527fe758c549c0b8d2032eb1bd311ad4675db345bff5f7b6ad36aafb50c20921730c5460e01b7fffffffff00000000000000000000000000000000000000000000000000000000166118bd57604080517f5a2a81000000000000000000000000000000000000000000000000000000000081525f6020820152f35b7f5a2a8100000000000000000000000000000000000000000000000000000000005f52600a6020527fe758c549c0b8d2032eb1bd311ad4675db345bff5f7b6ad36aafb50c20921730c546104b99060e01b61124a565b0135905082806117e8565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08216927fc2575a0e9e593c00f959f8c92f12db2869c3395a3b0502d05e2516446f71f85b915f5b8581106119be57508360019510611986575b505050811b0160035561181b565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60f88560031b161c19910135169055828080611978565b90926020600181928686013581550194019101611966565b601f820160051c7fc2575a0e9e593c00f959f8c92f12db2869c3395a3b0502d05e2516446f71f85b019060208310611a4b575b601f0160051c7fc2575a0e9e593c00f959f8c92f12db2869c3395a3b0502d05e2516446f71f85b01905b818110611a4057506117d2565b5f8155600101611a33565b7fc2575a0e9e593c00f959f8c92f12db2869c3395a3b0502d05e2516446f71f85b9150611a09565b346104435760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261044357611aaa612d26565b602435907fffffffff0000000000000000000000000000000000000000000000000000000082168203610443577fffffffff00000000000000000000000000000000000000000000000000000000165f52600a60205260405f209060e01c7fffffffffffffffffffffffffffffffffffffffffffffffffffffffff000000008254161790555f80f35b34610443576101407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261044357611b6b612be7565b5060a07fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffdc3601126104435760607fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff3c360112610443576101243567ffffffffffffffff811161044357611be1903690600401612c0a565b67ffffffffffffffff811161041657611bfb600654612b0d565b601f8111611e32575b505f601f8211600114611d7a5781925f92611d6f575b50507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8260011b9260031b1c1916176006555b7f575e24b4000000000000000000000000000000000000000000000000000000005f52600a6020527f8f4f5a3132b3286a8e7a4ddb5cd55fe3b98d5fc42a66d217eae1c84b873ebaf25460e01b7fffffffff0000000000000000000000000000000000000000000000000000000016611d1a5760607f575e24b4000000000000000000000000000000000000000000000000000000005b7fffffffff00000000000000000000000000000000000000000000000000000000604051911681525f60208201525f6040820152f35b7f575e24b4000000000000000000000000000000000000000000000000000000005f52600a6020527f8f4f5a3132b3286a8e7a4ddb5cd55fe3b98d5fc42a66d217eae1c84b873ebaf25460609060e01b611ce4565b013590508280611c1a565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08216927ff652222313e28459528d920b65115c16c04f3efc82aaedc97be59f3f377c0d3f915f5b858110611e1a57508360019510611de2575b505050811b01600655611c4d565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60f88560031b161c19910135169055828080611dd4565b90926020600181928686013581550194019101611dc2565b601f820160051c7ff652222313e28459528d920b65115c16c04f3efc82aaedc97be59f3f377c0d3f019060208310611ea7575b601f0160051c7ff652222313e28459528d920b65115c16c04f3efc82aaedc97be59f3f377c0d3f01905b818110611e9c5750611c04565b5f8155600101611e8f565b7ff652222313e28459528d920b65115c16c04f3efc82aaedc97be59f3f377c0d3f9150611e65565b34610443575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610443576040515f600654611f0d81612b0d565b808452906001811690811561051b5750600114611f34576104b9836104ad81850382612b5e565b60065f9081527ff652222313e28459528d920b65115c16c04f3efc82aaedc97be59f3f377c0d3f939250905b808210611f78575090915081016020016104ad61049d565b919260018160209254838588010152019101909291611f60565b34610443575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610443576040515f8054611fcf81612b0d565b808452906001811690811561051b5750600114611ff6576104b9836104ad81850382612b5e565b5f8080527f290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563939250905b808210612038575090915081016020016104ad61049d565b919260018160209254838588010152019101909291612020565b34610443575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610443576040515f60045461209081612b0d565b808452906001811690811561051b57506001146120b7576104b9836104ad81850382612b5e565b60045f9081527f8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd19b939250905b8082106120fb575090915081016020016104ad61049d565b9192600181602092548385880101520191019092916120e3565b34610443576101007ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126104435761214d612be7565b5060a07fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffdc36011261044357612180612d03565b5060e43567ffffffffffffffff8111610443576121a1903690600401612c0a565b67ffffffffffffffff8111610416576121ba5f54612b0d565b601f81116123bf575b505f601f82116001146123085781925f926122fd575b50507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8260011b9260031b1c1916175f555b7f3440d820000000000000000000000000000000000000000000000000000000005f52600a6020527f6f932b1d2c5ebee2a67a1e9784cf9684c2c9b84dcc0b9f7509ef70b3f6375d355460e01b7fffffffff00000000000000000000000000000000000000000000000000000000166122a9576040517f3440d820000000000000000000000000000000000000000000000000000000008152602090f35b7f3440d820000000000000000000000000000000000000000000000000000000005f52600a60209081527f6f932b1d2c5ebee2a67a1e9784cf9684c2c9b84dcc0b9f7509ef70b3f6375d355460e01b610238565b0135905082806121d9565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08216927f290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563915f5b8581106123a75750836001951061236f575b505050811b015f5561220b565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60f88560031b161c19910135169055828080612362565b90926020600181928686013581550194019101612350565b601f820160051c7f290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563019060208310612434575b601f0160051c7f290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e56301905b81811061242957506121c3565b5f815560010161241c565b7f290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e56391506123f2565b346104435761246a36612c38565b925092505067ffffffffffffffff811161041657612489600254612b0d565b601f8111612690575b505f601f82116001146125d85781925f926125cd575b50507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8260011b9260031b1c1916176002555b7f259982e5000000000000000000000000000000000000000000000000000000005f52600a6020527fc3eb8857b979a39a232f594aca1feb3d3a12b1f808751651f517ed9effc532795460e01b7fffffffff0000000000000000000000000000000000000000000000000000000016612579576040517f259982e5000000000000000000000000000000000000000000000000000000008152602090f35b7f259982e5000000000000000000000000000000000000000000000000000000005f52600a60209081527fc3eb8857b979a39a232f594aca1feb3d3a12b1f808751651f517ed9effc532795460e01b610238565b0135905082806124a8565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08216927f405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace915f5b85811061267857508360019510612640575b505050811b016002556124db565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60f88560031b161c19910135169055828080612632565b90926020600181928686013581550194019101612620565b601f820160051c7f405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace019060208310612705575b601f0160051c7f405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace01905b8181106126fa5750612492565b5f81556001016126ed565b7f405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace91506126c3565b346104435761273b36612c38565b925092505067ffffffffffffffff81116104165761275a600454612b0d565b601f8111612961575b505f601f82116001146128a95781925f9261289e575b50507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8260011b9260031b1c1916176004555b7f21d0ee70000000000000000000000000000000000000000000000000000000005f52600a6020527f3ca76996c4de3804eeab337bff8d944de8de2379662c8666e6ffe7bfa23a1b435460e01b7fffffffff000000000000000000000000000000000000000000000000000000001661284a576040517f21d0ee70000000000000000000000000000000000000000000000000000000008152602090f35b7f21d0ee70000000000000000000000000000000000000000000000000000000005f52600a60209081527f3ca76996c4de3804eeab337bff8d944de8de2379662c8666e6ffe7bfa23a1b435460e01b610238565b013590508280612779565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08216927f8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd19b915f5b85811061294957508360019510612911575b505050811b016004556127ac565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60f88560031b161c19910135169055828080612903565b909260206001819286860135815501940191016128f1565b601f820160051c7f8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd19b0190602083106129d6575b601f0160051c7f8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd19b01905b8181106129cb5750612763565b5f81556001016129be565b7f8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd19b9150612994565b346104435760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610443576004355f52600b602052602061ffff60405f205416604051908152f35b34610443575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610443576040515f600154612a8881612b0d565b808452906001811690811561051b5750600114612aaf576104b9836104ad81850382612b5e565b60015f9081527fb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6939250905b808210612af3575090915081016020016104ad61049d565b919260018160209254838588010152019101909291612adb565b90600182811c92168015612b54575b6020831014612b2757565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602260045260245ffd5b91607f1691612b1c565b90601f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0910116810190811067ffffffffffffffff82111761041657604052565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f602060409481855280519182918282880152018686015e5f8582860101520116010190565b6004359073ffffffffffffffffffffffffffffffffffffffff8216820361044357565b9181601f840112156104435782359167ffffffffffffffff8311610443576020838186019501011161044357565b906101607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc8301126104435760043573ffffffffffffffffffffffffffffffffffffffff81168103610443579160a07fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffdc8201126104435760249160807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff3c8301126104435760c491610144359067ffffffffffffffff821161044357612cff91600401612c0a565b9091565b60c4359073ffffffffffffffffffffffffffffffffffffffff8216820361044357565b600435907fffffffff000000000000000000000000000000000000000000000000000000008216820361044357565b6101807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc8201126104435760043573ffffffffffffffffffffffffffffffffffffffff81168103610443579160a07fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffdc8301126104435760249160807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff3c8201126104435760c4916101443591610164359067ffffffffffffffff821161044357612cff91600401612c0a565b60e435908160020b820361044357565b6101207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc8201126104435760043573ffffffffffffffffffffffffffffffffffffffff81168103610443579160a07fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffdc8301126104435760249160c4359160e43591610104359067ffffffffffffffff821161044357612cff91600401612c0a56fea26469706673582212206697e62ca0632d49458cbced7fba63af5cf63d8cb0640fddf69567718473e3a764736f6c634300081a0033
    /// ```
    #[rustfmt::skip]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R`\x046\x10\x15a\0\x11W_\x80\xFD[_5`\xE0\x1C\x80c\n-X'\x14a*JW\x80c\x17\xBDa#\x14a)\xFEW\x80c!\xD0\xEEp\x14a'-W\x80c%\x99\x82\xE5\x14a$\\W\x80c4@\xD8 \x14a!\x15W\x80cM\x08\x1C~\x14a RW\x80cP\xCD\x07\xEB\x14a\x1F\x92W\x80cT.\x93i\x14a\x1E\xCFW\x80cW^$\xB4\x14a\x1B3W\x80cYA\xB5\xBB\x14a\x1AsW\x80cZ*\x81\0\x14a\x17\x9BW\x80cb.`\xDE\x14a\x16\xD8W\x80cp\xB2\x8E\xDA\x14a\x16\x15W\x80cz3\x85\xF5\x14a\x14\xFCW\x80c~G/\xB2\x14a\x149W\x80c\x8D\xB2\xB6R\x14a\x112W\x80c\xA2\xBC\x94\xAD\x14a\x10\x9EW\x80c\xA9\x10\xF8\x0F\x14a\rJW\x80c\xAFW\xC1\x84\x14a\x0C\x87W\x80c\xB4{/\xB1\x14a\x08\xF2W\x80c\xB6\xA8\xB0\xFA\x14a\x06 W\x80c\xB8Qdf\x14a\x05]W\x80c\xDBmv\xA2\x14a\x04GWc\xE1\xB4\xAFi\x14a\x01!W_\x80\xFD[4a\x04CWa\x01/6a.0V[\x93P\x93PPPg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x04\x16Wa\x01O`\tTa+\rV[`\x1F\x81\x11a\x03yW[P_`\x1F\x82\x11`\x01\x14a\x02\xC1W\x81\x92_\x92a\x02\xB6W[PP\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82`\x01\x1B\x92`\x03\x1B\x1C\x19\x16\x17`\tU[\x7F\xE1\xB4\xAFi\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\n` R\x7F>\x1C\xFF~\t\xCCL\xB6\x04\xC0\xC0\x17\xAD\xD8V\xC5ue\"\xD5\xE4\xDF\xC0\x8F\xA7\x94\xB6\xE2\xE9\xF5\xC0\xE9T`\xE0\x1B\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16a\x02bW` \x7F\xE1\xB4\xAFi\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0[\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`@Q\x91\x16\x81R\xF3[\x7F\xE1\xB4\xAFi\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\n` \x90\x81R\x7F>\x1C\xFF~\t\xCCL\xB6\x04\xC0\xC0\x17\xAD\xD8V\xC5ue\"\xD5\xE4\xDF\xC0\x8F\xA7\x94\xB6\xE2\xE9\xF5\xC0\xE9T`\xE0\x1Ba\x028V[\x015\x90P_\x80a\x01nV[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x82\x16\x92\x7Fn\x15@\x17\x1Bl\x0C\x96\x0Bq\xA7\x02\r\x9F`\x07\x7Fj\xF91\xA8\xBB\xF5\x90\xDA\x02#\xDA\xCFu\xC7\xAF\x91_[\x85\x81\x10a\x03aWP\x83`\x01\x95\x10a\x03)W[PPP\x81\x1B\x01`\tUa\x01\xA1V[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\xF8\x85`\x03\x1B\x16\x1C\x19\x91\x015\x16\x90U_\x80\x80a\x03\x1BV[\x90\x92` `\x01\x81\x92\x86\x86\x015\x81U\x01\x94\x01\x91\x01a\x03\tV[`\x1F\x82\x01`\x05\x1C\x7Fn\x15@\x17\x1Bl\x0C\x96\x0Bq\xA7\x02\r\x9F`\x07\x7Fj\xF91\xA8\xBB\xF5\x90\xDA\x02#\xDA\xCFu\xC7\xAF\x01\x90` \x83\x10a\x03\xEEW[`\x1F\x01`\x05\x1C\x7Fn\x15@\x17\x1Bl\x0C\x96\x0Bq\xA7\x02\r\x9F`\x07\x7Fj\xF91\xA8\xBB\xF5\x90\xDA\x02#\xDA\xCFu\xC7\xAF\x01\x90[\x81\x81\x10a\x03\xE3WPa\x01XV[_\x81U`\x01\x01a\x03\xD6V[\x7Fn\x15@\x17\x1Bl\x0C\x96\x0Bq\xA7\x02\r\x9F`\x07\x7Fj\xF91\xA8\xBB\xF5\x90\xDA\x02#\xDA\xCFu\xC7\xAF\x91Pa\x03\xACV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`A`\x04R`$_\xFD[_\x80\xFD[4a\x04CW_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x04CW`@Q_`\x02Ta\x04\x85\x81a+\rV[\x80\x84R\x90`\x01\x81\x16\x90\x81\x15a\x05\x1BWP`\x01\x14a\x04\xBDW[a\x04\xB9\x83a\x04\xAD\x81\x85\x03\x82a+^V[`@Q\x91\x82\x91\x82a+\x9FV[\x03\x90\xF3[`\x02_\x90\x81R\x7F@W\x87\xFA\x12\xA8#\xE0\xF2\xB7c\x1C\xC4\x1B;\xA8\x82\x8B3!\xCA\x81\x11\x11\xFAu\xCD:\xA3\xBBZ\xCE\x93\x92P\x90[\x80\x82\x10a\x05\x01WP\x90\x91P\x81\x01` \x01a\x04\xADa\x04\x9DV[\x91\x92`\x01\x81` \x92T\x83\x85\x88\x01\x01R\x01\x91\x01\x90\x92\x91a\x04\xE9V[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\x16` \x80\x86\x01\x91\x90\x91R\x91\x15\x15`\x05\x1B\x84\x01\x90\x91\x01\x91Pa\x04\xAD\x90Pa\x04\x9DV[4a\x04CW_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x04CW`@Q_`\x03Ta\x05\x9B\x81a+\rV[\x80\x84R\x90`\x01\x81\x16\x90\x81\x15a\x05\x1BWP`\x01\x14a\x05\xC2Wa\x04\xB9\x83a\x04\xAD\x81\x85\x03\x82a+^V[`\x03_\x90\x81R\x7F\xC2WZ\x0E\x9EY<\0\xF9Y\xF8\xC9/\x12\xDB(i\xC39Z;\x05\x02\xD0^%\x16Doq\xF8[\x93\x92P\x90[\x80\x82\x10a\x06\x06WP\x90\x91P\x81\x01` \x01a\x04\xADa\x04\x9DV[\x91\x92`\x01\x81` \x92T\x83\x85\x88\x01\x01R\x01\x91\x01\x90\x92\x91a\x05\xEEV[4a\x04CWa\x06.6a.0V[\x93P\x93PPPg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x04\x16Wa\x06N`\x08Ta+\rV[`\x1F\x81\x11a\x08UW[P_`\x1F\x82\x11`\x01\x14a\x07\x9DW\x81\x92_\x92a\x07\x92W[PP\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82`\x01\x1B\x92`\x03\x1B\x1C\x19\x16\x17`\x08U[\x7F\xB6\xA8\xB0\xFA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\n` R\x7F\xC0 \xF4\xCBz\n\xE9\xBA\\Y\x0F\xBB'(\xBB\xAB\x87\xFC\x8F\x06\x8At\xC7\x04,\xA3\xF2\xF2|\xC5\x19\xF7T`\xE0\x1B\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16a\x07>W`@Q\x7F\xB6\xA8\xB0\xFA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` \x90\xF3[\x7F\xB6\xA8\xB0\xFA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\n` \x90\x81R\x7F\xC0 \xF4\xCBz\n\xE9\xBA\\Y\x0F\xBB'(\xBB\xAB\x87\xFC\x8F\x06\x8At\xC7\x04,\xA3\xF2\xF2|\xC5\x19\xF7T`\xE0\x1Ba\x028V[\x015\x90P\x82\x80a\x06mV[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x82\x16\x92\x7F\xF3\xF7\xA9\xFE6O\xAA\xB9;!m\xA5\n2\x14\x15O\"\xA0\xA2\xB4\x15\xB2:\x84\xC8\x16\x9E\x8Bcn\xE3\x91_[\x85\x81\x10a\x08=WP\x83`\x01\x95\x10a\x08\x05W[PPP\x81\x1B\x01`\x08Ua\x06\xA0V[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\xF8\x85`\x03\x1B\x16\x1C\x19\x91\x015\x16\x90U\x82\x80\x80a\x07\xF7V[\x90\x92` `\x01\x81\x92\x86\x86\x015\x81U\x01\x94\x01\x91\x01a\x07\xE5V[`\x1F\x82\x01`\x05\x1C\x7F\xF3\xF7\xA9\xFE6O\xAA\xB9;!m\xA5\n2\x14\x15O\"\xA0\xA2\xB4\x15\xB2:\x84\xC8\x16\x9E\x8Bcn\xE3\x01\x90` \x83\x10a\x08\xCAW[`\x1F\x01`\x05\x1C\x7F\xF3\xF7\xA9\xFE6O\xAA\xB9;!m\xA5\n2\x14\x15O\"\xA0\xA2\xB4\x15\xB2:\x84\xC8\x16\x9E\x8Bcn\xE3\x01\x90[\x81\x81\x10a\x08\xBFWPa\x06WV[_\x81U`\x01\x01a\x08\xB2V[\x7F\xF3\xF7\xA9\xFE6O\xAA\xB9;!m\xA5\n2\x14\x15O\"\xA0\xA2\xB4\x15\xB2:\x84\xC8\x16\x9E\x8Bcn\xE3\x91Pa\x08\x88V[4a\x04CWa\x01`\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x04CWa\t*a+\xE7V[P`\xA0\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xDC6\x01\x12a\x04CW``\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF<6\x01\x12a\x04CWa\x01D5g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x04CWa\t\xA0\x906\x90`\x04\x01a,\nV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x04\x16Wa\t\xBA`\x07Ta+\rV[`\x1F\x81\x11a\x0B\xEAW[P_`\x1F\x82\x11`\x01\x14a\x0B2W\x81\x92_\x92a\x0B'W[PP\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82`\x01\x1B\x92`\x03\x1B\x1C\x19\x16\x17`\x07U[\x7F\xB4{/\xB1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\n` R\x7F$\x91\xB1\xA3\xE0^\xB9\x15Y]\xD2\xD1u5\xE9\xDDB\x80\xB7\xE1\xDC>\x97\xBD\x13\x82\x88>L\x86(cT`\xE0\x1B\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16a\n\xD2W`@\x7F\xB4{/\xB1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0[\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82Q\x91\x16\x81R_` \x82\x01R\xF3[\x7F\xB4{/\xB1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\n` R\x7F$\x91\xB1\xA3\xE0^\xB9\x15Y]\xD2\xD1u5\xE9\xDDB\x80\xB7\xE1\xDC>\x97\xBD\x13\x82\x88>L\x86(cT`@\x90`\xE0\x1Ba\n\xA3V[\x015\x90P\x82\x80a\t\xD9V[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x82\x16\x92\x7F\xA6l\xC9(\xB5\xED\xB8*\xF9\xBDI\x92)T\x15Z\xB7\xB0\x94&\x94\xBE\xA4\xCEDf\x1D\x9A\x876\xC6\x88\x91_[\x85\x81\x10a\x0B\xD2WP\x83`\x01\x95\x10a\x0B\x9AW[PPP\x81\x1B\x01`\x07Ua\n\x0CV[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\xF8\x85`\x03\x1B\x16\x1C\x19\x91\x015\x16\x90U\x82\x80\x80a\x0B\x8CV[\x90\x92` `\x01\x81\x92\x86\x86\x015\x81U\x01\x94\x01\x91\x01a\x0BzV[`\x1F\x82\x01`\x05\x1C\x7F\xA6l\xC9(\xB5\xED\xB8*\xF9\xBDI\x92)T\x15Z\xB7\xB0\x94&\x94\xBE\xA4\xCEDf\x1D\x9A\x876\xC6\x88\x01\x90` \x83\x10a\x0C_W[`\x1F\x01`\x05\x1C\x7F\xA6l\xC9(\xB5\xED\xB8*\xF9\xBDI\x92)T\x15Z\xB7\xB0\x94&\x94\xBE\xA4\xCEDf\x1D\x9A\x876\xC6\x88\x01\x90[\x81\x81\x10a\x0CTWPa\t\xC3V[_\x81U`\x01\x01a\x0CGV[\x7F\xA6l\xC9(\xB5\xED\xB8*\xF9\xBDI\x92)T\x15Z\xB7\xB0\x94&\x94\xBE\xA4\xCEDf\x1D\x9A\x876\xC6\x88\x91Pa\x0C\x1DV[4a\x04CW_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x04CW`@Q_`\x08Ta\x0C\xC5\x81a+\rV[\x80\x84R\x90`\x01\x81\x16\x90\x81\x15a\x05\x1BWP`\x01\x14a\x0C\xECWa\x04\xB9\x83a\x04\xAD\x81\x85\x03\x82a+^V[`\x08_\x90\x81R\x7F\xF3\xF7\xA9\xFE6O\xAA\xB9;!m\xA5\n2\x14\x15O\"\xA0\xA2\xB4\x15\xB2:\x84\xC8\x16\x9E\x8Bcn\xE3\x93\x92P\x90[\x80\x82\x10a\r0WP\x90\x91P\x81\x01` \x01a\x04\xADa\x04\x9DV[\x91\x92`\x01\x81` \x92T\x83\x85\x88\x01\x01R\x01\x91\x01\x90\x92\x91a\r\x18V[4a\x04CWa\x01 \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x04CWa\r\x82a+\xE7V[P`\xA0\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xDC6\x01\x12a\x04CWa\r\xB5a-\x03V[Pa\r\xBEa. V[Pa\x01\x045g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x04CWa\r\xE0\x906\x90`\x04\x01a,\nV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x04\x16Wa\r\xFA`\x01Ta+\rV[`\x1F\x81\x11a\x10\x01W[P_`\x1F\x82\x11`\x01\x14a\x0FIW\x81\x92_\x92a\x0F>W[PP\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82`\x01\x1B\x92`\x03\x1B\x1C\x19\x16\x17`\x01U[\x7F\xA9\x10\xF8\x0F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\n` R\x7Fk\xF6\xB3\xC2f\x8C\xBE\x14\x1Es\xF2\x94\x7F\xC4\xA6\x1F\x0F\xA3\xDD\t^48\xF5\xF1D\xC8\xE9\x81M9\x0BT`\xE0\x1B\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16a\x0E\xEAW`@Q\x7F\xA9\x10\xF8\x0F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` \x90\xF3[\x7F\xA9\x10\xF8\x0F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\n` \x90\x81R\x7Fk\xF6\xB3\xC2f\x8C\xBE\x14\x1Es\xF2\x94\x7F\xC4\xA6\x1F\x0F\xA3\xDD\t^48\xF5\xF1D\xC8\xE9\x81M9\x0BT`\xE0\x1Ba\x028V[\x015\x90P\x82\x80a\x0E\x19V[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x82\x16\x92\x7F\xB1\x0E-Rv\x12\x07;&\xEE\xCD\xFDq~j2\x0C\xF4KJ\xFA\xC2\xB0s-\x9F\xCB\xE2\xB7\xFA\x0C\xF6\x91_[\x85\x81\x10a\x0F\xE9WP\x83`\x01\x95\x10a\x0F\xB1W[PPP\x81\x1B\x01`\x01Ua\x0ELV[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\xF8\x85`\x03\x1B\x16\x1C\x19\x91\x015\x16\x90U\x82\x80\x80a\x0F\xA3V[\x90\x92` `\x01\x81\x92\x86\x86\x015\x81U\x01\x94\x01\x91\x01a\x0F\x91V[`\x1F\x82\x01`\x05\x1C\x7F\xB1\x0E-Rv\x12\x07;&\xEE\xCD\xFDq~j2\x0C\xF4KJ\xFA\xC2\xB0s-\x9F\xCB\xE2\xB7\xFA\x0C\xF6\x01\x90` \x83\x10a\x10vW[`\x1F\x01`\x05\x1C\x7F\xB1\x0E-Rv\x12\x07;&\xEE\xCD\xFDq~j2\x0C\xF4KJ\xFA\xC2\xB0s-\x9F\xCB\xE2\xB7\xFA\x0C\xF6\x01\x90[\x81\x81\x10a\x10kWPa\x0E\x03V[_\x81U`\x01\x01a\x10^V[\x7F\xB1\x0E-Rv\x12\x07;&\xEE\xCD\xFDq~j2\x0C\xF4KJ\xFA\xC2\xB0s-\x9F\xCB\xE2\xB7\xFA\x0C\xF6\x91Pa\x104V[4a\x04CW` \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x04CW\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x10\xF6a-&V[\x16_R`\n` R` `@_ T`\xE0\x1B\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`@Q\x91\x16\x81R\xF3[4a\x04CWa\x11@6a-UV[\x93P\x93PPPg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x04\x16Wa\x11``\x05Ta+\rV[`\x1F\x81\x11a\x13\x9CW[P_`\x1F\x82\x11`\x01\x14a\x12\xE4W\x81\x92_\x92a\x12\xD9W[PP\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82`\x01\x1B\x92`\x03\x1B\x1C\x19\x16\x17`\x05U[\x7F\x8D\xB2\xB6R\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\n` R\x7F\xAF-\x1E\xDA'\x89\x84\xC2j&\xB0\xC3\xE4\xF6\xB3\xC0\xBEp\xF0\xF58%\xD8\xB8e\xBC\x10\x1B%\x1F\"@T`\xE0\x1B\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16a\x12\x83Wa\x04\xB9\x7F\x8D\xB2\xB6R\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0[`@\x80Q\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\x92\x16\x82R_` \x83\x01R\x90\x91\x82\x91\x82\x01\x90V[\x7F\x8D\xB2\xB6R\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\n` R\x7F\xAF-\x1E\xDA'\x89\x84\xC2j&\xB0\xC3\xE4\xF6\xB3\xC0\xBEp\xF0\xF58%\xD8\xB8e\xBC\x10\x1B%\x1F\"@Ta\x04\xB9\x90`\xE0\x1Ba\x12JV[\x015\x90P\x82\x80a\x11\x7FV[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x82\x16\x92\x7F\x03kc\x84\xB5\xEC\xA7\x91\xC6'a\x15-\x0Cy\xBB\x06\x04\xC1\x04\xA5\xFBoN\xB0p?1T\xBB=\xB0\x91_[\x85\x81\x10a\x13\x84WP\x83`\x01\x95\x10a\x13LW[PPP\x81\x1B\x01`\x05Ua\x11\xB2V[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\xF8\x85`\x03\x1B\x16\x1C\x19\x91\x015\x16\x90U\x82\x80\x80a\x13>V[\x90\x92` `\x01\x81\x92\x86\x86\x015\x81U\x01\x94\x01\x91\x01a\x13,V[`\x1F\x82\x01`\x05\x1C\x7F\x03kc\x84\xB5\xEC\xA7\x91\xC6'a\x15-\x0Cy\xBB\x06\x04\xC1\x04\xA5\xFBoN\xB0p?1T\xBB=\xB0\x01\x90` \x83\x10a\x14\x11W[`\x1F\x01`\x05\x1C\x7F\x03kc\x84\xB5\xEC\xA7\x91\xC6'a\x15-\x0Cy\xBB\x06\x04\xC1\x04\xA5\xFBoN\xB0p?1T\xBB=\xB0\x01\x90[\x81\x81\x10a\x14\x06WPa\x11iV[_\x81U`\x01\x01a\x13\xF9V[\x7F\x03kc\x84\xB5\xEC\xA7\x91\xC6'a\x15-\x0Cy\xBB\x06\x04\xC1\x04\xA5\xFBoN\xB0p?1T\xBB=\xB0\x91Pa\x13\xCFV[4a\x04CW_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x04CW`@Q_`\x05Ta\x14w\x81a+\rV[\x80\x84R\x90`\x01\x81\x16\x90\x81\x15a\x05\x1BWP`\x01\x14a\x14\x9EWa\x04\xB9\x83a\x04\xAD\x81\x85\x03\x82a+^V[`\x05_\x90\x81R\x7F\x03kc\x84\xB5\xEC\xA7\x91\xC6'a\x15-\x0Cy\xBB\x06\x04\xC1\x04\xA5\xFBoN\xB0p?1T\xBB=\xB0\x93\x92P\x90[\x80\x82\x10a\x14\xE2WP\x90\x91P\x81\x01` \x01a\x04\xADa\x04\x9DV[\x91\x92`\x01\x81` \x92T\x83\x85\x88\x01\x01R\x01\x91\x01\x90\x92\x91a\x14\xCAV[4a\x04CW\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01`\xC0\x81\x12a\x04CW`\xA0\x13a\x04CW`\xA45a\xFF\xFF\x81\x16\x80\x91\x03a\x04CW`@Q`\xA0\x81\x01\x81\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x04\x16W`@Ra\x15ga+\xE7V[\x81R`$5s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x81\x03a\x04CW` \x82\x01R`D5b\xFF\xFF\xFF\x81\x16\x81\x03a\x04CW`@\x82\x01R`d5\x80`\x02\x0B\x81\x03a\x04CW``\x82\x01R`\x845\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x82\x03a\x04CW`\xA0\x91`\x80\x82\x01R _R`\x0B` R`@_ \x90\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\x82T\x16\x17\x90U_\x80\xF3[4a\x04CW_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x04CW`@Q_`\tTa\x16S\x81a+\rV[\x80\x84R\x90`\x01\x81\x16\x90\x81\x15a\x05\x1BWP`\x01\x14a\x16zWa\x04\xB9\x83a\x04\xAD\x81\x85\x03\x82a+^V[`\t_\x90\x81R\x7Fn\x15@\x17\x1Bl\x0C\x96\x0Bq\xA7\x02\r\x9F`\x07\x7Fj\xF91\xA8\xBB\xF5\x90\xDA\x02#\xDA\xCFu\xC7\xAF\x93\x92P\x90[\x80\x82\x10a\x16\xBEWP\x90\x91P\x81\x01` \x01a\x04\xADa\x04\x9DV[\x91\x92`\x01\x81` \x92T\x83\x85\x88\x01\x01R\x01\x91\x01\x90\x92\x91a\x16\xA6V[4a\x04CW_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x04CW`@Q_`\x07Ta\x17\x16\x81a+\rV[\x80\x84R\x90`\x01\x81\x16\x90\x81\x15a\x05\x1BWP`\x01\x14a\x17=Wa\x04\xB9\x83a\x04\xAD\x81\x85\x03\x82a+^V[`\x07_\x90\x81R\x7F\xA6l\xC9(\xB5\xED\xB8*\xF9\xBDI\x92)T\x15Z\xB7\xB0\x94&\x94\xBE\xA4\xCEDf\x1D\x9A\x876\xC6\x88\x93\x92P\x90[\x80\x82\x10a\x17\x81WP\x90\x91P\x81\x01` \x01a\x04\xADa\x04\x9DV[\x91\x92`\x01\x81` \x92T\x83\x85\x88\x01\x01R\x01\x91\x01\x90\x92\x91a\x17iV[4a\x04CWa\x17\xA96a-UV[\x93P\x93PPPg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x04\x16Wa\x17\xC9`\x03Ta+\rV[`\x1F\x81\x11a\x19\xD6W[P_`\x1F\x82\x11`\x01\x14a\x19\x1EW\x81\x92_\x92a\x19\x13W[PP\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82`\x01\x1B\x92`\x03\x1B\x1C\x19\x16\x17`\x03U[\x7FZ*\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\n` R\x7F\xE7X\xC5I\xC0\xB8\xD2\x03.\xB1\xBD1\x1A\xD4g]\xB3E\xBF\xF5\xF7\xB6\xAD6\xAA\xFBP\xC2\t!s\x0CT`\xE0\x1B\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16a\x18\xBDW`@\x80Q\x7FZ*\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R_` \x82\x01R\xF3[\x7FZ*\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\n` R\x7F\xE7X\xC5I\xC0\xB8\xD2\x03.\xB1\xBD1\x1A\xD4g]\xB3E\xBF\xF5\xF7\xB6\xAD6\xAA\xFBP\xC2\t!s\x0CTa\x04\xB9\x90`\xE0\x1Ba\x12JV[\x015\x90P\x82\x80a\x17\xE8V[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x82\x16\x92\x7F\xC2WZ\x0E\x9EY<\0\xF9Y\xF8\xC9/\x12\xDB(i\xC39Z;\x05\x02\xD0^%\x16Doq\xF8[\x91_[\x85\x81\x10a\x19\xBEWP\x83`\x01\x95\x10a\x19\x86W[PPP\x81\x1B\x01`\x03Ua\x18\x1BV[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\xF8\x85`\x03\x1B\x16\x1C\x19\x91\x015\x16\x90U\x82\x80\x80a\x19xV[\x90\x92` `\x01\x81\x92\x86\x86\x015\x81U\x01\x94\x01\x91\x01a\x19fV[`\x1F\x82\x01`\x05\x1C\x7F\xC2WZ\x0E\x9EY<\0\xF9Y\xF8\xC9/\x12\xDB(i\xC39Z;\x05\x02\xD0^%\x16Doq\xF8[\x01\x90` \x83\x10a\x1AKW[`\x1F\x01`\x05\x1C\x7F\xC2WZ\x0E\x9EY<\0\xF9Y\xF8\xC9/\x12\xDB(i\xC39Z;\x05\x02\xD0^%\x16Doq\xF8[\x01\x90[\x81\x81\x10a\x1A@WPa\x17\xD2V[_\x81U`\x01\x01a\x1A3V[\x7F\xC2WZ\x0E\x9EY<\0\xF9Y\xF8\xC9/\x12\xDB(i\xC39Z;\x05\x02\xD0^%\x16Doq\xF8[\x91Pa\x1A\tV[4a\x04CW`@\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x04CWa\x1A\xAAa-&V[`$5\x90\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x16\x82\x03a\x04CW\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16_R`\n` R`@_ \x90`\xE0\x1C\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\x82T\x16\x17\x90U_\x80\xF3[4a\x04CWa\x01@\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x04CWa\x1Bka+\xE7V[P`\xA0\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xDC6\x01\x12a\x04CW``\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF<6\x01\x12a\x04CWa\x01$5g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x04CWa\x1B\xE1\x906\x90`\x04\x01a,\nV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x04\x16Wa\x1B\xFB`\x06Ta+\rV[`\x1F\x81\x11a\x1E2W[P_`\x1F\x82\x11`\x01\x14a\x1DzW\x81\x92_\x92a\x1DoW[PP\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82`\x01\x1B\x92`\x03\x1B\x1C\x19\x16\x17`\x06U[\x7FW^$\xB4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\n` R\x7F\x8FOZ12\xB3(j\x8EzM\xDB\\\xD5_\xE3\xB9\x8D_\xC4*f\xD2\x17\xEA\xE1\xC8K\x87>\xBA\xF2T`\xE0\x1B\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16a\x1D\x1AW``\x7FW^$\xB4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0[\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`@Q\x91\x16\x81R_` \x82\x01R_`@\x82\x01R\xF3[\x7FW^$\xB4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\n` R\x7F\x8FOZ12\xB3(j\x8EzM\xDB\\\xD5_\xE3\xB9\x8D_\xC4*f\xD2\x17\xEA\xE1\xC8K\x87>\xBA\xF2T``\x90`\xE0\x1Ba\x1C\xE4V[\x015\x90P\x82\x80a\x1C\x1AV[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x82\x16\x92\x7F\xF6R\"#\x13\xE2\x84YR\x8D\x92\x0Be\x11\\\x16\xC0O>\xFC\x82\xAA\xED\xC9{\xE5\x9F?7|\r?\x91_[\x85\x81\x10a\x1E\x1AWP\x83`\x01\x95\x10a\x1D\xE2W[PPP\x81\x1B\x01`\x06Ua\x1CMV[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\xF8\x85`\x03\x1B\x16\x1C\x19\x91\x015\x16\x90U\x82\x80\x80a\x1D\xD4V[\x90\x92` `\x01\x81\x92\x86\x86\x015\x81U\x01\x94\x01\x91\x01a\x1D\xC2V[`\x1F\x82\x01`\x05\x1C\x7F\xF6R\"#\x13\xE2\x84YR\x8D\x92\x0Be\x11\\\x16\xC0O>\xFC\x82\xAA\xED\xC9{\xE5\x9F?7|\r?\x01\x90` \x83\x10a\x1E\xA7W[`\x1F\x01`\x05\x1C\x7F\xF6R\"#\x13\xE2\x84YR\x8D\x92\x0Be\x11\\\x16\xC0O>\xFC\x82\xAA\xED\xC9{\xE5\x9F?7|\r?\x01\x90[\x81\x81\x10a\x1E\x9CWPa\x1C\x04V[_\x81U`\x01\x01a\x1E\x8FV[\x7F\xF6R\"#\x13\xE2\x84YR\x8D\x92\x0Be\x11\\\x16\xC0O>\xFC\x82\xAA\xED\xC9{\xE5\x9F?7|\r?\x91Pa\x1EeV[4a\x04CW_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x04CW`@Q_`\x06Ta\x1F\r\x81a+\rV[\x80\x84R\x90`\x01\x81\x16\x90\x81\x15a\x05\x1BWP`\x01\x14a\x1F4Wa\x04\xB9\x83a\x04\xAD\x81\x85\x03\x82a+^V[`\x06_\x90\x81R\x7F\xF6R\"#\x13\xE2\x84YR\x8D\x92\x0Be\x11\\\x16\xC0O>\xFC\x82\xAA\xED\xC9{\xE5\x9F?7|\r?\x93\x92P\x90[\x80\x82\x10a\x1FxWP\x90\x91P\x81\x01` \x01a\x04\xADa\x04\x9DV[\x91\x92`\x01\x81` \x92T\x83\x85\x88\x01\x01R\x01\x91\x01\x90\x92\x91a\x1F`V[4a\x04CW_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x04CW`@Q_\x80Ta\x1F\xCF\x81a+\rV[\x80\x84R\x90`\x01\x81\x16\x90\x81\x15a\x05\x1BWP`\x01\x14a\x1F\xF6Wa\x04\xB9\x83a\x04\xAD\x81\x85\x03\x82a+^V[_\x80\x80R\x7F)\r\xEC\xD9T\x8Bb\xA8\xD6\x03E\xA9\x888o\xC8K\xA6\xBC\x95H@\x08\xF66/\x93\x16\x0E\xF3\xE5c\x93\x92P\x90[\x80\x82\x10a 8WP\x90\x91P\x81\x01` \x01a\x04\xADa\x04\x9DV[\x91\x92`\x01\x81` \x92T\x83\x85\x88\x01\x01R\x01\x91\x01\x90\x92\x91a  V[4a\x04CW_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x04CW`@Q_`\x04Ta \x90\x81a+\rV[\x80\x84R\x90`\x01\x81\x16\x90\x81\x15a\x05\x1BWP`\x01\x14a \xB7Wa\x04\xB9\x83a\x04\xAD\x81\x85\x03\x82a+^V[`\x04_\x90\x81R\x7F\x8A5\xAC\xFB\xC1_\xF8\x1A9\xAE}4O\xD7\t\xF2\x8E\x86\0\xB4\xAA\x8Ce\xC6\xB6K\xFE\x7F\xE3k\xD1\x9B\x93\x92P\x90[\x80\x82\x10a \xFBWP\x90\x91P\x81\x01` \x01a\x04\xADa\x04\x9DV[\x91\x92`\x01\x81` \x92T\x83\x85\x88\x01\x01R\x01\x91\x01\x90\x92\x91a \xE3V[4a\x04CWa\x01\0\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x04CWa!Ma+\xE7V[P`\xA0\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xDC6\x01\x12a\x04CWa!\x80a-\x03V[P`\xE45g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x04CWa!\xA1\x906\x90`\x04\x01a,\nV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x04\x16Wa!\xBA_Ta+\rV[`\x1F\x81\x11a#\xBFW[P_`\x1F\x82\x11`\x01\x14a#\x08W\x81\x92_\x92a\"\xFDW[PP\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82`\x01\x1B\x92`\x03\x1B\x1C\x19\x16\x17_U[\x7F4@\xD8 \0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\n` R\x7Fo\x93+\x1D,^\xBE\xE2\xA6z\x1E\x97\x84\xCF\x96\x84\xC2\xC9\xB8M\xCC\x0B\x9Fu\t\xEFp\xB3\xF67]5T`\xE0\x1B\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16a\"\xA9W`@Q\x7F4@\xD8 \0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` \x90\xF3[\x7F4@\xD8 \0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\n` \x90\x81R\x7Fo\x93+\x1D,^\xBE\xE2\xA6z\x1E\x97\x84\xCF\x96\x84\xC2\xC9\xB8M\xCC\x0B\x9Fu\t\xEFp\xB3\xF67]5T`\xE0\x1Ba\x028V[\x015\x90P\x82\x80a!\xD9V[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x82\x16\x92\x7F)\r\xEC\xD9T\x8Bb\xA8\xD6\x03E\xA9\x888o\xC8K\xA6\xBC\x95H@\x08\xF66/\x93\x16\x0E\xF3\xE5c\x91_[\x85\x81\x10a#\xA7WP\x83`\x01\x95\x10a#oW[PPP\x81\x1B\x01_Ua\"\x0BV[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\xF8\x85`\x03\x1B\x16\x1C\x19\x91\x015\x16\x90U\x82\x80\x80a#bV[\x90\x92` `\x01\x81\x92\x86\x86\x015\x81U\x01\x94\x01\x91\x01a#PV[`\x1F\x82\x01`\x05\x1C\x7F)\r\xEC\xD9T\x8Bb\xA8\xD6\x03E\xA9\x888o\xC8K\xA6\xBC\x95H@\x08\xF66/\x93\x16\x0E\xF3\xE5c\x01\x90` \x83\x10a$4W[`\x1F\x01`\x05\x1C\x7F)\r\xEC\xD9T\x8Bb\xA8\xD6\x03E\xA9\x888o\xC8K\xA6\xBC\x95H@\x08\xF66/\x93\x16\x0E\xF3\xE5c\x01\x90[\x81\x81\x10a$)WPa!\xC3V[_\x81U`\x01\x01a$\x1CV[\x7F)\r\xEC\xD9T\x8Bb\xA8\xD6\x03E\xA9\x888o\xC8K\xA6\xBC\x95H@\x08\xF66/\x93\x16\x0E\xF3\xE5c\x91Pa#\xF2V[4a\x04CWa$j6a,8V[\x92P\x92PPg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x04\x16Wa$\x89`\x02Ta+\rV[`\x1F\x81\x11a&\x90W[P_`\x1F\x82\x11`\x01\x14a%\xD8W\x81\x92_\x92a%\xCDW[PP\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82`\x01\x1B\x92`\x03\x1B\x1C\x19\x16\x17`\x02U[\x7F%\x99\x82\xE5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\n` R\x7F\xC3\xEB\x88W\xB9y\xA3\x9A#/YJ\xCA\x1F\xEB=:\x12\xB1\xF8\x08u\x16Q\xF5\x17\xED\x9E\xFF\xC52yT`\xE0\x1B\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16a%yW`@Q\x7F%\x99\x82\xE5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` \x90\xF3[\x7F%\x99\x82\xE5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\n` \x90\x81R\x7F\xC3\xEB\x88W\xB9y\xA3\x9A#/YJ\xCA\x1F\xEB=:\x12\xB1\xF8\x08u\x16Q\xF5\x17\xED\x9E\xFF\xC52yT`\xE0\x1Ba\x028V[\x015\x90P\x82\x80a$\xA8V[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x82\x16\x92\x7F@W\x87\xFA\x12\xA8#\xE0\xF2\xB7c\x1C\xC4\x1B;\xA8\x82\x8B3!\xCA\x81\x11\x11\xFAu\xCD:\xA3\xBBZ\xCE\x91_[\x85\x81\x10a&xWP\x83`\x01\x95\x10a&@W[PPP\x81\x1B\x01`\x02Ua$\xDBV[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\xF8\x85`\x03\x1B\x16\x1C\x19\x91\x015\x16\x90U\x82\x80\x80a&2V[\x90\x92` `\x01\x81\x92\x86\x86\x015\x81U\x01\x94\x01\x91\x01a& V[`\x1F\x82\x01`\x05\x1C\x7F@W\x87\xFA\x12\xA8#\xE0\xF2\xB7c\x1C\xC4\x1B;\xA8\x82\x8B3!\xCA\x81\x11\x11\xFAu\xCD:\xA3\xBBZ\xCE\x01\x90` \x83\x10a'\x05W[`\x1F\x01`\x05\x1C\x7F@W\x87\xFA\x12\xA8#\xE0\xF2\xB7c\x1C\xC4\x1B;\xA8\x82\x8B3!\xCA\x81\x11\x11\xFAu\xCD:\xA3\xBBZ\xCE\x01\x90[\x81\x81\x10a&\xFAWPa$\x92V[_\x81U`\x01\x01a&\xEDV[\x7F@W\x87\xFA\x12\xA8#\xE0\xF2\xB7c\x1C\xC4\x1B;\xA8\x82\x8B3!\xCA\x81\x11\x11\xFAu\xCD:\xA3\xBBZ\xCE\x91Pa&\xC3V[4a\x04CWa';6a,8V[\x92P\x92PPg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x04\x16Wa'Z`\x04Ta+\rV[`\x1F\x81\x11a)aW[P_`\x1F\x82\x11`\x01\x14a(\xA9W\x81\x92_\x92a(\x9EW[PP\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82`\x01\x1B\x92`\x03\x1B\x1C\x19\x16\x17`\x04U[\x7F!\xD0\xEEp\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\n` R\x7F<\xA7i\x96\xC4\xDE8\x04\xEE\xAB3{\xFF\x8D\x94M\xE8\xDE#yf,\x86f\xE6\xFF\xE7\xBF\xA2:\x1BCT`\xE0\x1B\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16a(JW`@Q\x7F!\xD0\xEEp\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` \x90\xF3[\x7F!\xD0\xEEp\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\n` \x90\x81R\x7F<\xA7i\x96\xC4\xDE8\x04\xEE\xAB3{\xFF\x8D\x94M\xE8\xDE#yf,\x86f\xE6\xFF\xE7\xBF\xA2:\x1BCT`\xE0\x1Ba\x028V[\x015\x90P\x82\x80a'yV[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x82\x16\x92\x7F\x8A5\xAC\xFB\xC1_\xF8\x1A9\xAE}4O\xD7\t\xF2\x8E\x86\0\xB4\xAA\x8Ce\xC6\xB6K\xFE\x7F\xE3k\xD1\x9B\x91_[\x85\x81\x10a)IWP\x83`\x01\x95\x10a)\x11W[PPP\x81\x1B\x01`\x04Ua'\xACV[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\xF8\x85`\x03\x1B\x16\x1C\x19\x91\x015\x16\x90U\x82\x80\x80a)\x03V[\x90\x92` `\x01\x81\x92\x86\x86\x015\x81U\x01\x94\x01\x91\x01a(\xF1V[`\x1F\x82\x01`\x05\x1C\x7F\x8A5\xAC\xFB\xC1_\xF8\x1A9\xAE}4O\xD7\t\xF2\x8E\x86\0\xB4\xAA\x8Ce\xC6\xB6K\xFE\x7F\xE3k\xD1\x9B\x01\x90` \x83\x10a)\xD6W[`\x1F\x01`\x05\x1C\x7F\x8A5\xAC\xFB\xC1_\xF8\x1A9\xAE}4O\xD7\t\xF2\x8E\x86\0\xB4\xAA\x8Ce\xC6\xB6K\xFE\x7F\xE3k\xD1\x9B\x01\x90[\x81\x81\x10a)\xCBWPa'cV[_\x81U`\x01\x01a)\xBEV[\x7F\x8A5\xAC\xFB\xC1_\xF8\x1A9\xAE}4O\xD7\t\xF2\x8E\x86\0\xB4\xAA\x8Ce\xC6\xB6K\xFE\x7F\xE3k\xD1\x9B\x91Pa)\x94V[4a\x04CW` \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x04CW`\x045_R`\x0B` R` a\xFF\xFF`@_ T\x16`@Q\x90\x81R\xF3[4a\x04CW_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x04CW`@Q_`\x01Ta*\x88\x81a+\rV[\x80\x84R\x90`\x01\x81\x16\x90\x81\x15a\x05\x1BWP`\x01\x14a*\xAFWa\x04\xB9\x83a\x04\xAD\x81\x85\x03\x82a+^V[`\x01_\x90\x81R\x7F\xB1\x0E-Rv\x12\x07;&\xEE\xCD\xFDq~j2\x0C\xF4KJ\xFA\xC2\xB0s-\x9F\xCB\xE2\xB7\xFA\x0C\xF6\x93\x92P\x90[\x80\x82\x10a*\xF3WP\x90\x91P\x81\x01` \x01a\x04\xADa\x04\x9DV[\x91\x92`\x01\x81` \x92T\x83\x85\x88\x01\x01R\x01\x91\x01\x90\x92\x91a*\xDBV[\x90`\x01\x82\x81\x1C\x92\x16\x80\x15a+TW[` \x83\x10\x14a+'WV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\"`\x04R`$_\xFD[\x91`\x7F\x16\x91a+\x1CV[\x90`\x1F\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x91\x01\x16\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x04\x16W`@RV[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0`\x1F` `@\x94\x81\x85R\x80Q\x91\x82\x91\x82\x82\x88\x01R\x01\x86\x86\x01^_\x85\x82\x86\x01\x01R\x01\x16\x01\x01\x90V[`\x045\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x82\x03a\x04CWV[\x91\x81`\x1F\x84\x01\x12\x15a\x04CW\x825\x91g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11a\x04CW` \x83\x81\x86\x01\x95\x01\x01\x11a\x04CWV[\x90a\x01`\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC\x83\x01\x12a\x04CW`\x045s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x81\x03a\x04CW\x91`\xA0\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xDC\x82\x01\x12a\x04CW`$\x91`\x80\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF<\x83\x01\x12a\x04CW`\xC4\x91a\x01D5\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x04CWa,\xFF\x91`\x04\x01a,\nV[\x90\x91V[`\xC45\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x82\x03a\x04CWV[`\x045\x90\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x16\x82\x03a\x04CWV[a\x01\x80\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC\x82\x01\x12a\x04CW`\x045s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x81\x03a\x04CW\x91`\xA0\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xDC\x83\x01\x12a\x04CW`$\x91`\x80\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF<\x82\x01\x12a\x04CW`\xC4\x91a\x01D5\x91a\x01d5\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x04CWa,\xFF\x91`\x04\x01a,\nV[`\xE45\x90\x81`\x02\x0B\x82\x03a\x04CWV[a\x01 \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC\x82\x01\x12a\x04CW`\x045s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x81\x03a\x04CW\x91`\xA0\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xDC\x83\x01\x12a\x04CW`$\x91`\xC45\x91`\xE45\x91a\x01\x045\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x04CWa,\xFF\x91`\x04\x01a,\nV\xFE\xA2dipfsX\"\x12 f\x97\xE6,\xA0c-IE\x8C\xBC\xED\x7F\xBAc\xAF\\\xF6=\x8C\xB0d\x0F\xDD\xF6\x95gq\x84s\xE3\xA7dsolcC\0\x08\x1A\x003",
    );
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct BalanceDelta(alloy::sol_types::private::I256);
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<BalanceDelta>
        for alloy::sol_types::private::I256 {
            #[inline]
            fn stv_to_tokens(
                &self,
            ) -> <alloy::sol_types::sol_data::Int<
                256,
            > as alloy_sol_types::SolType>::Token<'_> {
                alloy_sol_types::private::SolTypeValue::<
                    alloy::sol_types::sol_data::Int<256>,
                >::stv_to_tokens(self)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <alloy::sol_types::sol_data::Int<
                    256,
                > as alloy_sol_types::SolType>::tokenize(self)
                    .0
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Int<
                    256,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(self, out)
            }
        }
        #[automatically_derived]
        impl BalanceDelta {
            /// The Solidity type name.
            pub const NAME: &'static str = stringify!(@ name);
            /// Convert from the underlying value type.
            #[inline]
            pub const fn from(value: alloy::sol_types::private::I256) -> Self {
                Self(value)
            }
            /// Return the underlying value.
            #[inline]
            pub const fn into(self) -> alloy::sol_types::private::I256 {
                self.0
            }
            /// Return the single encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode(&self.0)
            }
            /// Return the packed encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode_packed(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode_packed(&self.0)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for BalanceDelta {
            type RustType = alloy::sol_types::private::I256;
            type Token<'a> = <alloy::sol_types::sol_data::Int<
                256,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = Self::NAME;
            const ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Int<
                256,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                Self::type_check(token).is_ok()
            }
            #[inline]
            fn type_check(token: &Self::Token<'_>) -> alloy_sol_types::Result<()> {
                <alloy::sol_types::sol_data::Int<
                    256,
                > as alloy_sol_types::SolType>::type_check(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                <alloy::sol_types::sol_data::Int<
                    256,
                > as alloy_sol_types::SolType>::detokenize(token)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for BalanceDelta {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                <alloy::sol_types::sol_data::Int<
                    256,
                > as alloy_sol_types::EventTopic>::topic_preimage_length(rust)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Int<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, out)
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                <alloy::sol_types::sol_data::Int<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(rust)
            }
        }
    };
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct BeforeSwapDelta(alloy::sol_types::private::I256);
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<BeforeSwapDelta>
        for alloy::sol_types::private::I256 {
            #[inline]
            fn stv_to_tokens(
                &self,
            ) -> <alloy::sol_types::sol_data::Int<
                256,
            > as alloy_sol_types::SolType>::Token<'_> {
                alloy_sol_types::private::SolTypeValue::<
                    alloy::sol_types::sol_data::Int<256>,
                >::stv_to_tokens(self)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <alloy::sol_types::sol_data::Int<
                    256,
                > as alloy_sol_types::SolType>::tokenize(self)
                    .0
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Int<
                    256,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(self, out)
            }
        }
        #[automatically_derived]
        impl BeforeSwapDelta {
            /// The Solidity type name.
            pub const NAME: &'static str = stringify!(@ name);
            /// Convert from the underlying value type.
            #[inline]
            pub const fn from(value: alloy::sol_types::private::I256) -> Self {
                Self(value)
            }
            /// Return the underlying value.
            #[inline]
            pub const fn into(self) -> alloy::sol_types::private::I256 {
                self.0
            }
            /// Return the single encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode(&self.0)
            }
            /// Return the packed encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode_packed(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode_packed(&self.0)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for BeforeSwapDelta {
            type RustType = alloy::sol_types::private::I256;
            type Token<'a> = <alloy::sol_types::sol_data::Int<
                256,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = Self::NAME;
            const ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Int<
                256,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                Self::type_check(token).is_ok()
            }
            #[inline]
            fn type_check(token: &Self::Token<'_>) -> alloy_sol_types::Result<()> {
                <alloy::sol_types::sol_data::Int<
                    256,
                > as alloy_sol_types::SolType>::type_check(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                <alloy::sol_types::sol_data::Int<
                    256,
                > as alloy_sol_types::SolType>::detokenize(token)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for BeforeSwapDelta {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                <alloy::sol_types::sol_data::Int<
                    256,
                > as alloy_sol_types::EventTopic>::topic_preimage_length(rust)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Int<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, out)
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                <alloy::sol_types::sol_data::Int<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(rust)
            }
        }
    };
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct Currency(alloy::sol_types::private::Address);
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Currency>
        for alloy::sol_types::private::Address {
            #[inline]
            fn stv_to_tokens(
                &self,
            ) -> <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::Token<
                '_,
            > {
                alloy_sol_types::private::SolTypeValue::<
                    alloy::sol_types::sol_data::Address,
                >::stv_to_tokens(self)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        self,
                    )
                    .0
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::abi_encode_packed_to(
                    self,
                    out,
                )
            }
        }
        #[automatically_derived]
        impl Currency {
            /// The Solidity type name.
            pub const NAME: &'static str = stringify!(@ name);
            /// Convert from the underlying value type.
            #[inline]
            pub const fn from(value: alloy::sol_types::private::Address) -> Self {
                Self(value)
            }
            /// Return the underlying value.
            #[inline]
            pub const fn into(self) -> alloy::sol_types::private::Address {
                self.0
            }
            /// Return the single encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode(&self.0)
            }
            /// Return the packed encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode_packed(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode_packed(&self.0)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for Currency {
            type RustType = alloy::sol_types::private::Address;
            type Token<'a> = <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::Token<
                'a,
            >;
            const SOL_NAME: &'static str = Self::NAME;
            const ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                Self::type_check(token).is_ok()
            }
            #[inline]
            fn type_check(token: &Self::Token<'_>) -> alloy_sol_types::Result<()> {
                <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::type_check(
                    token,
                )
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::detokenize(
                    token,
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for Currency {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                    rust,
                )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    out,
                )
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    rust,
                )
            }
        }
    };
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct PoolId(alloy::sol_types::private::FixedBytes<32>);
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<PoolId>
        for alloy::sol_types::private::FixedBytes<32> {
            #[inline]
            fn stv_to_tokens(
                &self,
            ) -> <alloy::sol_types::sol_data::FixedBytes<
                32,
            > as alloy_sol_types::SolType>::Token<'_> {
                alloy_sol_types::private::SolTypeValue::<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >::stv_to_tokens(self)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::SolType>::tokenize(self)
                    .0
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(self, out)
            }
        }
        #[automatically_derived]
        impl PoolId {
            /// The Solidity type name.
            pub const NAME: &'static str = stringify!(@ name);
            /// Convert from the underlying value type.
            #[inline]
            pub const fn from(value: alloy::sol_types::private::FixedBytes<32>) -> Self {
                Self(value)
            }
            /// Return the underlying value.
            #[inline]
            pub const fn into(self) -> alloy::sol_types::private::FixedBytes<32> {
                self.0
            }
            /// Return the single encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode(&self.0)
            }
            /// Return the packed encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode_packed(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode_packed(&self.0)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for PoolId {
            type RustType = alloy::sol_types::private::FixedBytes<32>;
            type Token<'a> = <alloy::sol_types::sol_data::FixedBytes<
                32,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = Self::NAME;
            const ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::FixedBytes<
                32,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                Self::type_check(token).is_ok()
            }
            #[inline]
            fn type_check(token: &Self::Token<'_>) -> alloy_sol_types::Result<()> {
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::SolType>::type_check(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::SolType>::detokenize(token)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for PoolId {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::topic_preimage_length(rust)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, out)
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(rust)
            }
        }
    };
    /**```solidity
struct ModifyLiquidityParams { int24 tickLower; int24 tickUpper; int256 liquidityDelta; bytes32 salt; }
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct ModifyLiquidityParams {
        pub tickLower: <alloy::sol_types::sol_data::Int<
            24,
        > as alloy::sol_types::SolType>::RustType,
        pub tickUpper: <alloy::sol_types::sol_data::Int<
            24,
        > as alloy::sol_types::SolType>::RustType,
        pub liquidityDelta: alloy::sol_types::private::I256,
        pub salt: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Int<24>,
            alloy::sol_types::sol_data::Int<24>,
            alloy::sol_types::sol_data::Int<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            <alloy::sol_types::sol_data::Int<24> as alloy::sol_types::SolType>::RustType,
            <alloy::sol_types::sol_data::Int<24> as alloy::sol_types::SolType>::RustType,
            alloy::sol_types::private::I256,
            alloy::sol_types::private::FixedBytes<32>,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ModifyLiquidityParams> for UnderlyingRustTuple<'_> {
            fn from(value: ModifyLiquidityParams) -> Self {
                (value.tickLower, value.tickUpper, value.liquidityDelta, value.salt)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ModifyLiquidityParams {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    tickLower: tuple.0,
                    tickUpper: tuple.1,
                    liquidityDelta: tuple.2,
                    salt: tuple.3,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for ModifyLiquidityParams {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for ModifyLiquidityParams {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Int<
                        24,
                    > as alloy_sol_types::SolType>::tokenize(&self.tickLower),
                    <alloy::sol_types::sol_data::Int<
                        24,
                    > as alloy_sol_types::SolType>::tokenize(&self.tickUpper),
                    <alloy::sol_types::sol_data::Int<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.liquidityDelta),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.salt),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for ModifyLiquidityParams {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for ModifyLiquidityParams {
            const NAME: &'static str = "ModifyLiquidityParams";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "ModifyLiquidityParams(int24 tickLower,int24 tickUpper,int256 liquidityDelta,bytes32 salt)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Int<
                        24,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.tickLower)
                        .0,
                    <alloy::sol_types::sol_data::Int<
                        24,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.tickUpper)
                        .0,
                    <alloy::sol_types::sol_data::Int<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.liquidityDelta,
                        )
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.salt)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for ModifyLiquidityParams {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Int<
                        24,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.tickLower,
                    )
                    + <alloy::sol_types::sol_data::Int<
                        24,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.tickUpper,
                    )
                    + <alloy::sol_types::sol_data::Int<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.liquidityDelta,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.salt)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Int<
                    24,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.tickLower,
                    out,
                );
                <alloy::sol_types::sol_data::Int<
                    24,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.tickUpper,
                    out,
                );
                <alloy::sol_types::sol_data::Int<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.liquidityDelta,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.salt,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct PoolKey { Currency currency0; Currency currency1; uint24 fee; int24 tickSpacing; address hooks; }
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct PoolKey {
        pub currency0: <Currency as alloy::sol_types::SolType>::RustType,
        pub currency1: <Currency as alloy::sol_types::SolType>::RustType,
        pub fee: <alloy::sol_types::sol_data::Uint<
            24,
        > as alloy::sol_types::SolType>::RustType,
        pub tickSpacing: <alloy::sol_types::sol_data::Int<
            24,
        > as alloy::sol_types::SolType>::RustType,
        pub hooks: alloy::sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            Currency,
            Currency,
            alloy::sol_types::sol_data::Uint<24>,
            alloy::sol_types::sol_data::Int<24>,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            <Currency as alloy::sol_types::SolType>::RustType,
            <Currency as alloy::sol_types::SolType>::RustType,
            <alloy::sol_types::sol_data::Uint<
                24,
            > as alloy::sol_types::SolType>::RustType,
            <alloy::sol_types::sol_data::Int<24> as alloy::sol_types::SolType>::RustType,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<PoolKey> for UnderlyingRustTuple<'_> {
            fn from(value: PoolKey) -> Self {
                (
                    value.currency0,
                    value.currency1,
                    value.fee,
                    value.tickSpacing,
                    value.hooks,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for PoolKey {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    currency0: tuple.0,
                    currency1: tuple.1,
                    fee: tuple.2,
                    tickSpacing: tuple.3,
                    hooks: tuple.4,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for PoolKey {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for PoolKey {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <Currency as alloy_sol_types::SolType>::tokenize(&self.currency0),
                    <Currency as alloy_sol_types::SolType>::tokenize(&self.currency1),
                    <alloy::sol_types::sol_data::Uint<
                        24,
                    > as alloy_sol_types::SolType>::tokenize(&self.fee),
                    <alloy::sol_types::sol_data::Int<
                        24,
                    > as alloy_sol_types::SolType>::tokenize(&self.tickSpacing),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.hooks,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for PoolKey {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for PoolKey {
            const NAME: &'static str = "PoolKey";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "PoolKey(address currency0,address currency1,uint24 fee,int24 tickSpacing,address hooks)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <Currency as alloy_sol_types::SolType>::eip712_data_word(
                            &self.currency0,
                        )
                        .0,
                    <Currency as alloy_sol_types::SolType>::eip712_data_word(
                            &self.currency1,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        24,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.fee)
                        .0,
                    <alloy::sol_types::sol_data::Int<
                        24,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.tickSpacing)
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.hooks,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for PoolKey {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <Currency as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.currency0,
                    )
                    + <Currency as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.currency1,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        24,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.fee)
                    + <alloy::sol_types::sol_data::Int<
                        24,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.tickSpacing,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.hooks,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <Currency as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.currency0,
                    out,
                );
                <Currency as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.currency1,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    24,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.fee, out);
                <alloy::sol_types::sol_data::Int<
                    24,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.tickSpacing,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.hooks,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct SwapParams { bool zeroForOne; int256 amountSpecified; uint160 sqrtPriceLimitX96; }
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct SwapParams {
        pub zeroForOne: bool,
        pub amountSpecified: alloy::sol_types::private::I256,
        pub sqrtPriceLimitX96: <alloy::sol_types::sol_data::Uint<
            160,
        > as alloy::sol_types::SolType>::RustType,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bool,
            alloy::sol_types::sol_data::Int<256>,
            alloy::sol_types::sol_data::Uint<160>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            bool,
            alloy::sol_types::private::I256,
            <alloy::sol_types::sol_data::Uint<
                160,
            > as alloy::sol_types::SolType>::RustType,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SwapParams> for UnderlyingRustTuple<'_> {
            fn from(value: SwapParams) -> Self {
                (value.zeroForOne, value.amountSpecified, value.sqrtPriceLimitX96)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for SwapParams {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    zeroForOne: tuple.0,
                    amountSpecified: tuple.1,
                    sqrtPriceLimitX96: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for SwapParams {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for SwapParams {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.zeroForOne,
                    ),
                    <alloy::sol_types::sol_data::Int<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amountSpecified),
                    <alloy::sol_types::sol_data::Uint<
                        160,
                    > as alloy_sol_types::SolType>::tokenize(&self.sqrtPriceLimitX96),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for SwapParams {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for SwapParams {
            const NAME: &'static str = "SwapParams";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "SwapParams(bool zeroForOne,int256 amountSpecified,uint160 sqrtPriceLimitX96)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::eip712_data_word(
                            &self.zeroForOne,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Int<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.amountSpecified,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        160,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sqrtPriceLimitX96,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for SwapParams {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.zeroForOne,
                    )
                    + <alloy::sol_types::sol_data::Int<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.amountSpecified,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        160,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sqrtPriceLimitX96,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.zeroForOne,
                    out,
                );
                <alloy::sol_types::sol_data::Int<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.amountSpecified,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    160,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sqrtPriceLimitX96,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**Function with signature `afterAddLiquidity(address,(address,address,uint24,int24,address),(int24,int24,int256,bytes32),int256,bytes)` and selector `0x5a2a8100`.
```solidity
function afterAddLiquidity(address, PoolKey memory, ModifyLiquidityParams memory, BalanceDelta, bytes memory hookData) external returns (bytes4, BalanceDelta);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct afterAddLiquidityCall {
        pub _0: alloy::sol_types::private::Address,
        pub _1: <PoolKey as alloy::sol_types::SolType>::RustType,
        pub _2: <ModifyLiquidityParams as alloy::sol_types::SolType>::RustType,
        pub _3: <BalanceDelta as alloy::sol_types::SolType>::RustType,
        pub hookData: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`afterAddLiquidity(address,(address,address,uint24,int24,address),(int24,int24,int256,bytes32),int256,bytes)`](afterAddLiquidityCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct afterAddLiquidityReturn {
        pub _0: alloy::sol_types::private::FixedBytes<4>,
        pub _1: <BalanceDelta as alloy::sol_types::SolType>::RustType,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                PoolKey,
                ModifyLiquidityParams,
                BalanceDelta,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                <PoolKey as alloy::sol_types::SolType>::RustType,
                <ModifyLiquidityParams as alloy::sol_types::SolType>::RustType,
                <BalanceDelta as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<afterAddLiquidityCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: afterAddLiquidityCall) -> Self {
                    (value._0, value._1, value._2, value._3, value.hookData)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for afterAddLiquidityCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _0: tuple.0,
                        _1: tuple.1,
                        _2: tuple.2,
                        _3: tuple.3,
                        hookData: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<4>,
                BalanceDelta,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<4>,
                <BalanceDelta as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<afterAddLiquidityReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: afterAddLiquidityReturn) -> Self {
                    (value._0, value._1)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for afterAddLiquidityReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0, _1: tuple.1 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for afterAddLiquidityCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                PoolKey,
                ModifyLiquidityParams,
                BalanceDelta,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = afterAddLiquidityReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<4>,
                BalanceDelta,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "afterAddLiquidity(address,(address,address,uint24,int24,address),(int24,int24,int256,bytes32),int256,bytes)";
            const SELECTOR: [u8; 4] = [90u8, 42u8, 129u8, 0u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._0,
                    ),
                    <PoolKey as alloy_sol_types::SolType>::tokenize(&self._1),
                    <ModifyLiquidityParams as alloy_sol_types::SolType>::tokenize(
                        &self._2,
                    ),
                    <BalanceDelta as alloy_sol_types::SolType>::tokenize(&self._3),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.hookData,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `afterAddLiquidityData()` and selector `0xb8516466`.
```solidity
function afterAddLiquidityData() external view returns (bytes memory);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct afterAddLiquidityDataCall {}
    ///Container type for the return parameters of the [`afterAddLiquidityData()`](afterAddLiquidityDataCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct afterAddLiquidityDataReturn {
        pub _0: alloy::sol_types::private::Bytes,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<afterAddLiquidityDataCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: afterAddLiquidityDataCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for afterAddLiquidityDataCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<afterAddLiquidityDataReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: afterAddLiquidityDataReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for afterAddLiquidityDataReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for afterAddLiquidityDataCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = afterAddLiquidityDataReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "afterAddLiquidityData()";
            const SELECTOR: [u8; 4] = [184u8, 81u8, 100u8, 102u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `afterDonate(address,(address,address,uint24,int24,address),uint256,uint256,bytes)` and selector `0xe1b4af69`.
```solidity
function afterDonate(address, PoolKey memory, uint256, uint256, bytes memory hookData) external returns (bytes4);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct afterDonateCall {
        pub _0: alloy::sol_types::private::Address,
        pub _1: <PoolKey as alloy::sol_types::SolType>::RustType,
        pub _2: alloy::sol_types::private::U256,
        pub _3: alloy::sol_types::private::U256,
        pub hookData: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`afterDonate(address,(address,address,uint24,int24,address),uint256,uint256,bytes)`](afterDonateCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct afterDonateReturn {
        pub _0: alloy::sol_types::private::FixedBytes<4>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                PoolKey,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                <PoolKey as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::U256,
                alloy::sol_types::private::U256,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<afterDonateCall> for UnderlyingRustTuple<'_> {
                fn from(value: afterDonateCall) -> Self {
                    (value._0, value._1, value._2, value._3, value.hookData)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for afterDonateCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _0: tuple.0,
                        _1: tuple.1,
                        _2: tuple.2,
                        _3: tuple.3,
                        hookData: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<4>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<afterDonateReturn> for UnderlyingRustTuple<'_> {
                fn from(value: afterDonateReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for afterDonateReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for afterDonateCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                PoolKey,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = afterDonateReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "afterDonate(address,(address,address,uint24,int24,address),uint256,uint256,bytes)";
            const SELECTOR: [u8; 4] = [225u8, 180u8, 175u8, 105u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._0,
                    ),
                    <PoolKey as alloy_sol_types::SolType>::tokenize(&self._1),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._2),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._3),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.hookData,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `afterDonateData()` and selector `0x70b28eda`.
```solidity
function afterDonateData() external view returns (bytes memory);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct afterDonateDataCall {}
    ///Container type for the return parameters of the [`afterDonateData()`](afterDonateDataCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct afterDonateDataReturn {
        pub _0: alloy::sol_types::private::Bytes,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<afterDonateDataCall> for UnderlyingRustTuple<'_> {
                fn from(value: afterDonateDataCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for afterDonateDataCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<afterDonateDataReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: afterDonateDataReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for afterDonateDataReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for afterDonateDataCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = afterDonateDataReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "afterDonateData()";
            const SELECTOR: [u8; 4] = [112u8, 178u8, 142u8, 218u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `afterInitialize(address,(address,address,uint24,int24,address),uint160,int24,bytes)` and selector `0xa910f80f`.
```solidity
function afterInitialize(address, PoolKey memory, uint160, int24, bytes memory hookData) external returns (bytes4);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct afterInitializeCall {
        pub _0: alloy::sol_types::private::Address,
        pub _1: <PoolKey as alloy::sol_types::SolType>::RustType,
        pub _2: <alloy::sol_types::sol_data::Uint<
            160,
        > as alloy::sol_types::SolType>::RustType,
        pub _3: <alloy::sol_types::sol_data::Int<
            24,
        > as alloy::sol_types::SolType>::RustType,
        pub hookData: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`afterInitialize(address,(address,address,uint24,int24,address),uint160,int24,bytes)`](afterInitializeCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct afterInitializeReturn {
        pub _0: alloy::sol_types::private::FixedBytes<4>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                PoolKey,
                alloy::sol_types::sol_data::Uint<160>,
                alloy::sol_types::sol_data::Int<24>,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                <PoolKey as alloy::sol_types::SolType>::RustType,
                <alloy::sol_types::sol_data::Uint<
                    160,
                > as alloy::sol_types::SolType>::RustType,
                <alloy::sol_types::sol_data::Int<
                    24,
                > as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<afterInitializeCall> for UnderlyingRustTuple<'_> {
                fn from(value: afterInitializeCall) -> Self {
                    (value._0, value._1, value._2, value._3, value.hookData)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for afterInitializeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _0: tuple.0,
                        _1: tuple.1,
                        _2: tuple.2,
                        _3: tuple.3,
                        hookData: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<4>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<afterInitializeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: afterInitializeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for afterInitializeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for afterInitializeCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                PoolKey,
                alloy::sol_types::sol_data::Uint<160>,
                alloy::sol_types::sol_data::Int<24>,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = afterInitializeReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "afterInitialize(address,(address,address,uint24,int24,address),uint160,int24,bytes)";
            const SELECTOR: [u8; 4] = [169u8, 16u8, 248u8, 15u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._0,
                    ),
                    <PoolKey as alloy_sol_types::SolType>::tokenize(&self._1),
                    <alloy::sol_types::sol_data::Uint<
                        160,
                    > as alloy_sol_types::SolType>::tokenize(&self._2),
                    <alloy::sol_types::sol_data::Int<
                        24,
                    > as alloy_sol_types::SolType>::tokenize(&self._3),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.hookData,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `afterInitializeData()` and selector `0x0a2d5827`.
```solidity
function afterInitializeData() external view returns (bytes memory);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct afterInitializeDataCall {}
    ///Container type for the return parameters of the [`afterInitializeData()`](afterInitializeDataCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct afterInitializeDataReturn {
        pub _0: alloy::sol_types::private::Bytes,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<afterInitializeDataCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: afterInitializeDataCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for afterInitializeDataCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<afterInitializeDataReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: afterInitializeDataReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for afterInitializeDataReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for afterInitializeDataCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = afterInitializeDataReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "afterInitializeData()";
            const SELECTOR: [u8; 4] = [10u8, 45u8, 88u8, 39u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `afterRemoveLiquidity(address,(address,address,uint24,int24,address),(int24,int24,int256,bytes32),int256,bytes)` and selector `0x8db2b652`.
```solidity
function afterRemoveLiquidity(address, PoolKey memory, ModifyLiquidityParams memory, BalanceDelta, bytes memory hookData) external returns (bytes4, BalanceDelta);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct afterRemoveLiquidityCall {
        pub _0: alloy::sol_types::private::Address,
        pub _1: <PoolKey as alloy::sol_types::SolType>::RustType,
        pub _2: <ModifyLiquidityParams as alloy::sol_types::SolType>::RustType,
        pub _3: <BalanceDelta as alloy::sol_types::SolType>::RustType,
        pub hookData: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`afterRemoveLiquidity(address,(address,address,uint24,int24,address),(int24,int24,int256,bytes32),int256,bytes)`](afterRemoveLiquidityCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct afterRemoveLiquidityReturn {
        pub _0: alloy::sol_types::private::FixedBytes<4>,
        pub _1: <BalanceDelta as alloy::sol_types::SolType>::RustType,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                PoolKey,
                ModifyLiquidityParams,
                BalanceDelta,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                <PoolKey as alloy::sol_types::SolType>::RustType,
                <ModifyLiquidityParams as alloy::sol_types::SolType>::RustType,
                <BalanceDelta as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<afterRemoveLiquidityCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: afterRemoveLiquidityCall) -> Self {
                    (value._0, value._1, value._2, value._3, value.hookData)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for afterRemoveLiquidityCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _0: tuple.0,
                        _1: tuple.1,
                        _2: tuple.2,
                        _3: tuple.3,
                        hookData: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<4>,
                BalanceDelta,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<4>,
                <BalanceDelta as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<afterRemoveLiquidityReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: afterRemoveLiquidityReturn) -> Self {
                    (value._0, value._1)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for afterRemoveLiquidityReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0, _1: tuple.1 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for afterRemoveLiquidityCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                PoolKey,
                ModifyLiquidityParams,
                BalanceDelta,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = afterRemoveLiquidityReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<4>,
                BalanceDelta,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "afterRemoveLiquidity(address,(address,address,uint24,int24,address),(int24,int24,int256,bytes32),int256,bytes)";
            const SELECTOR: [u8; 4] = [141u8, 178u8, 182u8, 82u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._0,
                    ),
                    <PoolKey as alloy_sol_types::SolType>::tokenize(&self._1),
                    <ModifyLiquidityParams as alloy_sol_types::SolType>::tokenize(
                        &self._2,
                    ),
                    <BalanceDelta as alloy_sol_types::SolType>::tokenize(&self._3),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.hookData,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `afterRemoveLiquidityData()` and selector `0x7e472fb2`.
```solidity
function afterRemoveLiquidityData() external view returns (bytes memory);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct afterRemoveLiquidityDataCall {}
    ///Container type for the return parameters of the [`afterRemoveLiquidityData()`](afterRemoveLiquidityDataCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct afterRemoveLiquidityDataReturn {
        pub _0: alloy::sol_types::private::Bytes,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<afterRemoveLiquidityDataCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: afterRemoveLiquidityDataCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for afterRemoveLiquidityDataCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<afterRemoveLiquidityDataReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: afterRemoveLiquidityDataReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for afterRemoveLiquidityDataReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for afterRemoveLiquidityDataCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = afterRemoveLiquidityDataReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "afterRemoveLiquidityData()";
            const SELECTOR: [u8; 4] = [126u8, 71u8, 47u8, 178u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `afterSwap(address,(address,address,uint24,int24,address),(bool,int256,uint160),int256,bytes)` and selector `0xb47b2fb1`.
```solidity
function afterSwap(address, PoolKey memory, SwapParams memory, BalanceDelta, bytes memory hookData) external returns (bytes4, int128);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct afterSwapCall {
        pub _0: alloy::sol_types::private::Address,
        pub _1: <PoolKey as alloy::sol_types::SolType>::RustType,
        pub _2: <SwapParams as alloy::sol_types::SolType>::RustType,
        pub _3: <BalanceDelta as alloy::sol_types::SolType>::RustType,
        pub hookData: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`afterSwap(address,(address,address,uint24,int24,address),(bool,int256,uint160),int256,bytes)`](afterSwapCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct afterSwapReturn {
        pub _0: alloy::sol_types::private::FixedBytes<4>,
        pub _1: i128,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                PoolKey,
                SwapParams,
                BalanceDelta,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                <PoolKey as alloy::sol_types::SolType>::RustType,
                <SwapParams as alloy::sol_types::SolType>::RustType,
                <BalanceDelta as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<afterSwapCall> for UnderlyingRustTuple<'_> {
                fn from(value: afterSwapCall) -> Self {
                    (value._0, value._1, value._2, value._3, value.hookData)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for afterSwapCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _0: tuple.0,
                        _1: tuple.1,
                        _2: tuple.2,
                        _3: tuple.3,
                        hookData: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<4>,
                alloy::sol_types::sol_data::Int<128>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<4>,
                i128,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<afterSwapReturn> for UnderlyingRustTuple<'_> {
                fn from(value: afterSwapReturn) -> Self {
                    (value._0, value._1)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for afterSwapReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0, _1: tuple.1 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for afterSwapCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                PoolKey,
                SwapParams,
                BalanceDelta,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = afterSwapReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<4>,
                alloy::sol_types::sol_data::Int<128>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "afterSwap(address,(address,address,uint24,int24,address),(bool,int256,uint160),int256,bytes)";
            const SELECTOR: [u8; 4] = [180u8, 123u8, 47u8, 177u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._0,
                    ),
                    <PoolKey as alloy_sol_types::SolType>::tokenize(&self._1),
                    <SwapParams as alloy_sol_types::SolType>::tokenize(&self._2),
                    <BalanceDelta as alloy_sol_types::SolType>::tokenize(&self._3),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.hookData,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `afterSwapData()` and selector `0x622e60de`.
```solidity
function afterSwapData() external view returns (bytes memory);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct afterSwapDataCall {}
    ///Container type for the return parameters of the [`afterSwapData()`](afterSwapDataCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct afterSwapDataReturn {
        pub _0: alloy::sol_types::private::Bytes,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<afterSwapDataCall> for UnderlyingRustTuple<'_> {
                fn from(value: afterSwapDataCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for afterSwapDataCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<afterSwapDataReturn> for UnderlyingRustTuple<'_> {
                fn from(value: afterSwapDataReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for afterSwapDataReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for afterSwapDataCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = afterSwapDataReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "afterSwapData()";
            const SELECTOR: [u8; 4] = [98u8, 46u8, 96u8, 222u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `beforeAddLiquidity(address,(address,address,uint24,int24,address),(int24,int24,int256,bytes32),bytes)` and selector `0x259982e5`.
```solidity
function beforeAddLiquidity(address, PoolKey memory, ModifyLiquidityParams memory, bytes memory hookData) external returns (bytes4);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct beforeAddLiquidityCall {
        pub _0: alloy::sol_types::private::Address,
        pub _1: <PoolKey as alloy::sol_types::SolType>::RustType,
        pub _2: <ModifyLiquidityParams as alloy::sol_types::SolType>::RustType,
        pub hookData: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`beforeAddLiquidity(address,(address,address,uint24,int24,address),(int24,int24,int256,bytes32),bytes)`](beforeAddLiquidityCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct beforeAddLiquidityReturn {
        pub _0: alloy::sol_types::private::FixedBytes<4>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                PoolKey,
                ModifyLiquidityParams,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                <PoolKey as alloy::sol_types::SolType>::RustType,
                <ModifyLiquidityParams as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<beforeAddLiquidityCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: beforeAddLiquidityCall) -> Self {
                    (value._0, value._1, value._2, value.hookData)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for beforeAddLiquidityCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _0: tuple.0,
                        _1: tuple.1,
                        _2: tuple.2,
                        hookData: tuple.3,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<4>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<beforeAddLiquidityReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: beforeAddLiquidityReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for beforeAddLiquidityReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for beforeAddLiquidityCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                PoolKey,
                ModifyLiquidityParams,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = beforeAddLiquidityReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "beforeAddLiquidity(address,(address,address,uint24,int24,address),(int24,int24,int256,bytes32),bytes)";
            const SELECTOR: [u8; 4] = [37u8, 153u8, 130u8, 229u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._0,
                    ),
                    <PoolKey as alloy_sol_types::SolType>::tokenize(&self._1),
                    <ModifyLiquidityParams as alloy_sol_types::SolType>::tokenize(
                        &self._2,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.hookData,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `beforeAddLiquidityData()` and selector `0xdb6d76a2`.
```solidity
function beforeAddLiquidityData() external view returns (bytes memory);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct beforeAddLiquidityDataCall {}
    ///Container type for the return parameters of the [`beforeAddLiquidityData()`](beforeAddLiquidityDataCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct beforeAddLiquidityDataReturn {
        pub _0: alloy::sol_types::private::Bytes,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<beforeAddLiquidityDataCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: beforeAddLiquidityDataCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for beforeAddLiquidityDataCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<beforeAddLiquidityDataReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: beforeAddLiquidityDataReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for beforeAddLiquidityDataReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for beforeAddLiquidityDataCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = beforeAddLiquidityDataReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "beforeAddLiquidityData()";
            const SELECTOR: [u8; 4] = [219u8, 109u8, 118u8, 162u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `beforeDonate(address,(address,address,uint24,int24,address),uint256,uint256,bytes)` and selector `0xb6a8b0fa`.
```solidity
function beforeDonate(address, PoolKey memory, uint256, uint256, bytes memory hookData) external returns (bytes4);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct beforeDonateCall {
        pub _0: alloy::sol_types::private::Address,
        pub _1: <PoolKey as alloy::sol_types::SolType>::RustType,
        pub _2: alloy::sol_types::private::U256,
        pub _3: alloy::sol_types::private::U256,
        pub hookData: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`beforeDonate(address,(address,address,uint24,int24,address),uint256,uint256,bytes)`](beforeDonateCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct beforeDonateReturn {
        pub _0: alloy::sol_types::private::FixedBytes<4>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                PoolKey,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                <PoolKey as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::U256,
                alloy::sol_types::private::U256,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<beforeDonateCall> for UnderlyingRustTuple<'_> {
                fn from(value: beforeDonateCall) -> Self {
                    (value._0, value._1, value._2, value._3, value.hookData)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for beforeDonateCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _0: tuple.0,
                        _1: tuple.1,
                        _2: tuple.2,
                        _3: tuple.3,
                        hookData: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<4>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<beforeDonateReturn> for UnderlyingRustTuple<'_> {
                fn from(value: beforeDonateReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for beforeDonateReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for beforeDonateCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                PoolKey,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = beforeDonateReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "beforeDonate(address,(address,address,uint24,int24,address),uint256,uint256,bytes)";
            const SELECTOR: [u8; 4] = [182u8, 168u8, 176u8, 250u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._0,
                    ),
                    <PoolKey as alloy_sol_types::SolType>::tokenize(&self._1),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._2),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._3),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.hookData,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `beforeDonateData()` and selector `0xaf57c184`.
```solidity
function beforeDonateData() external view returns (bytes memory);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct beforeDonateDataCall {}
    ///Container type for the return parameters of the [`beforeDonateData()`](beforeDonateDataCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct beforeDonateDataReturn {
        pub _0: alloy::sol_types::private::Bytes,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<beforeDonateDataCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: beforeDonateDataCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for beforeDonateDataCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<beforeDonateDataReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: beforeDonateDataReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for beforeDonateDataReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for beforeDonateDataCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = beforeDonateDataReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "beforeDonateData()";
            const SELECTOR: [u8; 4] = [175u8, 87u8, 193u8, 132u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `beforeInitialize(address,(address,address,uint24,int24,address),uint160,bytes)` and selector `0x3440d820`.
```solidity
function beforeInitialize(address, PoolKey memory, uint160, bytes memory hookData) external returns (bytes4);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct beforeInitializeCall {
        pub _0: alloy::sol_types::private::Address,
        pub _1: <PoolKey as alloy::sol_types::SolType>::RustType,
        pub _2: <alloy::sol_types::sol_data::Uint<
            160,
        > as alloy::sol_types::SolType>::RustType,
        pub hookData: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`beforeInitialize(address,(address,address,uint24,int24,address),uint160,bytes)`](beforeInitializeCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct beforeInitializeReturn {
        pub _0: alloy::sol_types::private::FixedBytes<4>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                PoolKey,
                alloy::sol_types::sol_data::Uint<160>,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                <PoolKey as alloy::sol_types::SolType>::RustType,
                <alloy::sol_types::sol_data::Uint<
                    160,
                > as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<beforeInitializeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: beforeInitializeCall) -> Self {
                    (value._0, value._1, value._2, value.hookData)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for beforeInitializeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _0: tuple.0,
                        _1: tuple.1,
                        _2: tuple.2,
                        hookData: tuple.3,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<4>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<beforeInitializeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: beforeInitializeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for beforeInitializeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for beforeInitializeCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                PoolKey,
                alloy::sol_types::sol_data::Uint<160>,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = beforeInitializeReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "beforeInitialize(address,(address,address,uint24,int24,address),uint160,bytes)";
            const SELECTOR: [u8; 4] = [52u8, 64u8, 216u8, 32u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._0,
                    ),
                    <PoolKey as alloy_sol_types::SolType>::tokenize(&self._1),
                    <alloy::sol_types::sol_data::Uint<
                        160,
                    > as alloy_sol_types::SolType>::tokenize(&self._2),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.hookData,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `beforeInitializeData()` and selector `0x50cd07eb`.
```solidity
function beforeInitializeData() external view returns (bytes memory);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct beforeInitializeDataCall {}
    ///Container type for the return parameters of the [`beforeInitializeData()`](beforeInitializeDataCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct beforeInitializeDataReturn {
        pub _0: alloy::sol_types::private::Bytes,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<beforeInitializeDataCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: beforeInitializeDataCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for beforeInitializeDataCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<beforeInitializeDataReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: beforeInitializeDataReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for beforeInitializeDataReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for beforeInitializeDataCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = beforeInitializeDataReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "beforeInitializeData()";
            const SELECTOR: [u8; 4] = [80u8, 205u8, 7u8, 235u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `beforeRemoveLiquidity(address,(address,address,uint24,int24,address),(int24,int24,int256,bytes32),bytes)` and selector `0x21d0ee70`.
```solidity
function beforeRemoveLiquidity(address, PoolKey memory, ModifyLiquidityParams memory, bytes memory hookData) external returns (bytes4);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct beforeRemoveLiquidityCall {
        pub _0: alloy::sol_types::private::Address,
        pub _1: <PoolKey as alloy::sol_types::SolType>::RustType,
        pub _2: <ModifyLiquidityParams as alloy::sol_types::SolType>::RustType,
        pub hookData: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`beforeRemoveLiquidity(address,(address,address,uint24,int24,address),(int24,int24,int256,bytes32),bytes)`](beforeRemoveLiquidityCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct beforeRemoveLiquidityReturn {
        pub _0: alloy::sol_types::private::FixedBytes<4>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                PoolKey,
                ModifyLiquidityParams,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                <PoolKey as alloy::sol_types::SolType>::RustType,
                <ModifyLiquidityParams as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<beforeRemoveLiquidityCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: beforeRemoveLiquidityCall) -> Self {
                    (value._0, value._1, value._2, value.hookData)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for beforeRemoveLiquidityCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _0: tuple.0,
                        _1: tuple.1,
                        _2: tuple.2,
                        hookData: tuple.3,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<4>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<beforeRemoveLiquidityReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: beforeRemoveLiquidityReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for beforeRemoveLiquidityReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for beforeRemoveLiquidityCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                PoolKey,
                ModifyLiquidityParams,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = beforeRemoveLiquidityReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "beforeRemoveLiquidity(address,(address,address,uint24,int24,address),(int24,int24,int256,bytes32),bytes)";
            const SELECTOR: [u8; 4] = [33u8, 208u8, 238u8, 112u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._0,
                    ),
                    <PoolKey as alloy_sol_types::SolType>::tokenize(&self._1),
                    <ModifyLiquidityParams as alloy_sol_types::SolType>::tokenize(
                        &self._2,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.hookData,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `beforeRemoveLiquidityData()` and selector `0x4d081c7e`.
```solidity
function beforeRemoveLiquidityData() external view returns (bytes memory);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct beforeRemoveLiquidityDataCall {}
    ///Container type for the return parameters of the [`beforeRemoveLiquidityData()`](beforeRemoveLiquidityDataCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct beforeRemoveLiquidityDataReturn {
        pub _0: alloy::sol_types::private::Bytes,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<beforeRemoveLiquidityDataCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: beforeRemoveLiquidityDataCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for beforeRemoveLiquidityDataCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<beforeRemoveLiquidityDataReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: beforeRemoveLiquidityDataReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for beforeRemoveLiquidityDataReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for beforeRemoveLiquidityDataCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = beforeRemoveLiquidityDataReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "beforeRemoveLiquidityData()";
            const SELECTOR: [u8; 4] = [77u8, 8u8, 28u8, 126u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `beforeSwap(address,(address,address,uint24,int24,address),(bool,int256,uint160),bytes)` and selector `0x575e24b4`.
```solidity
function beforeSwap(address, PoolKey memory, SwapParams memory, bytes memory hookData) external returns (bytes4, BeforeSwapDelta, uint24);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct beforeSwapCall {
        pub _0: alloy::sol_types::private::Address,
        pub _1: <PoolKey as alloy::sol_types::SolType>::RustType,
        pub _2: <SwapParams as alloy::sol_types::SolType>::RustType,
        pub hookData: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`beforeSwap(address,(address,address,uint24,int24,address),(bool,int256,uint160),bytes)`](beforeSwapCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct beforeSwapReturn {
        pub _0: alloy::sol_types::private::FixedBytes<4>,
        pub _1: <BeforeSwapDelta as alloy::sol_types::SolType>::RustType,
        pub _2: <alloy::sol_types::sol_data::Uint<
            24,
        > as alloy::sol_types::SolType>::RustType,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                PoolKey,
                SwapParams,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                <PoolKey as alloy::sol_types::SolType>::RustType,
                <SwapParams as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<beforeSwapCall> for UnderlyingRustTuple<'_> {
                fn from(value: beforeSwapCall) -> Self {
                    (value._0, value._1, value._2, value.hookData)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for beforeSwapCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _0: tuple.0,
                        _1: tuple.1,
                        _2: tuple.2,
                        hookData: tuple.3,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<4>,
                BeforeSwapDelta,
                alloy::sol_types::sol_data::Uint<24>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<4>,
                <BeforeSwapDelta as alloy::sol_types::SolType>::RustType,
                <alloy::sol_types::sol_data::Uint<
                    24,
                > as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<beforeSwapReturn> for UnderlyingRustTuple<'_> {
                fn from(value: beforeSwapReturn) -> Self {
                    (value._0, value._1, value._2)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for beforeSwapReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _0: tuple.0,
                        _1: tuple.1,
                        _2: tuple.2,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for beforeSwapCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                PoolKey,
                SwapParams,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = beforeSwapReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<4>,
                BeforeSwapDelta,
                alloy::sol_types::sol_data::Uint<24>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "beforeSwap(address,(address,address,uint24,int24,address),(bool,int256,uint160),bytes)";
            const SELECTOR: [u8; 4] = [87u8, 94u8, 36u8, 180u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._0,
                    ),
                    <PoolKey as alloy_sol_types::SolType>::tokenize(&self._1),
                    <SwapParams as alloy_sol_types::SolType>::tokenize(&self._2),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.hookData,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `beforeSwapData()` and selector `0x542e9369`.
```solidity
function beforeSwapData() external view returns (bytes memory);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct beforeSwapDataCall {}
    ///Container type for the return parameters of the [`beforeSwapData()`](beforeSwapDataCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct beforeSwapDataReturn {
        pub _0: alloy::sol_types::private::Bytes,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<beforeSwapDataCall> for UnderlyingRustTuple<'_> {
                fn from(value: beforeSwapDataCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for beforeSwapDataCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<beforeSwapDataReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: beforeSwapDataReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for beforeSwapDataReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for beforeSwapDataCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = beforeSwapDataReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "beforeSwapData()";
            const SELECTOR: [u8; 4] = [84u8, 46u8, 147u8, 105u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `lpFees(bytes32)` and selector `0x17bd6123`.
```solidity
function lpFees(PoolId) external view returns (uint16);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct lpFeesCall {
        pub _0: <PoolId as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`lpFees(bytes32)`](lpFeesCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct lpFeesReturn {
        pub _0: u16,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (PoolId,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <PoolId as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<lpFeesCall> for UnderlyingRustTuple<'_> {
                fn from(value: lpFeesCall) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for lpFeesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<16>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u16,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<lpFeesReturn> for UnderlyingRustTuple<'_> {
                fn from(value: lpFeesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for lpFeesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for lpFeesCall {
            type Parameters<'a> = (PoolId,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = lpFeesReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<16>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "lpFees(bytes32)";
            const SELECTOR: [u8; 4] = [23u8, 189u8, 97u8, 35u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<PoolId as alloy_sol_types::SolType>::tokenize(&self._0),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `returnValues(bytes4)` and selector `0xa2bc94ad`.
```solidity
function returnValues(bytes4) external view returns (bytes4);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct returnValuesCall {
        pub _0: alloy::sol_types::private::FixedBytes<4>,
    }
    ///Container type for the return parameters of the [`returnValues(bytes4)`](returnValuesCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct returnValuesReturn {
        pub _0: alloy::sol_types::private::FixedBytes<4>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<4>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<returnValuesCall> for UnderlyingRustTuple<'_> {
                fn from(value: returnValuesCall) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for returnValuesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<4>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<returnValuesReturn> for UnderlyingRustTuple<'_> {
                fn from(value: returnValuesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for returnValuesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for returnValuesCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = returnValuesReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "returnValues(bytes4)";
            const SELECTOR: [u8; 4] = [162u8, 188u8, 148u8, 173u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        4,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setReturnValue(bytes4,bytes4)` and selector `0x5941b5bb`.
```solidity
function setReturnValue(bytes4 key, bytes4 value) external;
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct setReturnValueCall {
        pub key: alloy::sol_types::private::FixedBytes<4>,
        pub value: alloy::sol_types::private::FixedBytes<4>,
    }
    ///Container type for the return parameters of the [`setReturnValue(bytes4,bytes4)`](setReturnValueCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct setReturnValueReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<4>,
                alloy::sol_types::sol_data::FixedBytes<4>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<4>,
                alloy::sol_types::private::FixedBytes<4>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setReturnValueCall> for UnderlyingRustTuple<'_> {
                fn from(value: setReturnValueCall) -> Self {
                    (value.key, value.value)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setReturnValueCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        key: tuple.0,
                        value: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setReturnValueReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setReturnValueReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setReturnValueReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setReturnValueCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<4>,
                alloy::sol_types::sol_data::FixedBytes<4>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setReturnValueReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setReturnValue(bytes4,bytes4)";
            const SELECTOR: [u8; 4] = [89u8, 65u8, 181u8, 187u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        4,
                    > as alloy_sol_types::SolType>::tokenize(&self.key),
                    <alloy::sol_types::sol_data::FixedBytes<
                        4,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setlpFee((address,address,uint24,int24,address),uint16)` and selector `0x7a3385f5`.
```solidity
function setlpFee(PoolKey memory key, uint16 value) external;
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct setlpFeeCall {
        pub key: <PoolKey as alloy::sol_types::SolType>::RustType,
        pub value: u16,
    }
    ///Container type for the return parameters of the [`setlpFee((address,address,uint24,int24,address),uint16)`](setlpFeeCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct setlpFeeReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                PoolKey,
                alloy::sol_types::sol_data::Uint<16>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <PoolKey as alloy::sol_types::SolType>::RustType,
                u16,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setlpFeeCall> for UnderlyingRustTuple<'_> {
                fn from(value: setlpFeeCall) -> Self {
                    (value.key, value.value)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setlpFeeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        key: tuple.0,
                        value: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setlpFeeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: setlpFeeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setlpFeeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setlpFeeCall {
            type Parameters<'a> = (PoolKey, alloy::sol_types::sol_data::Uint<16>);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setlpFeeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setlpFee((address,address,uint24,int24,address),uint16)";
            const SELECTOR: [u8; 4] = [122u8, 51u8, 133u8, 245u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <PoolKey as alloy_sol_types::SolType>::tokenize(&self.key),
                    <alloy::sol_types::sol_data::Uint<
                        16,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`MockHooks`](self) function calls.
    pub enum MockHooksCalls {
        afterAddLiquidity(afterAddLiquidityCall),
        afterAddLiquidityData(afterAddLiquidityDataCall),
        afterDonate(afterDonateCall),
        afterDonateData(afterDonateDataCall),
        afterInitialize(afterInitializeCall),
        afterInitializeData(afterInitializeDataCall),
        afterRemoveLiquidity(afterRemoveLiquidityCall),
        afterRemoveLiquidityData(afterRemoveLiquidityDataCall),
        afterSwap(afterSwapCall),
        afterSwapData(afterSwapDataCall),
        beforeAddLiquidity(beforeAddLiquidityCall),
        beforeAddLiquidityData(beforeAddLiquidityDataCall),
        beforeDonate(beforeDonateCall),
        beforeDonateData(beforeDonateDataCall),
        beforeInitialize(beforeInitializeCall),
        beforeInitializeData(beforeInitializeDataCall),
        beforeRemoveLiquidity(beforeRemoveLiquidityCall),
        beforeRemoveLiquidityData(beforeRemoveLiquidityDataCall),
        beforeSwap(beforeSwapCall),
        beforeSwapData(beforeSwapDataCall),
        lpFees(lpFeesCall),
        returnValues(returnValuesCall),
        setReturnValue(setReturnValueCall),
        setlpFee(setlpFeeCall),
    }
    #[automatically_derived]
    impl MockHooksCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [10u8, 45u8, 88u8, 39u8],
            [23u8, 189u8, 97u8, 35u8],
            [33u8, 208u8, 238u8, 112u8],
            [37u8, 153u8, 130u8, 229u8],
            [52u8, 64u8, 216u8, 32u8],
            [77u8, 8u8, 28u8, 126u8],
            [80u8, 205u8, 7u8, 235u8],
            [84u8, 46u8, 147u8, 105u8],
            [87u8, 94u8, 36u8, 180u8],
            [89u8, 65u8, 181u8, 187u8],
            [90u8, 42u8, 129u8, 0u8],
            [98u8, 46u8, 96u8, 222u8],
            [112u8, 178u8, 142u8, 218u8],
            [122u8, 51u8, 133u8, 245u8],
            [126u8, 71u8, 47u8, 178u8],
            [141u8, 178u8, 182u8, 82u8],
            [162u8, 188u8, 148u8, 173u8],
            [169u8, 16u8, 248u8, 15u8],
            [175u8, 87u8, 193u8, 132u8],
            [180u8, 123u8, 47u8, 177u8],
            [182u8, 168u8, 176u8, 250u8],
            [184u8, 81u8, 100u8, 102u8],
            [219u8, 109u8, 118u8, 162u8],
            [225u8, 180u8, 175u8, 105u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for MockHooksCalls {
        const NAME: &'static str = "MockHooksCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 24usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::afterAddLiquidity(_) => {
                    <afterAddLiquidityCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::afterAddLiquidityData(_) => {
                    <afterAddLiquidityDataCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::afterDonate(_) => {
                    <afterDonateCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::afterDonateData(_) => {
                    <afterDonateDataCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::afterInitialize(_) => {
                    <afterInitializeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::afterInitializeData(_) => {
                    <afterInitializeDataCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::afterRemoveLiquidity(_) => {
                    <afterRemoveLiquidityCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::afterRemoveLiquidityData(_) => {
                    <afterRemoveLiquidityDataCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::afterSwap(_) => {
                    <afterSwapCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::afterSwapData(_) => {
                    <afterSwapDataCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::beforeAddLiquidity(_) => {
                    <beforeAddLiquidityCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::beforeAddLiquidityData(_) => {
                    <beforeAddLiquidityDataCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::beforeDonate(_) => {
                    <beforeDonateCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::beforeDonateData(_) => {
                    <beforeDonateDataCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::beforeInitialize(_) => {
                    <beforeInitializeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::beforeInitializeData(_) => {
                    <beforeInitializeDataCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::beforeRemoveLiquidity(_) => {
                    <beforeRemoveLiquidityCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::beforeRemoveLiquidityData(_) => {
                    <beforeRemoveLiquidityDataCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::beforeSwap(_) => {
                    <beforeSwapCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::beforeSwapData(_) => {
                    <beforeSwapDataCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::lpFees(_) => <lpFeesCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::returnValues(_) => {
                    <returnValuesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setReturnValue(_) => {
                    <setReturnValueCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setlpFee(_) => <setlpFeeCall as alloy_sol_types::SolCall>::SELECTOR,
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(unsafe_code, non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<MockHooksCalls>] = &[
                {
                    fn afterInitializeData(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockHooksCalls> {
                        <afterInitializeDataCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockHooksCalls::afterInitializeData)
                    }
                    afterInitializeData
                },
                {
                    fn lpFees(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockHooksCalls> {
                        <lpFeesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockHooksCalls::lpFees)
                    }
                    lpFees
                },
                {
                    fn beforeRemoveLiquidity(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockHooksCalls> {
                        <beforeRemoveLiquidityCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockHooksCalls::beforeRemoveLiquidity)
                    }
                    beforeRemoveLiquidity
                },
                {
                    fn beforeAddLiquidity(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockHooksCalls> {
                        <beforeAddLiquidityCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockHooksCalls::beforeAddLiquidity)
                    }
                    beforeAddLiquidity
                },
                {
                    fn beforeInitialize(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockHooksCalls> {
                        <beforeInitializeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockHooksCalls::beforeInitialize)
                    }
                    beforeInitialize
                },
                {
                    fn beforeRemoveLiquidityData(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockHooksCalls> {
                        <beforeRemoveLiquidityDataCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockHooksCalls::beforeRemoveLiquidityData)
                    }
                    beforeRemoveLiquidityData
                },
                {
                    fn beforeInitializeData(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockHooksCalls> {
                        <beforeInitializeDataCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockHooksCalls::beforeInitializeData)
                    }
                    beforeInitializeData
                },
                {
                    fn beforeSwapData(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockHooksCalls> {
                        <beforeSwapDataCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockHooksCalls::beforeSwapData)
                    }
                    beforeSwapData
                },
                {
                    fn beforeSwap(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockHooksCalls> {
                        <beforeSwapCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockHooksCalls::beforeSwap)
                    }
                    beforeSwap
                },
                {
                    fn setReturnValue(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockHooksCalls> {
                        <setReturnValueCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockHooksCalls::setReturnValue)
                    }
                    setReturnValue
                },
                {
                    fn afterAddLiquidity(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockHooksCalls> {
                        <afterAddLiquidityCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockHooksCalls::afterAddLiquidity)
                    }
                    afterAddLiquidity
                },
                {
                    fn afterSwapData(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockHooksCalls> {
                        <afterSwapDataCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockHooksCalls::afterSwapData)
                    }
                    afterSwapData
                },
                {
                    fn afterDonateData(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockHooksCalls> {
                        <afterDonateDataCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockHooksCalls::afterDonateData)
                    }
                    afterDonateData
                },
                {
                    fn setlpFee(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockHooksCalls> {
                        <setlpFeeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockHooksCalls::setlpFee)
                    }
                    setlpFee
                },
                {
                    fn afterRemoveLiquidityData(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockHooksCalls> {
                        <afterRemoveLiquidityDataCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockHooksCalls::afterRemoveLiquidityData)
                    }
                    afterRemoveLiquidityData
                },
                {
                    fn afterRemoveLiquidity(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockHooksCalls> {
                        <afterRemoveLiquidityCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockHooksCalls::afterRemoveLiquidity)
                    }
                    afterRemoveLiquidity
                },
                {
                    fn returnValues(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockHooksCalls> {
                        <returnValuesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockHooksCalls::returnValues)
                    }
                    returnValues
                },
                {
                    fn afterInitialize(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockHooksCalls> {
                        <afterInitializeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockHooksCalls::afterInitialize)
                    }
                    afterInitialize
                },
                {
                    fn beforeDonateData(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockHooksCalls> {
                        <beforeDonateDataCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockHooksCalls::beforeDonateData)
                    }
                    beforeDonateData
                },
                {
                    fn afterSwap(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockHooksCalls> {
                        <afterSwapCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockHooksCalls::afterSwap)
                    }
                    afterSwap
                },
                {
                    fn beforeDonate(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockHooksCalls> {
                        <beforeDonateCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockHooksCalls::beforeDonate)
                    }
                    beforeDonate
                },
                {
                    fn afterAddLiquidityData(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockHooksCalls> {
                        <afterAddLiquidityDataCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockHooksCalls::afterAddLiquidityData)
                    }
                    afterAddLiquidityData
                },
                {
                    fn beforeAddLiquidityData(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockHooksCalls> {
                        <beforeAddLiquidityDataCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockHooksCalls::beforeAddLiquidityData)
                    }
                    beforeAddLiquidityData
                },
                {
                    fn afterDonate(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockHooksCalls> {
                        <afterDonateCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockHooksCalls::afterDonate)
                    }
                    afterDonate
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            (unsafe { DECODE_SHIMS.get_unchecked(idx) })(data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::afterAddLiquidity(inner) => {
                    <afterAddLiquidityCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::afterAddLiquidityData(inner) => {
                    <afterAddLiquidityDataCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::afterDonate(inner) => {
                    <afterDonateCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::afterDonateData(inner) => {
                    <afterDonateDataCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::afterInitialize(inner) => {
                    <afterInitializeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::afterInitializeData(inner) => {
                    <afterInitializeDataCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::afterRemoveLiquidity(inner) => {
                    <afterRemoveLiquidityCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::afterRemoveLiquidityData(inner) => {
                    <afterRemoveLiquidityDataCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::afterSwap(inner) => {
                    <afterSwapCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::afterSwapData(inner) => {
                    <afterSwapDataCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::beforeAddLiquidity(inner) => {
                    <beforeAddLiquidityCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::beforeAddLiquidityData(inner) => {
                    <beforeAddLiquidityDataCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::beforeDonate(inner) => {
                    <beforeDonateCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::beforeDonateData(inner) => {
                    <beforeDonateDataCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::beforeInitialize(inner) => {
                    <beforeInitializeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::beforeInitializeData(inner) => {
                    <beforeInitializeDataCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::beforeRemoveLiquidity(inner) => {
                    <beforeRemoveLiquidityCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::beforeRemoveLiquidityData(inner) => {
                    <beforeRemoveLiquidityDataCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::beforeSwap(inner) => {
                    <beforeSwapCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::beforeSwapData(inner) => {
                    <beforeSwapDataCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::lpFees(inner) => {
                    <lpFeesCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::returnValues(inner) => {
                    <returnValuesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setReturnValue(inner) => {
                    <setReturnValueCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setlpFee(inner) => {
                    <setlpFeeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::afterAddLiquidity(inner) => {
                    <afterAddLiquidityCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::afterAddLiquidityData(inner) => {
                    <afterAddLiquidityDataCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::afterDonate(inner) => {
                    <afterDonateCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::afterDonateData(inner) => {
                    <afterDonateDataCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::afterInitialize(inner) => {
                    <afterInitializeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::afterInitializeData(inner) => {
                    <afterInitializeDataCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::afterRemoveLiquidity(inner) => {
                    <afterRemoveLiquidityCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::afterRemoveLiquidityData(inner) => {
                    <afterRemoveLiquidityDataCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::afterSwap(inner) => {
                    <afterSwapCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::afterSwapData(inner) => {
                    <afterSwapDataCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::beforeAddLiquidity(inner) => {
                    <beforeAddLiquidityCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::beforeAddLiquidityData(inner) => {
                    <beforeAddLiquidityDataCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::beforeDonate(inner) => {
                    <beforeDonateCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::beforeDonateData(inner) => {
                    <beforeDonateDataCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::beforeInitialize(inner) => {
                    <beforeInitializeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::beforeInitializeData(inner) => {
                    <beforeInitializeDataCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::beforeRemoveLiquidity(inner) => {
                    <beforeRemoveLiquidityCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::beforeRemoveLiquidityData(inner) => {
                    <beforeRemoveLiquidityDataCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::beforeSwap(inner) => {
                    <beforeSwapCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::beforeSwapData(inner) => {
                    <beforeSwapDataCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::lpFees(inner) => {
                    <lpFeesCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::returnValues(inner) => {
                    <returnValuesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setReturnValue(inner) => {
                    <setReturnValueCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setlpFee(inner) => {
                    <setlpFeeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`MockHooks`](self) contract instance.

See the [wrapper's documentation](`MockHooksInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> MockHooksInstance<T, P, N> {
        MockHooksInstance::<T, P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<MockHooksInstance<T, P, N>>,
    > {
        MockHooksInstance::<T, P, N>::deploy(provider)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
        MockHooksInstance::<T, P, N>::deploy_builder(provider)
    }
    /**A [`MockHooks`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`MockHooks`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct MockHooksInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for MockHooksInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("MockHooksInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > MockHooksInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`MockHooks`](self) contract instance.

See the [wrapper's documentation](`MockHooksInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
        ) -> alloy_contract::Result<MockHooksInstance<T, P, N>> {
            let call_builder = Self::deploy_builder(provider);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                ::core::clone::Clone::clone(&BYTECODE),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> MockHooksInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> MockHooksInstance<T, P, N> {
            MockHooksInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > MockHooksInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`afterAddLiquidity`] function.
        pub fn afterAddLiquidity(
            &self,
            _0: alloy::sol_types::private::Address,
            _1: <PoolKey as alloy::sol_types::SolType>::RustType,
            _2: <ModifyLiquidityParams as alloy::sol_types::SolType>::RustType,
            _3: <BalanceDelta as alloy::sol_types::SolType>::RustType,
            hookData: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, afterAddLiquidityCall, N> {
            self.call_builder(
                &afterAddLiquidityCall {
                    _0,
                    _1,
                    _2,
                    _3,
                    hookData,
                },
            )
        }
        ///Creates a new call builder for the [`afterAddLiquidityData`] function.
        pub fn afterAddLiquidityData(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, afterAddLiquidityDataCall, N> {
            self.call_builder(&afterAddLiquidityDataCall {})
        }
        ///Creates a new call builder for the [`afterDonate`] function.
        pub fn afterDonate(
            &self,
            _0: alloy::sol_types::private::Address,
            _1: <PoolKey as alloy::sol_types::SolType>::RustType,
            _2: alloy::sol_types::private::U256,
            _3: alloy::sol_types::private::U256,
            hookData: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, afterDonateCall, N> {
            self.call_builder(
                &afterDonateCall {
                    _0,
                    _1,
                    _2,
                    _3,
                    hookData,
                },
            )
        }
        ///Creates a new call builder for the [`afterDonateData`] function.
        pub fn afterDonateData(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, afterDonateDataCall, N> {
            self.call_builder(&afterDonateDataCall {})
        }
        ///Creates a new call builder for the [`afterInitialize`] function.
        pub fn afterInitialize(
            &self,
            _0: alloy::sol_types::private::Address,
            _1: <PoolKey as alloy::sol_types::SolType>::RustType,
            _2: <alloy::sol_types::sol_data::Uint<
                160,
            > as alloy::sol_types::SolType>::RustType,
            _3: <alloy::sol_types::sol_data::Int<
                24,
            > as alloy::sol_types::SolType>::RustType,
            hookData: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, afterInitializeCall, N> {
            self.call_builder(
                &afterInitializeCall {
                    _0,
                    _1,
                    _2,
                    _3,
                    hookData,
                },
            )
        }
        ///Creates a new call builder for the [`afterInitializeData`] function.
        pub fn afterInitializeData(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, afterInitializeDataCall, N> {
            self.call_builder(&afterInitializeDataCall {})
        }
        ///Creates a new call builder for the [`afterRemoveLiquidity`] function.
        pub fn afterRemoveLiquidity(
            &self,
            _0: alloy::sol_types::private::Address,
            _1: <PoolKey as alloy::sol_types::SolType>::RustType,
            _2: <ModifyLiquidityParams as alloy::sol_types::SolType>::RustType,
            _3: <BalanceDelta as alloy::sol_types::SolType>::RustType,
            hookData: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, afterRemoveLiquidityCall, N> {
            self.call_builder(
                &afterRemoveLiquidityCall {
                    _0,
                    _1,
                    _2,
                    _3,
                    hookData,
                },
            )
        }
        ///Creates a new call builder for the [`afterRemoveLiquidityData`] function.
        pub fn afterRemoveLiquidityData(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, afterRemoveLiquidityDataCall, N> {
            self.call_builder(&afterRemoveLiquidityDataCall {})
        }
        ///Creates a new call builder for the [`afterSwap`] function.
        pub fn afterSwap(
            &self,
            _0: alloy::sol_types::private::Address,
            _1: <PoolKey as alloy::sol_types::SolType>::RustType,
            _2: <SwapParams as alloy::sol_types::SolType>::RustType,
            _3: <BalanceDelta as alloy::sol_types::SolType>::RustType,
            hookData: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, afterSwapCall, N> {
            self.call_builder(
                &afterSwapCall {
                    _0,
                    _1,
                    _2,
                    _3,
                    hookData,
                },
            )
        }
        ///Creates a new call builder for the [`afterSwapData`] function.
        pub fn afterSwapData(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, afterSwapDataCall, N> {
            self.call_builder(&afterSwapDataCall {})
        }
        ///Creates a new call builder for the [`beforeAddLiquidity`] function.
        pub fn beforeAddLiquidity(
            &self,
            _0: alloy::sol_types::private::Address,
            _1: <PoolKey as alloy::sol_types::SolType>::RustType,
            _2: <ModifyLiquidityParams as alloy::sol_types::SolType>::RustType,
            hookData: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, beforeAddLiquidityCall, N> {
            self.call_builder(
                &beforeAddLiquidityCall {
                    _0,
                    _1,
                    _2,
                    hookData,
                },
            )
        }
        ///Creates a new call builder for the [`beforeAddLiquidityData`] function.
        pub fn beforeAddLiquidityData(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, beforeAddLiquidityDataCall, N> {
            self.call_builder(&beforeAddLiquidityDataCall {})
        }
        ///Creates a new call builder for the [`beforeDonate`] function.
        pub fn beforeDonate(
            &self,
            _0: alloy::sol_types::private::Address,
            _1: <PoolKey as alloy::sol_types::SolType>::RustType,
            _2: alloy::sol_types::private::U256,
            _3: alloy::sol_types::private::U256,
            hookData: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, beforeDonateCall, N> {
            self.call_builder(
                &beforeDonateCall {
                    _0,
                    _1,
                    _2,
                    _3,
                    hookData,
                },
            )
        }
        ///Creates a new call builder for the [`beforeDonateData`] function.
        pub fn beforeDonateData(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, beforeDonateDataCall, N> {
            self.call_builder(&beforeDonateDataCall {})
        }
        ///Creates a new call builder for the [`beforeInitialize`] function.
        pub fn beforeInitialize(
            &self,
            _0: alloy::sol_types::private::Address,
            _1: <PoolKey as alloy::sol_types::SolType>::RustType,
            _2: <alloy::sol_types::sol_data::Uint<
                160,
            > as alloy::sol_types::SolType>::RustType,
            hookData: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, beforeInitializeCall, N> {
            self.call_builder(
                &beforeInitializeCall {
                    _0,
                    _1,
                    _2,
                    hookData,
                },
            )
        }
        ///Creates a new call builder for the [`beforeInitializeData`] function.
        pub fn beforeInitializeData(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, beforeInitializeDataCall, N> {
            self.call_builder(&beforeInitializeDataCall {})
        }
        ///Creates a new call builder for the [`beforeRemoveLiquidity`] function.
        pub fn beforeRemoveLiquidity(
            &self,
            _0: alloy::sol_types::private::Address,
            _1: <PoolKey as alloy::sol_types::SolType>::RustType,
            _2: <ModifyLiquidityParams as alloy::sol_types::SolType>::RustType,
            hookData: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, beforeRemoveLiquidityCall, N> {
            self.call_builder(
                &beforeRemoveLiquidityCall {
                    _0,
                    _1,
                    _2,
                    hookData,
                },
            )
        }
        ///Creates a new call builder for the [`beforeRemoveLiquidityData`] function.
        pub fn beforeRemoveLiquidityData(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, beforeRemoveLiquidityDataCall, N> {
            self.call_builder(&beforeRemoveLiquidityDataCall {})
        }
        ///Creates a new call builder for the [`beforeSwap`] function.
        pub fn beforeSwap(
            &self,
            _0: alloy::sol_types::private::Address,
            _1: <PoolKey as alloy::sol_types::SolType>::RustType,
            _2: <SwapParams as alloy::sol_types::SolType>::RustType,
            hookData: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, beforeSwapCall, N> {
            self.call_builder(
                &beforeSwapCall {
                    _0,
                    _1,
                    _2,
                    hookData,
                },
            )
        }
        ///Creates a new call builder for the [`beforeSwapData`] function.
        pub fn beforeSwapData(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, beforeSwapDataCall, N> {
            self.call_builder(&beforeSwapDataCall {})
        }
        ///Creates a new call builder for the [`lpFees`] function.
        pub fn lpFees(
            &self,
            _0: <PoolId as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, lpFeesCall, N> {
            self.call_builder(&lpFeesCall { _0 })
        }
        ///Creates a new call builder for the [`returnValues`] function.
        pub fn returnValues(
            &self,
            _0: alloy::sol_types::private::FixedBytes<4>,
        ) -> alloy_contract::SolCallBuilder<T, &P, returnValuesCall, N> {
            self.call_builder(&returnValuesCall { _0 })
        }
        ///Creates a new call builder for the [`setReturnValue`] function.
        pub fn setReturnValue(
            &self,
            key: alloy::sol_types::private::FixedBytes<4>,
            value: alloy::sol_types::private::FixedBytes<4>,
        ) -> alloy_contract::SolCallBuilder<T, &P, setReturnValueCall, N> {
            self.call_builder(&setReturnValueCall { key, value })
        }
        ///Creates a new call builder for the [`setlpFee`] function.
        pub fn setlpFee(
            &self,
            key: <PoolKey as alloy::sol_types::SolType>::RustType,
            value: u16,
        ) -> alloy_contract::SolCallBuilder<T, &P, setlpFeeCall, N> {
            self.call_builder(&setlpFeeCall { key, value })
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > MockHooksInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
    }
}
