/**

Generated by the following Solidity interface...
```solidity
interface PoolManager {
    type BalanceDelta is int256;
    type Currency is address;
    type PoolId is bytes32;
    struct ModifyLiquidityParams {
        int24 tickLower;
        int24 tickUpper;
        int256 liquidityDelta;
        bytes32 salt;
    }
    struct PoolKey {
        Currency currency0;
        Currency currency1;
        uint24 fee;
        int24 tickSpacing;
        address hooks;
    }
    struct SwapParams {
        bool zeroForOne;
        int256 amountSpecified;
        uint160 sqrtPriceLimitX96;
    }

    error AlreadyUnlocked();
    error CurrenciesOutOfOrderOrEqual();
    error CurrencyNotSettled();
    error DelegateCallNotAllowed();
    error InvalidCaller();
    error InvalidProtocolFee();
    error ManagerLocked();
    error NonZeroNativeValue();
    error PoolNotInitialized();
    error ProtocolFeeCannotBeFetched();
    error SwapAmountCannotBeZero();
    error TickSpacingTooLarge();
    error TickSpacingTooSmall();
    error UnauthorizedDynamicLPFeeUpdate();

    event Approval(address indexed owner, address indexed spender, uint256 indexed id, uint256 amount);
    event Initialize(PoolId id, Currency indexed currency0, Currency indexed currency1, uint24 fee, int24 tickSpacing, address hooks);
    event ModifyLiquidity(PoolId indexed id, address indexed sender, int24 tickLower, int24 tickUpper, int256 liquidityDelta);
    event OperatorSet(address indexed owner, address indexed operator, bool approved);
    event OwnershipTransferred(address indexed user, address indexed newOwner);
    event ProtocolFeeControllerUpdated(address protocolFeeController);
    event ProtocolFeeUpdated(PoolId indexed id, uint24 protocolFee);
    event Swap(PoolId indexed id, address sender, int128 amount0, int128 amount1, uint160 sqrtPriceX96, uint128 liquidity, int24 tick, uint24 fee);
    event Transfer(address caller, address indexed from, address indexed to, uint256 indexed id, uint256 amount);

    constructor(uint256 controllerGasLimit);

    function MAX_TICK_SPACING() external view returns (int24);
    function MIN_TICK_SPACING() external view returns (int24);
    function allowance(address, address, uint256) external view returns (uint256);
    function approve(address spender, uint256 id, uint256 amount) external returns (bool);
    function balanceOf(address, uint256) external view returns (uint256);
    function burn(address from, uint256 id, uint256 amount) external;
    function collectProtocolFees(address recipient, Currency currency, uint256 amount) external returns (uint256 amountCollected);
    function donate(PoolKey memory key, uint256 amount0, uint256 amount1, bytes memory hookData) external returns (BalanceDelta delta);
    function extsload(bytes32 slot) external view returns (bytes32);
    function extsload(bytes32 startSlot, uint256 nSlots) external view returns (bytes memory);
    function extsload(bytes32[] memory slots) external view returns (bytes32[] memory);
    function exttload(bytes32[] memory slots) external view returns (bytes32[] memory);
    function exttload(bytes32 slot) external view returns (bytes32);
    function initialize(PoolKey memory key, uint160 sqrtPriceX96, bytes memory hookData) external returns (int24 tick);
    function isOperator(address, address) external view returns (bool);
    function mint(address to, uint256 id, uint256 amount) external;
    function modifyLiquidity(PoolKey memory key, ModifyLiquidityParams memory params, bytes memory hookData) external returns (BalanceDelta callerDelta, BalanceDelta feesAccrued);
    function owner() external view returns (address);
    function protocolFeeController() external view returns (address);
    function protocolFeesAccrued(Currency currency) external view returns (uint256);
    function setOperator(address operator, bool approved) external returns (bool);
    function setProtocolFee(PoolKey memory key, uint24 newProtocolFee) external;
    function setProtocolFeeController(address controller) external;
    function settle(Currency currency) external payable returns (uint256 paid);
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
    function swap(PoolKey memory key, SwapParams memory params, bytes memory hookData) external returns (BalanceDelta swapDelta);
    function sync(Currency currency) external returns (uint256 balance);
    function take(Currency currency, address to, uint256 amount) external;
    function transfer(address receiver, uint256 id, uint256 amount) external returns (bool);
    function transferFrom(address sender, address receiver, uint256 id, uint256 amount) external returns (bool);
    function transferOwnership(address newOwner) external;
    function unlock(bytes memory data) external returns (bytes memory result);
    function updateDynamicLPFee(PoolKey memory key, uint24 newDynamicLPFee) external;
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [
      {
        "name": "controllerGasLimit",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "MAX_TICK_SPACING",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "int24",
        "internalType": "int24"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "MIN_TICK_SPACING",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "int24",
        "internalType": "int24"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "allowance",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "approve",
    "inputs": [
      {
        "name": "spender",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "id",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "balanceOf",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "burn",
    "inputs": [
      {
        "name": "from",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "id",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "collectProtocolFees",
    "inputs": [
      {
        "name": "recipient",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "currency",
        "type": "address",
        "internalType": "Currency"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "amountCollected",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "donate",
    "inputs": [
      {
        "name": "key",
        "type": "tuple",
        "internalType": "struct PoolKey",
        "components": [
          {
            "name": "currency0",
            "type": "address",
            "internalType": "Currency"
          },
          {
            "name": "currency1",
            "type": "address",
            "internalType": "Currency"
          },
          {
            "name": "fee",
            "type": "uint24",
            "internalType": "uint24"
          },
          {
            "name": "tickSpacing",
            "type": "int24",
            "internalType": "int24"
          },
          {
            "name": "hooks",
            "type": "address",
            "internalType": "contract IHooks"
          }
        ]
      },
      {
        "name": "amount0",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "amount1",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "hookData",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "delta",
        "type": "int256",
        "internalType": "BalanceDelta"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "extsload",
    "inputs": [
      {
        "name": "slot",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "extsload",
    "inputs": [
      {
        "name": "startSlot",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "nSlots",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "extsload",
    "inputs": [
      {
        "name": "slots",
        "type": "bytes32[]",
        "internalType": "bytes32[]"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32[]",
        "internalType": "bytes32[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "exttload",
    "inputs": [
      {
        "name": "slots",
        "type": "bytes32[]",
        "internalType": "bytes32[]"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32[]",
        "internalType": "bytes32[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "exttload",
    "inputs": [
      {
        "name": "slot",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "initialize",
    "inputs": [
      {
        "name": "key",
        "type": "tuple",
        "internalType": "struct PoolKey",
        "components": [
          {
            "name": "currency0",
            "type": "address",
            "internalType": "Currency"
          },
          {
            "name": "currency1",
            "type": "address",
            "internalType": "Currency"
          },
          {
            "name": "fee",
            "type": "uint24",
            "internalType": "uint24"
          },
          {
            "name": "tickSpacing",
            "type": "int24",
            "internalType": "int24"
          },
          {
            "name": "hooks",
            "type": "address",
            "internalType": "contract IHooks"
          }
        ]
      },
      {
        "name": "sqrtPriceX96",
        "type": "uint160",
        "internalType": "uint160"
      },
      {
        "name": "hookData",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "tick",
        "type": "int24",
        "internalType": "int24"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "isOperator",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "mint",
    "inputs": [
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "id",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "modifyLiquidity",
    "inputs": [
      {
        "name": "key",
        "type": "tuple",
        "internalType": "struct PoolKey",
        "components": [
          {
            "name": "currency0",
            "type": "address",
            "internalType": "Currency"
          },
          {
            "name": "currency1",
            "type": "address",
            "internalType": "Currency"
          },
          {
            "name": "fee",
            "type": "uint24",
            "internalType": "uint24"
          },
          {
            "name": "tickSpacing",
            "type": "int24",
            "internalType": "int24"
          },
          {
            "name": "hooks",
            "type": "address",
            "internalType": "contract IHooks"
          }
        ]
      },
      {
        "name": "params",
        "type": "tuple",
        "internalType": "struct IPoolManager.ModifyLiquidityParams",
        "components": [
          {
            "name": "tickLower",
            "type": "int24",
            "internalType": "int24"
          },
          {
            "name": "tickUpper",
            "type": "int24",
            "internalType": "int24"
          },
          {
            "name": "liquidityDelta",
            "type": "int256",
            "internalType": "int256"
          },
          {
            "name": "salt",
            "type": "bytes32",
            "internalType": "bytes32"
          }
        ]
      },
      {
        "name": "hookData",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "callerDelta",
        "type": "int256",
        "internalType": "BalanceDelta"
      },
      {
        "name": "feesAccrued",
        "type": "int256",
        "internalType": "BalanceDelta"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "owner",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "protocolFeeController",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract IProtocolFeeController"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "protocolFeesAccrued",
    "inputs": [
      {
        "name": "currency",
        "type": "address",
        "internalType": "Currency"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "setOperator",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "approved",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setProtocolFee",
    "inputs": [
      {
        "name": "key",
        "type": "tuple",
        "internalType": "struct PoolKey",
        "components": [
          {
            "name": "currency0",
            "type": "address",
            "internalType": "Currency"
          },
          {
            "name": "currency1",
            "type": "address",
            "internalType": "Currency"
          },
          {
            "name": "fee",
            "type": "uint24",
            "internalType": "uint24"
          },
          {
            "name": "tickSpacing",
            "type": "int24",
            "internalType": "int24"
          },
          {
            "name": "hooks",
            "type": "address",
            "internalType": "contract IHooks"
          }
        ]
      },
      {
        "name": "newProtocolFee",
        "type": "uint24",
        "internalType": "uint24"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setProtocolFeeController",
    "inputs": [
      {
        "name": "controller",
        "type": "address",
        "internalType": "contract IProtocolFeeController"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "settle",
    "inputs": [
      {
        "name": "currency",
        "type": "address",
        "internalType": "Currency"
      }
    ],
    "outputs": [
      {
        "name": "paid",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "supportsInterface",
    "inputs": [
      {
        "name": "interfaceId",
        "type": "bytes4",
        "internalType": "bytes4"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "swap",
    "inputs": [
      {
        "name": "key",
        "type": "tuple",
        "internalType": "struct PoolKey",
        "components": [
          {
            "name": "currency0",
            "type": "address",
            "internalType": "Currency"
          },
          {
            "name": "currency1",
            "type": "address",
            "internalType": "Currency"
          },
          {
            "name": "fee",
            "type": "uint24",
            "internalType": "uint24"
          },
          {
            "name": "tickSpacing",
            "type": "int24",
            "internalType": "int24"
          },
          {
            "name": "hooks",
            "type": "address",
            "internalType": "contract IHooks"
          }
        ]
      },
      {
        "name": "params",
        "type": "tuple",
        "internalType": "struct IPoolManager.SwapParams",
        "components": [
          {
            "name": "zeroForOne",
            "type": "bool",
            "internalType": "bool"
          },
          {
            "name": "amountSpecified",
            "type": "int256",
            "internalType": "int256"
          },
          {
            "name": "sqrtPriceLimitX96",
            "type": "uint160",
            "internalType": "uint160"
          }
        ]
      },
      {
        "name": "hookData",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "swapDelta",
        "type": "int256",
        "internalType": "BalanceDelta"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "sync",
    "inputs": [
      {
        "name": "currency",
        "type": "address",
        "internalType": "Currency"
      }
    ],
    "outputs": [
      {
        "name": "balance",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "take",
    "inputs": [
      {
        "name": "currency",
        "type": "address",
        "internalType": "Currency"
      },
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "transfer",
    "inputs": [
      {
        "name": "receiver",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "id",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "transferFrom",
    "inputs": [
      {
        "name": "sender",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "receiver",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "id",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "transferOwnership",
    "inputs": [
      {
        "name": "newOwner",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "unlock",
    "inputs": [
      {
        "name": "data",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "updateDynamicLPFee",
    "inputs": [
      {
        "name": "key",
        "type": "tuple",
        "internalType": "struct PoolKey",
        "components": [
          {
            "name": "currency0",
            "type": "address",
            "internalType": "Currency"
          },
          {
            "name": "currency1",
            "type": "address",
            "internalType": "Currency"
          },
          {
            "name": "fee",
            "type": "uint24",
            "internalType": "uint24"
          },
          {
            "name": "tickSpacing",
            "type": "int24",
            "internalType": "int24"
          },
          {
            "name": "hooks",
            "type": "address",
            "internalType": "contract IHooks"
          }
        ]
      },
      {
        "name": "newDynamicLPFee",
        "type": "uint24",
        "internalType": "uint24"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "event",
    "name": "Approval",
    "inputs": [
      {
        "name": "owner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "spender",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "id",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Initialize",
    "inputs": [
      {
        "name": "id",
        "type": "bytes32",
        "indexed": false,
        "internalType": "PoolId"
      },
      {
        "name": "currency0",
        "type": "address",
        "indexed": true,
        "internalType": "Currency"
      },
      {
        "name": "currency1",
        "type": "address",
        "indexed": true,
        "internalType": "Currency"
      },
      {
        "name": "fee",
        "type": "uint24",
        "indexed": false,
        "internalType": "uint24"
      },
      {
        "name": "tickSpacing",
        "type": "int24",
        "indexed": false,
        "internalType": "int24"
      },
      {
        "name": "hooks",
        "type": "address",
        "indexed": false,
        "internalType": "contract IHooks"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "ModifyLiquidity",
    "inputs": [
      {
        "name": "id",
        "type": "bytes32",
        "indexed": true,
        "internalType": "PoolId"
      },
      {
        "name": "sender",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "tickLower",
        "type": "int24",
        "indexed": false,
        "internalType": "int24"
      },
      {
        "name": "tickUpper",
        "type": "int24",
        "indexed": false,
        "internalType": "int24"
      },
      {
        "name": "liquidityDelta",
        "type": "int256",
        "indexed": false,
        "internalType": "int256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "OperatorSet",
    "inputs": [
      {
        "name": "owner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "operator",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "approved",
        "type": "bool",
        "indexed": false,
        "internalType": "bool"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "OwnershipTransferred",
    "inputs": [
      {
        "name": "user",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "newOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "ProtocolFeeControllerUpdated",
    "inputs": [
      {
        "name": "protocolFeeController",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "ProtocolFeeUpdated",
    "inputs": [
      {
        "name": "id",
        "type": "bytes32",
        "indexed": true,
        "internalType": "PoolId"
      },
      {
        "name": "protocolFee",
        "type": "uint24",
        "indexed": false,
        "internalType": "uint24"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Swap",
    "inputs": [
      {
        "name": "id",
        "type": "bytes32",
        "indexed": true,
        "internalType": "PoolId"
      },
      {
        "name": "sender",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "amount0",
        "type": "int128",
        "indexed": false,
        "internalType": "int128"
      },
      {
        "name": "amount1",
        "type": "int128",
        "indexed": false,
        "internalType": "int128"
      },
      {
        "name": "sqrtPriceX96",
        "type": "uint160",
        "indexed": false,
        "internalType": "uint160"
      },
      {
        "name": "liquidity",
        "type": "uint128",
        "indexed": false,
        "internalType": "uint128"
      },
      {
        "name": "tick",
        "type": "int24",
        "indexed": false,
        "internalType": "int24"
      },
      {
        "name": "fee",
        "type": "uint24",
        "indexed": false,
        "internalType": "uint24"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Transfer",
    "inputs": [
      {
        "name": "caller",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "from",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "to",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "id",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "AlreadyUnlocked",
    "inputs": []
  },
  {
    "type": "error",
    "name": "CurrenciesOutOfOrderOrEqual",
    "inputs": []
  },
  {
    "type": "error",
    "name": "CurrencyNotSettled",
    "inputs": []
  },
  {
    "type": "error",
    "name": "DelegateCallNotAllowed",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidCaller",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidProtocolFee",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ManagerLocked",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NonZeroNativeValue",
    "inputs": []
  },
  {
    "type": "error",
    "name": "PoolNotInitialized",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ProtocolFeeCannotBeFetched",
    "inputs": []
  },
  {
    "type": "error",
    "name": "SwapAmountCannotBeZero",
    "inputs": []
  },
  {
    "type": "error",
    "name": "TickSpacingTooLarge",
    "inputs": []
  },
  {
    "type": "error",
    "name": "TickSpacingTooSmall",
    "inputs": []
  },
  {
    "type": "error",
    "name": "UnauthorizedDynamicLPFeeUpdate",
    "inputs": []
  }
]
```*/
#[allow(non_camel_case_types, non_snake_case, clippy::style)]
pub mod PoolManager {
    use alloy::sol_types as alloy_sol_types;

    use super::*;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x60c034609d57601f615dc338819003918201601f19168301916001600160401b0383118484101760a157808492602094604052833981010312609d57515f80546001600160a01b03191633908117825560405192917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08180a36080523060a052615d0d90816100b682396080518161378b015260a051816131e40152f35b5f80fd5b634e487b7160e01b5f52604160045260245ffdfe60a0806040526004361015610012575f80fd5b5f3560e01c908162fdd58e14612ba05750806301ffc9a714612ae157806307eff0dd14612aa8578063095bcdb6146129fe5780630b0d9c0914612970578063156e29f6146128c05780631e2eaeaf14612886578063234266d71461260f5780632d7713891461254657806335fd631a146124e0578063426a84931461245c57806348c89491146121ff57806352759651146120e7578063558a729714612010578063598af9e714611f785780635a6bcfda146114ba57806360460f0614611480578063695c5bf514610f555780636a256b2914610df35780637e87ce7d14610cc45780638161b87414610bcc5780638da5cb5b14610b7c57806397e8cd4e14610b195780639bf6645f14610add578063a584119414610a9c578063b6363cf214610a0b578063dbd035ff146109cb578063f02de3b21461097a578063f135baaa14610940578063f2fde38b14610894578063f3cd914c14610501578063f5298aca146103345763fe99049a14610186575f80fd5b346103305760807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610330576101bd612c0a565b6101c5612c2d565b90604435917f1b3d7edb2e9c0b0e7c525b20aaaef0f5940d2ed71663c7d39266ecafac72885961027973ffffffffffffffffffffffffffffffffffffffff80606435951693843314158061030d575b610287575b845f52600460205260405f20875f5260205260405f2061023a878254612eb8565b90551693845f52600460205260405f20865f5260205260405f2061025f828254612ec5565b905560408051338152602081019290925290918291820190565b0390a4602060405160018152f35b845f52600560205260405f208233165f5260205260405f20875f5260205260405f2054867fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82036102da575b5050610219565b6102e391612eb8565b855f52600560205260405f208333165f5260205260405f20885f5260205260405f20555f866102d3565b50845f52600360205260405f208233165f5260205260ff60405f20541615610214565b5f80fd5b346103305761034236612c50565b7fc090fc4683624cfc3884e9d8de5eca132f2d0ec062aff75d43c0465d5ceeab239291925c156104d9577f1b3d7edb2e9c0b0e7c525b20aaaef0f5940d2ed71663c7d39266ecafac7288596103ef73ffffffffffffffffffffffffffffffffffffffff5f946103bd6103b386613018565b3390848a1661305e565b169233841415806104a2575b6103f4575b8385526004602052604085208686526020526040852061025f828254612eb8565b0390a4005b83855260056020526040852073ffffffffffffffffffffffffffffffffffffffff33168652602052604085208686526020526040852054817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff820361045b575b50506103ce565b61046491612eb8565b84865260056020526040862073ffffffffffffffffffffffffffffffffffffffff331687526020526040862087875260205260408620558681610454565b5083855260036020526040852073ffffffffffffffffffffffffffffffffffffffff3316865260205260ff604086205416156103c9565b7f54e3ca0d000000000000000000000000000000000000000000000000000000005f5260045ffd5b34610330576101207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103305761053a36612d4c565b60607fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff5c36011261033057604051906060820182811067ffffffffffffffff8211176108675760405260a4358015158103610330578252602082019060c435825260e4359073ffffffffffffffffffffffffffffffffffffffff8216820361033057604084019182526101043567ffffffffffffffff8111610330576105e3903690600401612e18565b9490937fc090fc4683624cfc3884e9d8de5eca132f2d0ec062aff75d43c0465d5ceeab235c156104d9576106156131cd565b511561083f57819060a0822095865f52600660205260405f209561063887613234565b6080840196848383868b5173ffffffffffffffffffffffffffffffffffffffff169361066394613996565b90959198606088015160020b9983511515915173ffffffffffffffffffffffffffffffffffffffff16916040519b61069a8d612cdd565b8c5260208c015260408b015260608a015262ffffff166080890152805115155f14997f40e9cecb9f5f1f1c5b9c97dec2917b7ee92e57ba5563708daca94dd84ad7112f60e062ffffff6107136107bf9c60209f9b6107ac9c61081f575173ffffffffffffffffffffffffffffffffffffffff16976149d7565b9392988291926107f0575b505073ffffffffffffffffffffffffffffffffffffffff6040840151169260606fffffffffffffffffffffffffffffffff60a08301511691015160020b90604051943386528a60801d600f0b60208701528a600f0b60408701526060860152608085015260a08401521660c0820152a28673ffffffffffffffffffffffffffffffffffffffff8a5116613ba3565b809491946107c7575b5050823391613310565b604051908152f35b73ffffffffffffffffffffffffffffffffffffffff6107e99251169083613310565b84806107b5565b73ffffffffffffffffffffffffffffffffffffffff165f5260206001905260405f209081540190555f8061071e565b6020015173ffffffffffffffffffffffffffffffffffffffff16976149d7565b7fbe8b8507000000000000000000000000000000000000000000000000000000005f5260045ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b346103305760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610330577fffffffffffffffffffffffff00000000000000000000000000000000000000006108ec612c0a565b73ffffffffffffffffffffffffffffffffffffffff5f54916109118284163314612ed2565b1691829116175f55337f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e05f80a3005b346103305760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610330576004355c5f5260205ff35b34610330575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261033057602073ffffffffffffffffffffffffffffffffffffffff60025416604051908152f35b34610330576109d936612e46565b604060045f3760051b604001809160208060405b83355481520191019082811015610a0757602080916109ed565b825ff35b346103305760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261033057610a42612c0a565b73ffffffffffffffffffffffffffffffffffffffff610a5f612c2d565b91165f52600360205273ffffffffffffffffffffffffffffffffffffffff60405f2091165f52602052602060ff60405f2054166040519015158152f35b346103305760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103305760206107bf610ad8612c0a565b612faf565b3461033057610aeb36612e46565b604060045f3760051b604001809160208060405b83355c81520191019082811015610a075760208091610aff565b346103305760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103305773ffffffffffffffffffffffffffffffffffffffff610b65612c0a565b165f526001602052602060405f2054604051908152f35b34610330575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261033057602073ffffffffffffffffffffffffffffffffffffffff5f5416604051908152f35b346103305760607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261033057610c03612c0a565b610c0b612c2d565b9060443573ffffffffffffffffffffffffffffffffffffffff600254163303610c9c576020926107bf9180610c94575073ffffffffffffffffffffffffffffffffffffffff81165f526001845260405f20549283915b73ffffffffffffffffffffffffffffffffffffffff81165f526001865260405f20610c8d848254612eb8565b905561314e565b928391610c61565b7f48f5c3ed000000000000000000000000000000000000000000000000000000005f5260045ffd5b346103305760c07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261033057610cfc36612d4c565b610d04612d3a565b9073ffffffffffffffffffffffffffffffffffffffff600254163303610c9c57623e900082106103e9610fff8416101615610dcb57602060a07fe9c42593e71f84403b84352cd168d693e2c9fcd1fdbcc3feb21d92b43e6696f9922092835f526006825260405f20610d7581613234565b805479ffffff00000000000000000000000000000000000000000000008360b81b16907fffffffffffff000000ffffffffffffffffffffffffffffffffffffffffffffff1617905562ffffff60405191168152a2005b7fba97f838000000000000000000000000000000000000000000000000000000005f5260045ffd5b60207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261033057610e25612c0a565b7fc090fc4683624cfc3884e9d8de5eca132f2d0ec062aff75d43c0465d5ceeab235c156104d95773ffffffffffffffffffffffffffffffffffffffff8116610e80576020906107bf34915b610e7983613018565b339161305e565b34610f2d577f1e0745a7db1623981f0b2a5d4232364c00787266eb75ad546f190e6cebe9bd955f528060205260405f205c908115610f0557817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60209314610efe575b610ef86107bf91610ef384612faf565b612eb8565b91610e70565b505f610ee3565b7f8774be48000000000000000000000000000000000000000000000000000000005f5260045ffd5b7f19d245cf000000000000000000000000000000000000000000000000000000005f5260045ffd5b346103305760e07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261033057610f8d36612d4c565b60a43573ffffffffffffffffffffffffffffffffffffffff81168082036103305760c43567ffffffffffffffff811161033057610fce903690600401612e18565b610fd66131cd565b6060850192617fff845160020b13611458576001845160020b126114305773ffffffffffffffffffffffffffffffffffffffff86511692602087019373ffffffffffffffffffffffffffffffffffffffff855116111561140857608087019473ffffffffffffffffffffffffffffffffffffffff86511695604089019661106362ffffff89511682613682565b156113dd575061107862ffffff885116613740565b93815173ffffffffffffffffffffffffffffffffffffffff811690813303611319575b505060a08a20936110ab8b61375d565b9a9050855f52600660205260405f2090815473ffffffffffffffffffffffffffffffffffffffff166112f1576110e090614664565b9a8b9760d01b7cffffff00000000000000000000000000000000000000000000000000001690848960a01b76ffffff000000000000000000000000000000000000000016179060b81b79ffffff0000000000000000000000000000000000000000000000161717905582519173ffffffffffffffffffffffffffffffffffffffff831692833314159c7f3fd553db44f207b1f41348cfc4d251860814af9eadc470e8e7895e4d120511f49960809960209f9662ffffff9673ffffffffffffffffffffffffffffffffffffffff989689979688976111ef575b5050505050505116985116985116925160020b915116916040519384528984015260408301526060820152a36040519060020b8152f35b611000166111fe575b806111b8565b6112b56112e1926112e696604051966020947fa910f80f000000000000000000000000000000000000000000000000000000008996870152336024870152611293604487018c73ffffffffffffffffffffffffffffffffffffffff6080809282815116855282602082015116602086015262ffffff6040820151166040860152606081015160020b6060860152015116910152565b60e486015260020b610104850152610120610124850152610144840191612f71565b037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08101845283612cf9565b613d47565b508e8d8180806111f8565b7f7983c051000000000000000000000000000000000000000000000000000000005f5260045ffd5b61200016611328575b8061109b565b6113d690604051907f3440d8200000000000000000000000000000000000000000000000000000000060208301523360248301526113b48d604484019073ffffffffffffffffffffffffffffffffffffffff6080809282815116855282602082015116602086015262ffffff6040820151166040860152606081015160020b6060860152015116910152565b8360e48301526101006101048301526112e1826112b561012482018c8b612f71565b508a611322565b7fe65af6a0000000000000000000000000000000000000000000000000000000005f5260045260245ffd5b7feaa6c6eb000000000000000000000000000000000000000000000000000000005f5260045ffd5b7f16fe7696000000000000000000000000000000000000000000000000000000005f5260045ffd5b7fb02b5dc2000000000000000000000000000000000000000000000000000000005f5260045ffd5b34610330575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610330576020604051617fff8152f35b34610330576101407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610330576114f336612d4c565b60807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff5c360112610330576040519061152a82612ca5565b60a4358060020b810361033057825260c4358060020b810361033057602083015260e435604083015260608201916101043583526101243567ffffffffffffffff81116103305761157f903690600401612e18565b907fc090fc4683624cfc3884e9d8de5eca132f2d0ec062aff75d43c0465d5ceeab235c156104d9576115af6131cd565b60a0842091825f52600660205260405f20916115ca83613234565b60808601518573ffffffffffffffffffffffffffffffffffffffff821691823303611e9a575b5090505160020b93602086015160020b9561160e6040820151613441565b96606089015160020b99516040519a6116268c612cc1565b338c528860208d01528260408d015289600f0b60608d015260808c015260a08b01525f9080881215611e6b577ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff276188812611e3f57620d89e88113611e1457604051986116908a612ca5565b5f8a525f60208b01525f60408b01525f60608b015280600f0b611b3b575b60048801988060020b5f528960205260405f20998360020b5f5260205260405f20895460a01c60020b8281125f14611ae9575060028060018d0154600184015490039c015491015490039c5b60a073ffffffffffffffffffffffffffffffffffffffff82511691015160265283600652816003525f52603a600c205f6026525f526006890160205260405f20986fffffffffffffffffffffffffffffffff8a54169a83600f0b155f14611a8c578b15611a64576117a560409f6118799c61179f9161188b9f5b6001830195611797600261178b848a548503613ecb565b95019283548503613ecb565b965555613018565b91613018565b6fffffffffffffffffffffffffffffffff169060801b179b5f84600f0b126119fa575b5082600f0b6118c3575b505050506117f96117ea8960801d8360801d01613441565b9189600f0b90600f0b01613441565b6fffffffffffffffffffffffffffffffff169060801b1791815160020b90602083015160020b8b840151908c5193845260208401528b8301527f541c041c2cce48e614b3de043c9280f06b6164c0a1741649e2de3c3d375f797460603393a38773ffffffffffffffffffffffffffffffffffffffff608082015116613530565b80949194611897575b50833391613310565b82519182526020820152f35b6118bd9073ffffffffffffffffffffffffffffffffffffffff6080840151169083613310565b85611882565b809192939450548060a01c60020b9073ffffffffffffffffffffffffffffffffffffffff16908381125f1461192b57505050916119199161191361190961191e956141dc565b91600f0b926141dc565b906145b3565b613441565b60801b5b8a8080806117d2565b948091939295125f146119c6576fffffffffffffffffffffffffffffffff926119836119196119999461197061191960039661196a8b600f0b916141dc565b876145b3565b9361197e89600f0b926141dc565b61452a565b84169060801b17940192600f0b82845416614604565b167fffffffffffffffffffffffffffffffff00000000000000000000000000000000825416179055611922565b91506119e39350916119dd611909611919946141dc565b9061452a565b6fffffffffffffffffffffffffffffffff16611922565b808f9151611a3a575b0151611a10575b8e6117c8565b611a35848260049160020b5f52016020525f6002604082208281558260018201550155565b611a0a565b611a5f848460049160020b5f52016020525f6002604082208281558260018201550155565b611a03565b7faefeb924000000000000000000000000000000000000000000000000000000005f5260045ffd5b6117a560409f6118799c61179f9161188b9f6fffffffffffffffffffffffffffffffff611abc8a600f0b83614604565b167fffffffffffffffffffffffffffffffff00000000000000000000000000000000845416178355611774565b909a908413611b0f5760028060018d0154600184015490039c015491015490039c6116fa565b99600260018b015460018d01549003600183015490039b81808d0154910154900391015490039c6116fa565b8860020b5f5260048801602052886fffffffffffffffffffffffffffffffff60405f20805490611b95838316928d611b7688600f0b86614604565b9415968787871615141597611de5575b505086600f0b9060801d613b5c565b60801b821790551660208c01528a528160020b5f526004880160205260405f208054906fffffffffffffffffffffffffffffffff8216611bd884600f0b82614604565b901592836fffffffffffffffffffffffffffffffff831615141593611dbe575b84600f0b9060801d600f0b03916f7fffffffffffffffffffffffffffffff83137fffffffffffffffffffffffffffffffff80000000000000000000000000000000841217611d9157826fffffffffffffffffffffffffffffffff935060801b821790551660608c015260408b0152898c5f83600f0b1215611cb9575b5051611c9f575b60408a0151156116ae57611c9a60808d015160020b8360058b016141a3565b6116ae565b611cb460808d015160020b8a60058b016141a3565b611c7b565b60016fffffffffffffffffffffffffffffffff602060808294015160020b940151169280807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff2761805028180620d89e80502030501810416809111611d65576fffffffffffffffffffffffffffffffff60608c01511611611d3957898c611c74565b507fb8e3c385000000000000000000000000000000000000000000000000000000005f5260045260245ffd5b897fb8e3c385000000000000000000000000000000000000000000000000000000005f5260045260245ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b8b5460a01c60020b8613611bf85760018c0154600184015560028c01546002840155611bf8565b815460a01c60020b1215611dfa575b8f611b86565b80600160029201546001860155015460028401558d611df4565b7f1ad777f8000000000000000000000000000000000000000000000000000000005f5260045260245ffd5b877fd5e2f7ab000000000000000000000000000000000000000000000000000000005f5260045260245ffd5b877fc4433ed5000000000000000000000000000000000000000000000000000000005f5260045260245260445ffd5b5f604083015113808091611f6b575b15611efd575050611ef3916112e1896112b587876040519687947f259982e50000000000000000000000000000000000000000000000000000000060208701523360248701613387565b505b8785816115f0565b159081611f5d575b50611f12575b5050611ef5565b611f55916112e1896112b587876040519687947f21d0ee700000000000000000000000000000000000000000000000000000000060208701523360248701613387565b508785611f0b565b61020091501615158a611f05565b5061080082161515611ea9565b346103305760607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261033057611faf612c0a565b73ffffffffffffffffffffffffffffffffffffffff611fcc612c2d565b91165f52600560205273ffffffffffffffffffffffffffffffffffffffff60405f2091165f5260205260405f206044355f52602052602060405f2054604051908152f35b346103305760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261033057612047612c0a565b602435908115158092036103305773ffffffffffffffffffffffffffffffffffffffff90335f52600360205260405f208282165f5260205260405f207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0081541660ff851617905560405192835216907fceb576d9f15e4e200fdb5096d64d5dfd667e16def20c1eefd14256d8e3faa26760203392a3602060405160018152f35b346103305760c07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103305761211f36612d4c565b612127612d3a565b906280000062ffffff604083015116148015906121db575b6121b35760a09061214f8361334e565b205f52600660205260405f209061216582613234565b81547fffffff000000ffffffffffffffffffffffffffffffffffffffffffffffffffff1660d09190911b7cffffff000000000000000000000000000000000000000000000000000016179055005b7f30d21641000000000000000000000000000000000000000000000000000000005f5260045ffd5b5073ffffffffffffffffffffffffffffffffffffffff60808201511633141561213f565b346103305760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103305760043567ffffffffffffffff81116103305761224e903690600401612e18565b7fc090fc4683624cfc3884e9d8de5eca132f2d0ec062aff75d43c0465d5ceeab235c612434576122da915f9160017fc090fc4683624cfc3884e9d8de5eca132f2d0ec062aff75d43c0465d5ceeab235d60405193849283927f91dd7346000000000000000000000000000000000000000000000000000000008452602060048501526024840191612f71565b038183335af1908115612429575f916123af575b507f7d4b3164c6e45b97e7d87b7125a44c5828d005af88f9d751cfd78729c5d99a0b5c6123875760406020915f7fc090fc4683624cfc3884e9d8de5eca132f2d0ec062aff75d43c0465d5ceeab235d7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f835194859381855280519182918282880152018686015e5f85828601015201168101030190f35b7f5212cba1000000000000000000000000000000000000000000000000000000005f5260045ffd5b90503d805f833e6123c08183612cf9565b8101906020818303126103305780519067ffffffffffffffff8211610330570181601f82011215610330578051906123f782612f37565b926124056040519485612cf9565b8284526020838301011161033057815f9260208093018386015e83010152816122ee565b6040513d5f823e3d90fd5b7f5090d6c6000000000000000000000000000000000000000000000000000000005f5260045ffd5b346103305773ffffffffffffffffffffffffffffffffffffffff61247f36612c50565b91929092335f52600560205260405f208282165f5260205260405f20845f526020528260405f205560405192835216907fb3fd5071835887567a0671151121894ddccc2842f1d10bedad13e0d17cace9a760203392a4602060405160018152f35b346103305760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103305760043560205f5260243560051b8060205260400180916001602060405b835481520191019082811015610a0757602060019161252c565b346103305760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103305760043573ffffffffffffffffffffffffffffffffffffffff81168091036103305760207fb4bd8ef53df690b9943d3318996006dbb82a25f54719d8c8035b516a2a5b8acc916125dc73ffffffffffffffffffffffffffffffffffffffff5f54163314612ed2565b807fffffffffffffffffffffffff00000000000000000000000000000000000000006002541617600255604051908152a1005b34610330576101007ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103305761264836612d4c565b60c4359060a43560e43567ffffffffffffffff81116103305761266f903690600401612e18565b9190937fc090fc4683624cfc3884e9d8de5eca132f2d0ec062aff75d43c0465d5ceeab235c156104d9576126a16131cd565b60a084205f52600660205260405f20946126ba86613234565b6080850194855173ffffffffffffffffffffffffffffffffffffffff81169081330361282e575b50506fffffffffffffffffffffffffffffffff6003880154169586156128065760209761270d86613018565b5f0361271886613018565b5f036fffffffffffffffffffffffffffffffff169060801b1797866127ed575b856127d2575b505061274b338884613310565b519273ffffffffffffffffffffffffffffffffffffffff841693843303612777575b8888604051908152f35b601016612785575b8061276d565b6127c6956112e1936112b5926040519788957fe1b4af69000000000000000000000000000000000000000000000000000000008d880152336024880161327a565b5082808080808061277f565b6127de60029187613e0a565b9101908154019055888061273e565b6127f78188613e0a565b60018301908154019055612738565b7fa74f97ab000000000000000000000000000000000000000000000000000000005f5260045ffd5b60201661283c575b806126e1565b6040517fb6a8b0fa00000000000000000000000000000000000000000000000000000000602082015261287f916112e1826112b58a888a8c8a336024880161327a565b5087612836565b346103305760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261033057600435545f5260205ff35b34610330576128ce36612c50565b90917fc090fc4683624cfc3884e9d8de5eca132f2d0ec062aff75d43c0465d5ceeab235c156104d9577f1b3d7edb2e9c0b0e7c525b20aaaef0f5940d2ed71663c7d39266ecafac7288596103ef73ffffffffffffffffffffffffffffffffffffffff5f9361294d61293e87613018565b8603600f0b3390848a1661305e565b16938484526004602052604084208685526020526040842061025f828254612ec5565b346103305760607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610330576129a7612c0a565b6129af612c2d565b604435907fc090fc4683624cfc3884e9d8de5eca132f2d0ec062aff75d43c0465d5ceeab235c156104d9576129fc926129f76129ea84613018565b5f03600f0b33908361305e565b61314e565b005b346103305773ffffffffffffffffffffffffffffffffffffffff612a2136612c50565b91929092335f52600460205260405f20845f5260205260405f20612a46848254612eb8565b90551690815f52600460205260405f20835f5260205260405f20612a6b828254612ec5565b9055604080513380825260208201939093527f1b3d7edb2e9c0b0e7c525b20aaaef0f5940d2ed71663c7d39266ecafac7288599181908101610279565b34610330575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261033057602060405160018152f35b346103305760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610330576004357fffffffff00000000000000000000000000000000000000000000000000000000811680910361033057807f01ffc9a70000000000000000000000000000000000000000000000000000000060209214908115612b76575b506040519015158152f35b7f0f632fb30000000000000000000000000000000000000000000000000000000091501482612b6b565b346103305760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103305760209073ffffffffffffffffffffffffffffffffffffffff612bef612c0a565b165f526004825260405f206024355f52825260405f20548152f35b6004359073ffffffffffffffffffffffffffffffffffffffff8216820361033057565b6024359073ffffffffffffffffffffffffffffffffffffffff8216820361033057565b7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc60609101126103305760043573ffffffffffffffffffffffffffffffffffffffff8116810361033057906024359060443590565b6080810190811067ffffffffffffffff82111761086757604052565b60c0810190811067ffffffffffffffff82111761086757604052565b60a0810190811067ffffffffffffffff82111761086757604052565b90601f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0910116810190811067ffffffffffffffff82111761086757604052565b60a4359062ffffff8216820361033057565b7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc60a09101126103305760405190612d8382612cdd565b8160043573ffffffffffffffffffffffffffffffffffffffff8116810361033057815260243573ffffffffffffffffffffffffffffffffffffffff8116810361033057602082015260443562ffffff811681036103305760408201526064358060020b81036103305760608201526084359073ffffffffffffffffffffffffffffffffffffffff821682036103305760800152565b9181601f840112156103305782359167ffffffffffffffff8311610330576020838186019501011161033057565b9060207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc8301126103305760043567ffffffffffffffff811161033057826023820112156103305780600401359267ffffffffffffffff84116103305760248460051b83010111610330576024019190565b91908203918211611d9157565b91908201809211611d9157565b15612ed957565b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600c60248201527f554e415554484f52495a454400000000000000000000000000000000000000006044820152fd5b67ffffffffffffffff811161086757601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01660200190565b601f82602094937fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe093818652868601375f8582860101520116010190565b90612fb9826138ff565b9182908315612ff0575b7f1e0745a7db1623981f0b2a5d4232364c00787266eb75ad546f190e6cebe9bd955f5260205260405f205d565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff9150612fc3565b6f8000000000000000000000000000000081101561303657600f0b90565b6393dafdf15f526004601cfd5b9190915f8382019384129112908015821691151617611d9157565b90600f0b91821561314957805f528160205261307f60405f205c9384613043565b92836130f957507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f7d4b3164c6e45b97e7d87b7125a44c5828d005af88f9d751cfd78729c5d99a0b5c017f7d4b3164c6e45b97e7d87b7125a44c5828d005af88f9d751cfd78729c5d99a0b5d5b5f5260205260405f205d565b6130ed5760017f7d4b3164c6e45b97e7d87b7125a44c5828d005af88f9d751cfd78729c5d99a0b5c017f7d4b3164c6e45b97e7d87b7125a44c5828d005af88f9d751cfd78729c5d99a0b5d6130ed565b505050565b73ffffffffffffffffffffffffffffffffffffffff811661318657505f80809381935af11561317957565b63f4b3b1bc5f526004601cfd5b60105f60449260209582956014526034526fa9059cbb00000000000000000000000082525af13d1560015f51141716156131c0575f603452565b63f27f64e45f526004601cfd5b73ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016300361320c57565b7f0d89438e000000000000000000000000000000000000000000000000000000005f5260045ffd5b5473ffffffffffffffffffffffffffffffffffffffff161561325257565b7f486aa307000000000000000000000000000000000000000000000000000000005f5260045ffd5b91926132f56101209473ffffffffffffffffffffffffffffffffffffffff61330d999794168552602085019073ffffffffffffffffffffffffffffffffffffffff6080809282815116855282602082015116602086015262ffffff6040820151166040860152606081015160020b6060860152015116910152565b60c083015260e0820152816101008201520191612f71565b90565b9073ffffffffffffffffffffffffffffffffffffffff602061334c949361333f85848351168660801d9061305e565b01511690600f0b9061305e565b565b62ffffff620f424091161161335f57565b7ffc5bee12000000000000000000000000000000000000000000000000000000005f5260045ffd5b9061330d95936134046101609473ffffffffffffffffffffffffffffffffffffffff61343394168552602085019073ffffffffffffffffffffffffffffffffffffffff6080809282815116855282602082015116602086015262ffffff6040820151166040860152606081015160020b6060860152015116910152565b8051600290810b60c08501526020820151900b60e0840152604081015161010084015260600151610120830152565b816101408201520191612f71565b806f800000000000000000000000000000000160801c15613469576393dafdf15f526004601cfd5b600f0b90565b91610180936134ed61351c9273ffffffffffffffffffffffffffffffffffffffff61330d9a9895168652602086019073ffffffffffffffffffffffffffffffffffffffff6080809282815116855282602082015116602086015262ffffff6040820151166040860152606081015160020b6060860152015116910152565b8051600290810b60c08601526020820151900b60e0850152604081015161010085015260600151610120840152565b610140820152816101608201520191612f71565b929593945f9573ffffffffffffffffffffffffffffffffffffffff8516331461367857875f6040860151135f1461360a576104008616613573575b505050505050565b6135fe969897506135eb926135f7969594926135bf926040519687957f5a2a8100000000000000000000000000000000000000000000000000000000006020880152336024880161346f565b037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08101835282612cf9565b60028216151591614610565b8092614627565b915f808080808061356b565b9493929190610100851661362057505050505050565b6135fe96985085975061366c92916135bf916135f7976040519687957f8db2b652000000000000000000000000000000000000000000000000000000006020880152336024880161346f565b60018216151591614610565b505f955050505050565b608081161580613734575b61370a57604081161580613728575b61370a576104008116158061371c575b61370a5761010081161580613710575b61370a5773ffffffffffffffffffffffffffffffffffffffff81166136ea575062ffffff1662800000141590565b613fff1615908115916136fb575090565b62800000915062ffffff161490565b50505f90565b506001811615156136bc565b506002811615156136ac565b5060048116151561369c565b5060088116151561368d565b6280000062ffffff8216146137585761330d8161334e565b505f90565b5f915f9173ffffffffffffffffffffffffffffffffffffffff6002541680613783575050565b91935091505a7f00000000000000000000000000000000000000000000000000000000000000008091106138d7575f9283809360405161383860208201947f553bfc37000000000000000000000000000000000000000000000000000000008652602483019073ffffffffffffffffffffffffffffffffffffffff6080809282815116855282602082015116602086015262ffffff6040820151166040860152606081015160020b6060860152015116910152565b60a4815261384760c482612cf9565b5193f13d156138cf573d9061385b82612f37565b916138696040519384612cf9565b82523d5f602084013e5b1580156138c4575b6138bd576020015162ffffff81169081811490816138a5575b501561389f57600191565b505f8091565b90506103e9610fff623e90008410921610165f613894565b505f905f90565b50602081511161387b565b606090613873565b7f1ee49702000000000000000000000000000000000000000000000000000000005f5260045ffd5b73ffffffffffffffffffffffffffffffffffffffff168061391f57504790565b6020602491604051928380927f70a082310000000000000000000000000000000000000000000000000000000082523060048301525afa908115612429575f91613967575090565b90506020813d60201161398e575b8161398260209383612cf9565b81010312610330575190565b3d9150613975565b949192945f945f9460208101519773ffffffffffffffffffffffffffffffffffffffff84163314613b4f57608084166139d1575b5050505050565b613ac3613a73613abd876135bf6040956280000098613aa962ffffff9989519788967f575e24b4000000000000000000000000000000000000000000000000000000006020890152336024890152604488019073ffffffffffffffffffffffffffffffffffffffff6080809282815116855282602082015116602086015262ffffff6040820151166040860152606081015160020b6060860152015116910152565b8051151560e487015260208101516101048701526040015173ffffffffffffffffffffffffffffffffffffffff16610124860152565b610140610144850152610164840191612f71565b85613d47565b9401511614613b43575b600816613ade575b808080806139ca565b604001519250608083901d600f0b8015613ad557613aff905f861295613043565b9315613b3b575f84135b613b13575f613ad5565b7ffa0b71d6000000000000000000000000000000000000000000000000000000005f5260045ffd5b5f8412613b09565b60608201519350613acd565b505f965086955050505050565b90600f0b90600f0b01907fffffffffffffffffffffffffffffffff8000000000000000000000000000000082126f7fffffffffffffffffffffffffffffff831317611d9157565b9196959394929473ffffffffffffffffffffffffffffffffffffffff83163314613d3a578460801d94600f0b938860408516613c62575b50505050505f9481600f0b15801590613c56575b613bfa575b5050509190565b613c319395505f60208201511290511515145f14613c39576fffffffffffffffffffffffffffffffff169060801b175b8093614627565b5f8080613bf3565b906fffffffffffffffffffffffffffffffff169060801b17613c2a565b5082600f0b1515613bee565b613d1e613d2a946135bf61191995613d30999895613d03613a73966040519788967fb47b2fb1000000000000000000000000000000000000000000000000000000006020890152336024890152604488019073ffffffffffffffffffffffffffffffffffffffff6080809282815116855282602082015116602086015262ffffff6040820151166040860152606081015160020b6060860152015116910152565b8c610144850152610160610164850152610184840191612f71565b60048216151591614610565b90613b5c565b5f80808088613bda565b5050505050909150905f90565b5f80939281926020825192019586915af115613def57604051917fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0603f3d011683016040523d83527fffffffff00000000000000000000000000000000000000000000000000000000803d60208601905f823e51925116911603613dc757565b7f1e048e1d000000000000000000000000000000000000000000000000000000005f5260045ffd5b3d15613dfd573d5f803e3d5ffd5b6336bc48c55f526004601cfd5b908160801b907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7001000000000000000000000000000000008409928280851094039380850394858411156103305714613ec45770010000000000000000000000000000000082910981805f03168092046002816003021880820260020302808202600203028082026002030280820260020302808202600203028091026002030293600183805f03040190848311900302920304170290565b5091500490565b90808202917fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8282099183808410930392808403938470010000000000000000000000000000000011156103305714613f4457700100000000000000000000000000000000910990828211900360801b910360801c1790565b50505060801c90565b90808202917fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff828209918380841093039280840393846c0100000000000000000000000011156103305714613fbe576c01000000000000000000000000910990828211900360a01b910360601c1790565b50505060601c90565b818102907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff83820990828083109203918083039283620f424011156103305714614046577fde8f6cefed634549b62c77574f722e1ac57e23f24d8fd5cb790fb65668c2613993620f4240910990828211900360fa1b910360061c170290565b5050620f424091500490565b908160601b907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff6c010000000000000000000000008409928280851094039380850394858411156103305714613ec4576c0100000000000000000000000082910981805f03168092046002816003021880820260020302808202600203028082026002030280820260020302808202600203028091026002030293600183805f03040190848311900302920304170290565b91818302917fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff81850993838086109503948086039586851115610330571461419b579082910981805f03168092046002816003021880820260020302808202600203028082026002030280820260020302808202600203028091026002030293600183805f03040190848311900302920304170290565b505091500490565b91908181076141c95705908160081d5f52602052600160ff60405f2092161b8154189055565b63d4d8f3e65f526020526040526044601cfd5b8060ff1d81810118620d89e8811161451d5763ffffffff91600182167001fffcb933bd6fad37aa2d162d1a59400102700100000000000000000000000000000000189160028116614501575b600481166144e5575b600881166144c9575b601081166144ad575b60208116614491575b60408116614475575b60808116614459575b610100811661443d575b6102008116614421575b6104008116614405575b61080081166143e9575b61100081166143cd575b61200081166143b1575b6140008116614395575b6180008116614379575b62010000811661435d575b620200008116614342575b620400008116614327575b620800001661430e575b5f126142e7575b0160201c90565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff046142e0565b6b048a170391f7dc42444e8fa290910260801c906142d9565b6d2216e584f5fa1ea926041bedfe9890920260801c916142cf565b916e5d6af8dedb81196699c329225ee6040260801c916142c4565b916f09aa508b5b7a84e1c677de54f3e99bc90260801c916142b9565b916f31be135f97d08fd981231505542fcfa60260801c916142ae565b916f70d869a156d2a1b890bb3df62baf32f70260801c916142a4565b916fa9f746462d870fdf8a65dc1f90e061e50260801c9161429a565b916fd097f3bdfd2022b8845ad8f792aa58250260801c91614290565b916fe7159475a2c29b7443b29c7fa6e889d90260801c91614286565b916ff3392b0822b70005940c7a398e4b70f30260801c9161427c565b916ff987a7253ac413176f2b074cf7815e540260801c91614272565b916ffcbe86c7900a88aedcffc83b479aa3a40260801c91614268565b916ffe5dee046a99a2a811c461f1969c30530260801c9161425e565b916fff2ea16466c96a3843ec78b326b528610260801c91614255565b916fff973b41fa98c081472e6896dfb254c00260801c9161424c565b916fffcb9843d60f6159c9db58835c9266440260801c91614243565b916fffe5caca7e10e4e61c3624eaa0941cd00260801c9161423a565b916ffff2e50f5f656932ef12357cf3c7fdcc0260801c91614231565b916ffff97272373d413259a46990580e213a0260801c91614228565b63ce8ef7fc5f526004601cfd5b5f83600f0b125f1461456757916145629161330d93038060ff1d90810118905f036fffffffffffffffffffffffffffffffff16613f4d565b615a26565b906c010000000000000000000000006001916145ae946fffffffffffffffffffffffffffffffff1693038060ff1d908101186145a38185613f4d565b930915151601615a26565b5f0390565b915f81600f0b125f146145e357916145629161330d935f036fffffffffffffffffffffffffffffffff1691615ae0565b91614562916145ae936fffffffffffffffffffffffffffffffff1691615a3b565b01908160801c61303657565b9061461a91613d47565b9015613758576040015190565b61464a9061463c8360801d8260801d03613441565b92600f0b90600f0b03613441565b6fffffffffffffffffffffffffffffffff169060801b1790565b73fffd8963efd1fc6a506488495d951d51639616827ffffffffffffffffffffffffffffffffffffffffffffffffffffffffefffd895d8201116149935777ffffffffffffffffffffffffffffffffffffffff000000008160201b16806fffffffffffffffffffffffffffffffff811160071b90811c67ffffffffffffffff811160061b90811c63ffffffff811160051b90811c61ffff811160041b90811c9060ff821160031b91821c92600f841160021b93841c94600160038711811b96871c1196171717171717179060808210155f14614989577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8182011c5b800280607f1c8160ff1c1c800280607f1c8160ff1c1c800280607f1c8160ff1c1c800280607f1c8160ff1c1c800280607f1c8160ff1c1c800280607f1c8160ff1c1c80029081607f1c8260ff1c1c80029283607f1c8460ff1c1c80029485607f1c8660ff1c1c80029687607f1c8860ff1c1c80029889607f1c8a60ff1c1c80029a8b607f1c8c60ff1c1c80029c8d80607f1c9060ff1c1c800260cd1c6604000000000000169d60cc1c6608000000000000169c60cb1c6610000000000000169b60ca1c6620000000000000169a60c91c6640000000000000169960c81c6680000000000000169860c71c670100000000000000169760c61c670200000000000000169660c51c670400000000000000169560c41c670800000000000000169460c31c671000000000000000169360c21c672000000000000000169260c11c674000000000000000169160c01c67800000000000000016907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff800160401b1717171717171717171717171717693627a301d71055774c85027ffffffffffffffffffffffffffffffffffd709b7e5480fba5a50fed5e62ffc556810160801d60020b906fdb2df09e81959a81455e260799a0632f0160801d60020b918282145f146149465750905090565b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff61497a846141dc565b1611614984575090565b905090565b81607f031b61475e565b6331efafe85f526004601cfd5b81156149aa570490565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b905f6040516149e581612cc1565b5f815260208101905f825260408101955f875260608201945f865260808301915f83525f60a08501528398885493602084015115986fffffffffffffffffffffffffffffffff60038c015416928a155f14615a17575f610fff8860b81c16995b60408801518a52528673ffffffffffffffffffffffffffffffffffffffff1690528560a01c60020b905288155f14615a0c5760018a0154905b5260a085018190526080830151624000008116156159fd5762bfffff16614aa48161334e565b61ffff87166159dc57905b81945f604086015112928315978880996159cb575b6159a35760408701511561598d57505089615919576060850173ffffffffffffffffffffffffffffffffffffffff8151168273ffffffffffffffffffffffffffffffffffffffff168110156158d457505173ffffffffffffffffffffffffffffffffffffffff166401000276a38111156158a957505b60405160805260e060805101608051811067ffffffffffffffff821117610867576040525f608051525f602060805101525f604060805101525f606060805101525f6080805101525f60a060805101525f60c060805101525b8b5115801561586c575b61571c5773ffffffffffffffffffffffffffffffffffffffff60408d0151166080515260608c015160020b855160020b90815f818307129105038c8c155f1461548e575060ff8116918d60056001851b918460081d60010b5f52016020527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60405f209180010190541691821592831593845f146154595781955f91610330577ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff27618968370010000000000000000000000000000000060ff95101561544a575b508068010000000000000000600292101561543c575b64010000000081101561542e575b62010000811015615420575b610100811015615412575b6010811015615404575b60048110156153f7575b10156153ea575b031660020b900360020b0260020b5b905b15156040608051015260020b806020608051015213156153bd575b620d89e86020608051015160020b12156153ad575b8b73ffffffffffffffffffffffffffffffffffffffff604081614d3e6020608051015160020b6141dc565b169283606060805101520151169073ffffffffffffffffffffffffffffffffffffffff60608801511690818d158183101891180218908d6fffffffffffffffffffffffffffffffff60a08201511690519062ffffff8a169273ffffffffffffffffffffffffffffffffffffffff8516811015915f84125f146151f35784620f424003614dcc81865f03613fc7565b9684156151c157614dde838583615a3b565b955b8689106150c9575073ffffffffffffffffffffffffffffffffffffffff9750958691620f424082036150ba575050845b935b156150ac5791614e2b92038060ff1d9081011890613f4d565b905b60c0608051015260a060805101526080805101521660408d0152865f1461506c57614e5d60a06080510151615a26565b8c51038c5260208c01805190614e8261456260808051015160c0608051015190612ec5565b915f8382039312818412811691841390151617611d9157525b61ffff8816615039575b6fffffffffffffffffffffffffffffffff60a08d01511680615019575b5073ffffffffffffffffffffffffffffffffffffffff60408d01511673ffffffffffffffffffffffffffffffffffffffff606060805101511681145f14614fdb575060406080510151614f2a575b89156020608051015160020b0360020b60608d0152614b93565b89614fb2576fffffffffffffffffffffffffffffffff614f998d8d60808201519060046002820154915b6020608051015160020b60020b5f520160205260405f2091600183019081549003905560028201908154900390555460801d908d15614fa4575b60a001518316614604565b1660a08d0152614f10565b5f91909103600f0b90614f8e565b6fffffffffffffffffffffffffffffffff614f998d8d6001810154906004608084015191614f54565b73ffffffffffffffffffffffffffffffffffffffff60805151168103615002575b50614b93565b61500b90614664565b60020b60608d01525f614ffc565b6150299060c06080510151613e0a565b60808d019081510190525f614ec2565b97620f424060808051015161ffff8a169060c06080510151010204908160c060805101510360c060805101520197614ea5565b61508260808051015160c0608051015101615a26565b8c51018c5260208c016150a5815161509f60a06080510151615a26565b90613043565b9052614e9b565b6150b592615ae0565b614e2b565b6150c49187615b75565b614e10565b95505050809450158115176151b45773ffffffffffffffffffffffffffffffffffffffff948215615150576150ff908583615c13565b935b84808284861561511f5761511492615a3b565b8095015f0393614e12565b9050038060ff1d9081011860016c010000000000000000000000006151448386613f4d565b92850915151601615114565b61518c90615187908781116151925761517f906fffffffffffffffffffffffffffffffff88169060601b6149a0565b878416612ec5565b615ca1565b93615101565b6151af906fffffffffffffffffffffffffffffffff881690614052565b61517f565b634f2461b85f526004601cfd5b8084038060ff1d9081011860016c010000000000000000000000006151e68387613f4d565b9286091515160195614de0565b909491939291841561539c576152138682038060ff1d9081011883613f4d565b925b83811061528e57509073ffffffffffffffffffffffffffffffffffffffff956152599280965b1561525e579061524b9291615a3b565b809380620f42400391615b75565b614e2d565b6c0100000000000000000000000090600192038060ff1d908101186152838185613f4d565b93091515160161524b565b9250508181158615176151b45784156153725773ffffffffffffffffffffffffffffffffffffffff81116153195760601b6fffffffffffffffffffffffffffffffff82168082061515910401905b8186111561530c578573ffffffffffffffffffffffffffffffffffffffff615259938180991603165b809661523b565b634323a5555f526004601cfd5b6fffffffffffffffffffffffffffffffff8216615344816c0100000000000000000000000084614104565b9181156149aa576c010000000000000000000000009009615366575b906152dc565b60010180615360575f80fd5b9085615397615259938373ffffffffffffffffffffffffffffffffffffffff99615b9e565b615305565b6153a7828288615ae0565b92615215565b620d89e860206080510152614d13565b7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff2761860206080510152614cfe565b9060018391011690614cd2565b928101841692811c614ccb565b60049384018516931c614cc1565b60089384018516931c614cb7565b60109384018516931c614cac565b60209384018516931c614ca0565b60409384018516931c614c92565b60809350831c90506002614c7c565b50507ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff276189360020b900360020b0260020b614ce1565b90600101918260020b9260058160ff16938560081d60010b5f52016020527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff600160ff60405f2093161b011990541692831593841593845f146156e2578195610330577ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff276189560ff9283906fffffffffffffffffffffffffffffffff8116156156d8575050607f5b67ffffffffffffffff8216156156ce577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc00183165b63ffffffff8216156156c4577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe00183165b61ffff8216156156ba577ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00183165b818416156156b0577ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff80183165b600f8216156156a6577ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc0183165b600382161561569a57837ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe6001920116915b16615671575b031660020b0160020b0260020b5b90614ce3565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff01821661565d565b9060019060021c615657565b9060041c90615625565b9060081c906155f7565b9060101c906155ca565b9060201c9061559b565b9060401c9061556a565b60801c9150615535565b7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff27618955060ff809250031660020b0160020b0260020b61566b565b91955091999698929550969296606087015160a01b76ffffff0000000000000000000000000000000000000000167fffffffffffffffffff000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff60408a0151169216171782556fffffffffffffffffffffffffffffffff60a087015116809103615827575b50811561581857600260808601519101555b15146157fb576157e160406157d56020850151613441565b92015183519003613441565b6fffffffffffffffffffffffffffffffff169060801b1793565b60400151815161580b9103613441565b6157e16020830151613441565b600160808601519101556157bd565b6fffffffffffffffffffffffffffffffff167fffffffffffffffffffffffffffffffff000000000000000000000000000000006003830154161760038201555f6157ab565b5073ffffffffffffffffffffffffffffffffffffffff60408d01511673ffffffffffffffffffffffffffffffffffffffff60608701511614614b9d565b7f9e4d7cc7000000000000000000000000000000000000000000000000000000005f5260045260245ffd5b827f7c9c6e8f000000000000000000000000000000000000000000000000000000005f5273ffffffffffffffffffffffffffffffffffffffff1660045260245260445ffd5b6060850173ffffffffffffffffffffffffffffffffffffffff8151168273ffffffffffffffffffffffffffffffffffffffff168111156158d457505173ffffffffffffffffffffffffffffffffffffffff1673fffd8963efd1fc6a506488495d951d5263988d268110156158a95750614b3a565b9a509a50505050975050505050505f925f929190565b7f96206246000000000000000000000000000000000000000000000000000000005f5260045ffd5b50620f424062ffffff831614614ac4565b8061ffff881602620f424080820615159104019061ffff8816010390614aaf565b508360d01c62ffffff16614aa4565b60028a015490614a7e565b5f610fff8860c41c1699614a45565b5f81121561330d576393dafdf15f526004601cfd5b9173ffffffffffffffffffffffffffffffffffffffff821673ffffffffffffffffffffffffffffffffffffffff841611615ad8575b8215615acc5773ffffffffffffffffffffffffffffffffffffffff91615abf917bffffffffffffffffffffffffffffffff00000000000000000000000084868185169403169160601b16615b75565b9116808206151591040190565b62bfc9215f526004601cfd5b919091615a70565b9073ffffffffffffffffffffffffffffffffffffffff811673ffffffffffffffffffffffffffffffffffffffff831611615b6f575b8115615acc57615b6773ffffffffffffffffffffffffffffffffffffffff9161330d947bffffffffffffffffffffffffffffffff00000000000000000000000084868185169403169160601b16614104565b9116906149a0565b90615b15565b929190615b83828286614104565b9382156149aa5709615b9157565b9060010190811561033057565b908215615c0d577bffffffffffffffffffffffffffffffff0000000000000000000000009060601b1673ffffffffffffffffffffffffffffffffffffffff82169283810292838311918404141615615c005761330d9261518792820391615b75565b63f5c787f15f526004601cfd5b50905090565b90918015615c0d5773ffffffffffffffffffffffffffffffffffffffff7bffffffffffffffffffffffffffffffff000000000000000000000000819460601b16921680820281615c6384836149a0565b14615c89575b5090615c78615c7d92846149a0565b612ec5565b80820615159104011690565b8301838110615c69579150615c9d92615b75565b1690565b740100000000000000000000000000000000000000008110156130365773ffffffffffffffffffffffffffffffffffffffff169056fea26469706673582212206cdb38c1d8509f6bd20bb1a66e49983e35dea09f2c8d6d2b81e8e58527c8ac7f64736f6c634300081a0033
    /// ```
    #[rustfmt::skip]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\xC04`\x9DW`\x1Fa]\xC38\x81\x90\x03\x91\x82\x01`\x1F\x19\x16\x83\x01\x91`\x01`\x01`@\x1B\x03\x83\x11\x84\x84\x10\x17`\xA1W\x80\x84\x92` \x94`@R\x839\x81\x01\x03\x12`\x9DWQ_\x80T`\x01`\x01`\xA0\x1B\x03\x19\x163\x90\x81\x17\x82U`@Q\x92\x91\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0\x81\x80\xA3`\x80R0`\xA0Ra]\r\x90\x81a\0\xB6\x829`\x80Q\x81a7\x8B\x01R`\xA0Q\x81a1\xE4\x01R\xF3[_\x80\xFD[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD\xFE`\xA0\x80`@R`\x046\x10\x15a\0\x12W_\x80\xFD[_5`\xE0\x1C\x90\x81b\xFD\xD5\x8E\x14a+\xA0WP\x80c\x01\xFF\xC9\xA7\x14a*\xE1W\x80c\x07\xEF\xF0\xDD\x14a*\xA8W\x80c\t[\xCD\xB6\x14a)\xFEW\x80c\x0B\r\x9C\t\x14a)pW\x80c\x15n)\xF6\x14a(\xC0W\x80c\x1E.\xAE\xAF\x14a(\x86W\x80c#Bf\xD7\x14a&\x0FW\x80c-w\x13\x89\x14a%FW\x80c5\xFDc\x1A\x14a$\xE0W\x80cBj\x84\x93\x14a$\\W\x80cH\xC8\x94\x91\x14a!\xFFW\x80cRu\x96Q\x14a \xE7W\x80cU\x8Ar\x97\x14a \x10W\x80cY\x8A\xF9\xE7\x14a\x1FxW\x80cZk\xCF\xDA\x14a\x14\xBAW\x80c`F\x0F\x06\x14a\x14\x80W\x80ci\\[\xF5\x14a\x0FUW\x80cj%k)\x14a\r\xF3W\x80c~\x87\xCE}\x14a\x0C\xC4W\x80c\x81a\xB8t\x14a\x0B\xCCW\x80c\x8D\xA5\xCB[\x14a\x0B|W\x80c\x97\xE8\xCDN\x14a\x0B\x19W\x80c\x9B\xF6d_\x14a\n\xDDW\x80c\xA5\x84\x11\x94\x14a\n\x9CW\x80c\xB66<\xF2\x14a\n\x0BW\x80c\xDB\xD05\xFF\x14a\t\xCBW\x80c\xF0-\xE3\xB2\x14a\tzW\x80c\xF15\xBA\xAA\x14a\t@W\x80c\xF2\xFD\xE3\x8B\x14a\x08\x94W\x80c\xF3\xCD\x91L\x14a\x05\x01W\x80c\xF5)\x8A\xCA\x14a\x034Wc\xFE\x99\x04\x9A\x14a\x01\x86W_\x80\xFD[4a\x030W`\x80\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030Wa\x01\xBDa,\nV[a\x01\xC5a,-V[\x90`D5\x91\x7F\x1B=~\xDB.\x9C\x0B\x0E|R[ \xAA\xAE\xF0\xF5\x94\r.\xD7\x16c\xC7\xD3\x92f\xEC\xAF\xACr\x88Ya\x02ys\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80`d5\x95\x16\x93\x843\x14\x15\x80a\x03\rW[a\x02\x87W[\x84_R`\x04` R`@_ \x87_R` R`@_ a\x02:\x87\x82Ta.\xB8V[\x90U\x16\x93\x84_R`\x04` R`@_ \x86_R` R`@_ a\x02_\x82\x82Ta.\xC5V[\x90U`@\x80Q3\x81R` \x81\x01\x92\x90\x92R\x90\x91\x82\x91\x82\x01\x90V[\x03\x90\xA4` `@Q`\x01\x81R\xF3[\x84_R`\x05` R`@_ \x823\x16_R` R`@_ \x87_R` R`@_ T\x86\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x03a\x02\xDAW[PPa\x02\x19V[a\x02\xE3\x91a.\xB8V[\x85_R`\x05` R`@_ \x833\x16_R` R`@_ \x88_R` R`@_ U_\x86a\x02\xD3V[P\x84_R`\x03` R`@_ \x823\x16_R` R`\xFF`@_ T\x16\x15a\x02\x14V[_\x80\xFD[4a\x030Wa\x03B6a,PV[\x7F\xC0\x90\xFCF\x83bL\xFC8\x84\xE9\xD8\xDE^\xCA\x13/-\x0E\xC0b\xAF\xF7]C\xC0F]\\\xEE\xAB#\x92\x91\x92\\\x15a\x04\xD9W\x7F\x1B=~\xDB.\x9C\x0B\x0E|R[ \xAA\xAE\xF0\xF5\x94\r.\xD7\x16c\xC7\xD3\x92f\xEC\xAF\xACr\x88Ya\x03\xEFs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF_\x94a\x03\xBDa\x03\xB3\x86a0\x18V[3\x90\x84\x8A\x16a0^V[\x16\x923\x84\x14\x15\x80a\x04\xA2W[a\x03\xF4W[\x83\x85R`\x04` R`@\x85 \x86\x86R` R`@\x85 a\x02_\x82\x82Ta.\xB8V[\x03\x90\xA4\0[\x83\x85R`\x05` R`@\x85 s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x16\x86R` R`@\x85 \x86\x86R` R`@\x85 T\x81\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x03a\x04[W[PPa\x03\xCEV[a\x04d\x91a.\xB8V[\x84\x86R`\x05` R`@\x86 s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x16\x87R` R`@\x86 \x87\x87R` R`@\x86 U\x86\x81a\x04TV[P\x83\x85R`\x03` R`@\x85 s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x16\x86R` R`\xFF`@\x86 T\x16\x15a\x03\xC9V[\x7FT\xE3\xCA\r\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[4a\x030Wa\x01 \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030Wa\x05:6a-LV[``\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\\6\x01\x12a\x030W`@Q\x90``\x82\x01\x82\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x08gW`@R`\xA45\x80\x15\x15\x81\x03a\x030W\x82R` \x82\x01\x90`\xC45\x82R`\xE45\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x82\x03a\x030W`@\x84\x01\x91\x82Ra\x01\x045g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x030Wa\x05\xE3\x906\x90`\x04\x01a.\x18V[\x94\x90\x93\x7F\xC0\x90\xFCF\x83bL\xFC8\x84\xE9\xD8\xDE^\xCA\x13/-\x0E\xC0b\xAF\xF7]C\xC0F]\\\xEE\xAB#\\\x15a\x04\xD9Wa\x06\x15a1\xCDV[Q\x15a\x08?W\x81\x90`\xA0\x82 \x95\x86_R`\x06` R`@_ \x95a\x068\x87a24V[`\x80\x84\x01\x96\x84\x83\x83\x86\x8BQs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x93a\x06c\x94a9\x96V[\x90\x95\x91\x98``\x88\x01Q`\x02\x0B\x99\x83Q\x15\x15\x91Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x91`@Q\x9Ba\x06\x9A\x8Da,\xDDV[\x8CR` \x8C\x01R`@\x8B\x01R``\x8A\x01Rb\xFF\xFF\xFF\x16`\x80\x89\x01R\x80Q\x15\x15_\x14\x99\x7F@\xE9\xCE\xCB\x9F_\x1F\x1C[\x9C\x97\xDE\xC2\x91{~\xE9.W\xBAUcp\x8D\xAC\xA9M\xD8J\xD7\x11/`\xE0b\xFF\xFF\xFFa\x07\x13a\x07\xBF\x9C` \x9F\x9Ba\x07\xAC\x9Ca\x08\x1FWQs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x97aI\xD7V[\x93\x92\x98\x82\x91\x92a\x07\xF0W[PPs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@\x84\x01Q\x16\x92``o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\xA0\x83\x01Q\x16\x91\x01Q`\x02\x0B\x90`@Q\x943\x86R\x8A`\x80\x1D`\x0F\x0B` \x87\x01R\x8A`\x0F\x0B`@\x87\x01R``\x86\x01R`\x80\x85\x01R`\xA0\x84\x01R\x16`\xC0\x82\x01R\xA2\x86s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x8AQ\x16a;\xA3V[\x80\x94\x91\x94a\x07\xC7W[PP\x823\x91a3\x10V[`@Q\x90\x81R\xF3[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x07\xE9\x92Q\x16\x90\x83a3\x10V[\x84\x80a\x07\xB5V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16_R` `\x01\x90R`@_ \x90\x81T\x01\x90U_\x80a\x07\x1EV[` \x01Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x97aI\xD7V[\x7F\xBE\x8B\x85\x07\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`A`\x04R`$_\xFD[4a\x030W` \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030W\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x08\xECa,\nV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF_T\x91a\t\x11\x82\x84\x163\x14a.\xD2V[\x16\x91\x82\x91\x16\x17_U3\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0_\x80\xA3\0[4a\x030W` \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030W`\x045\\_R` _\xF3[4a\x030W_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030W` s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x02T\x16`@Q\x90\x81R\xF3[4a\x030Wa\t\xD96a.FV[`@`\x04_7`\x05\x1B`@\x01\x80\x91` \x80`@[\x835T\x81R\x01\x91\x01\x90\x82\x81\x10\x15a\n\x07W` \x80\x91a\t\xEDV[\x82_\xF3[4a\x030W`@\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030Wa\nBa,\nV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\n_a,-V[\x91\x16_R`\x03` Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ \x91\x16_R` R` `\xFF`@_ T\x16`@Q\x90\x15\x15\x81R\xF3[4a\x030W` \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030W` a\x07\xBFa\n\xD8a,\nV[a/\xAFV[4a\x030Wa\n\xEB6a.FV[`@`\x04_7`\x05\x1B`@\x01\x80\x91` \x80`@[\x835\\\x81R\x01\x91\x01\x90\x82\x81\x10\x15a\n\x07W` \x80\x91a\n\xFFV[4a\x030W` \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x0Bea,\nV[\x16_R`\x01` R` `@_ T`@Q\x90\x81R\xF3[4a\x030W_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030W` s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF_T\x16`@Q\x90\x81R\xF3[4a\x030W``\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030Wa\x0C\x03a,\nV[a\x0C\x0Ba,-V[\x90`D5s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x02T\x163\x03a\x0C\x9CW` \x92a\x07\xBF\x91\x80a\x0C\x94WPs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16_R`\x01\x84R`@_ T\x92\x83\x91[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16_R`\x01\x86R`@_ a\x0C\x8D\x84\x82Ta.\xB8V[\x90Ua1NV[\x92\x83\x91a\x0CaV[\x7FH\xF5\xC3\xED\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[4a\x030W`\xC0\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030Wa\x0C\xFC6a-LV[a\r\x04a-:V[\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x02T\x163\x03a\x0C\x9CWb>\x90\0\x82\x10a\x03\xE9a\x0F\xFF\x84\x16\x10\x16\x15a\r\xCBW` `\xA0\x7F\xE9\xC4%\x93\xE7\x1F\x84@;\x845,\xD1h\xD6\x93\xE2\xC9\xFC\xD1\xFD\xBC\xC3\xFE\xB2\x1D\x92\xB4>f\x96\xF9\x92 \x92\x83_R`\x06\x82R`@_ a\ru\x81a24V[\x80Ty\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x83`\xB8\x1B\x16\x90\x7F\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x17\x90Ub\xFF\xFF\xFF`@Q\x91\x16\x81R\xA2\0[\x7F\xBA\x97\xF88\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[` \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030Wa\x0E%a,\nV[\x7F\xC0\x90\xFCF\x83bL\xFC8\x84\xE9\xD8\xDE^\xCA\x13/-\x0E\xC0b\xAF\xF7]C\xC0F]\\\xEE\xAB#\\\x15a\x04\xD9Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16a\x0E\x80W` \x90a\x07\xBF4\x91[a\x0Ey\x83a0\x18V[3\x91a0^V[4a\x0F-W\x7F\x1E\x07E\xA7\xDB\x16#\x98\x1F\x0B*]B26L\0xrf\xEBu\xADTo\x19\x0El\xEB\xE9\xBD\x95_R\x80` R`@_ \\\x90\x81\x15a\x0F\x05W\x81\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF` \x93\x14a\x0E\xFEW[a\x0E\xF8a\x07\xBF\x91a\x0E\xF3\x84a/\xAFV[a.\xB8V[\x91a\x0EpV[P_a\x0E\xE3V[\x7F\x87t\xBEH\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x7F\x19\xD2E\xCF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[4a\x030W`\xE0\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030Wa\x0F\x8D6a-LV[`\xA45s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x80\x82\x03a\x030W`\xC45g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x030Wa\x0F\xCE\x906\x90`\x04\x01a.\x18V[a\x0F\xD6a1\xCDV[``\x85\x01\x92a\x7F\xFF\x84Q`\x02\x0B\x13a\x14XW`\x01\x84Q`\x02\x0B\x12a\x140Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x86Q\x16\x92` \x87\x01\x93s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x85Q\x16\x11\x15a\x14\x08W`\x80\x87\x01\x94s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x86Q\x16\x95`@\x89\x01\x96a\x10cb\xFF\xFF\xFF\x89Q\x16\x82a6\x82V[\x15a\x13\xDDWPa\x10xb\xFF\xFF\xFF\x88Q\x16a7@V[\x93\x81Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x90\x813\x03a\x13\x19W[PP`\xA0\x8A \x93a\x10\xAB\x8Ba7]V[\x9A\x90P\x85_R`\x06` R`@_ \x90\x81Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x12\xF1Wa\x10\xE0\x90aFdV[\x9A\x8B\x97`\xD0\x1B|\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90\x84\x89`\xA0\x1Bv\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x17\x90`\xB8\x1By\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x17\x17\x90U\x82Q\x91s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x16\x92\x833\x14\x15\x9C\x7F?\xD5S\xDBD\xF2\x07\xB1\xF4\x13H\xCF\xC4\xD2Q\x86\x08\x14\xAF\x9E\xAD\xC4p\xE8\xE7\x89^M\x12\x05\x11\xF4\x99`\x80\x99` \x9F\x96b\xFF\xFF\xFF\x96s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x98\x96\x89\x97\x96\x88\x97a\x11\xEFW[PPPPPPQ\x16\x98Q\x16\x98Q\x16\x92Q`\x02\x0B\x91Q\x16\x91`@Q\x93\x84R\x89\x84\x01R`@\x83\x01R``\x82\x01R\xA3`@Q\x90`\x02\x0B\x81R\xF3[a\x10\0\x16a\x11\xFEW[\x80a\x11\xB8V[a\x12\xB5a\x12\xE1\x92a\x12\xE6\x96`@Q\x96` \x94\x7F\xA9\x10\xF8\x0F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x89\x96\x87\x01R3`$\x87\x01Ra\x12\x93`D\x87\x01\x8Cs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x80\x92\x82\x81Q\x16\x85R\x82` \x82\x01Q\x16` \x86\x01Rb\xFF\xFF\xFF`@\x82\x01Q\x16`@\x86\x01R``\x81\x01Q`\x02\x0B``\x86\x01R\x01Q\x16\x91\x01RV[`\xE4\x86\x01R`\x02\x0Ba\x01\x04\x85\x01Ra\x01 a\x01$\x85\x01Ra\x01D\x84\x01\x91a/qV[\x03\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x81\x01\x84R\x83a,\xF9V[a=GV[P\x8E\x8D\x81\x80\x80a\x11\xF8V[\x7Fy\x83\xC0Q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[a \0\x16a\x13(W[\x80a\x10\x9BV[a\x13\xD6\x90`@Q\x90\x7F4@\xD8 \0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x83\x01R3`$\x83\x01Ra\x13\xB4\x8D`D\x84\x01\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x80\x92\x82\x81Q\x16\x85R\x82` \x82\x01Q\x16` \x86\x01Rb\xFF\xFF\xFF`@\x82\x01Q\x16`@\x86\x01R``\x81\x01Q`\x02\x0B``\x86\x01R\x01Q\x16\x91\x01RV[\x83`\xE4\x83\x01Ra\x01\0a\x01\x04\x83\x01Ra\x12\xE1\x82a\x12\xB5a\x01$\x82\x01\x8C\x8Ba/qV[P\x8Aa\x13\"V[\x7F\xE6Z\xF6\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04R`$_\xFD[\x7F\xEA\xA6\xC6\xEB\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x7F\x16\xFEv\x96\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x7F\xB0+]\xC2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[4a\x030W_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030W` `@Qa\x7F\xFF\x81R\xF3[4a\x030Wa\x01@\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030Wa\x14\xF36a-LV[`\x80\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\\6\x01\x12a\x030W`@Q\x90a\x15*\x82a,\xA5V[`\xA45\x80`\x02\x0B\x81\x03a\x030W\x82R`\xC45\x80`\x02\x0B\x81\x03a\x030W` \x83\x01R`\xE45`@\x83\x01R``\x82\x01\x91a\x01\x045\x83Ra\x01$5g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x030Wa\x15\x7F\x906\x90`\x04\x01a.\x18V[\x90\x7F\xC0\x90\xFCF\x83bL\xFC8\x84\xE9\xD8\xDE^\xCA\x13/-\x0E\xC0b\xAF\xF7]C\xC0F]\\\xEE\xAB#\\\x15a\x04\xD9Wa\x15\xAFa1\xCDV[`\xA0\x84 \x91\x82_R`\x06` R`@_ \x91a\x15\xCA\x83a24V[`\x80\x86\x01Q\x85s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x91\x823\x03a\x1E\x9AW[P\x90PQ`\x02\x0B\x93` \x86\x01Q`\x02\x0B\x95a\x16\x0E`@\x82\x01Qa4AV[\x96``\x89\x01Q`\x02\x0B\x99Q`@Q\x9Aa\x16&\x8Ca,\xC1V[3\x8CR\x88` \x8D\x01R\x82`@\x8D\x01R\x89`\x0F\x0B``\x8D\x01R`\x80\x8C\x01R`\xA0\x8B\x01R_\x90\x80\x88\x12\x15a\x1EkW\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xF2v\x18\x88\x12a\x1E?Wb\r\x89\xE8\x81\x13a\x1E\x14W`@Q\x98a\x16\x90\x8Aa,\xA5V[_\x8AR_` \x8B\x01R_`@\x8B\x01R_``\x8B\x01R\x80`\x0F\x0Ba\x1B;W[`\x04\x88\x01\x98\x80`\x02\x0B_R\x89` R`@_ \x99\x83`\x02\x0B_R` R`@_ \x89T`\xA0\x1C`\x02\x0B\x82\x81\x12_\x14a\x1A\xE9WP`\x02\x80`\x01\x8D\x01T`\x01\x84\x01T\x90\x03\x9C\x01T\x91\x01T\x90\x03\x9C[`\xA0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82Q\x16\x91\x01Q`&R\x83`\x06R\x81`\x03R_R`:`\x0C _`&R_R`\x06\x89\x01` R`@_ \x98o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x8AT\x16\x9A\x83`\x0F\x0B\x15_\x14a\x1A\x8CW\x8B\x15a\x1AdWa\x17\xA5`@\x9Fa\x18y\x9Ca\x17\x9F\x91a\x18\x8B\x9F[`\x01\x83\x01\x95a\x17\x97`\x02a\x17\x8B\x84\x8AT\x85\x03a>\xCBV[\x95\x01\x92\x83T\x85\x03a>\xCBV[\x96UUa0\x18V[\x91a0\x18V[o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90`\x80\x1B\x17\x9B_\x84`\x0F\x0B\x12a\x19\xFAW[P\x82`\x0F\x0Ba\x18\xC3W[PPPPa\x17\xF9a\x17\xEA\x89`\x80\x1D\x83`\x80\x1D\x01a4AV[\x91\x89`\x0F\x0B\x90`\x0F\x0B\x01a4AV[o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90`\x80\x1B\x17\x91\x81Q`\x02\x0B\x90` \x83\x01Q`\x02\x0B\x8B\x84\x01Q\x90\x8CQ\x93\x84R` \x84\x01R\x8B\x83\x01R\x7FT\x1C\x04\x1C,\xCEH\xE6\x14\xB3\xDE\x04<\x92\x80\xF0kad\xC0\xA1t\x16I\xE2\xDE<=7_yt``3\x93\xA3\x87s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x82\x01Q\x16a50V[\x80\x94\x91\x94a\x18\x97W[P\x833\x91a3\x10V[\x82Q\x91\x82R` \x82\x01R\xF3[a\x18\xBD\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x84\x01Q\x16\x90\x83a3\x10V[\x85a\x18\x82V[\x80\x91\x92\x93\x94PT\x80`\xA0\x1C`\x02\x0B\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90\x83\x81\x12_\x14a\x19+WPPP\x91a\x19\x19\x91a\x19\x13a\x19\ta\x19\x1E\x95aA\xDCV[\x91`\x0F\x0B\x92aA\xDCV[\x90aE\xB3V[a4AV[`\x80\x1B[\x8A\x80\x80\x80a\x17\xD2V[\x94\x80\x91\x93\x92\x95\x12_\x14a\x19\xC6Wo\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x92a\x19\x83a\x19\x19a\x19\x99\x94a\x19pa\x19\x19`\x03\x96a\x19j\x8B`\x0F\x0B\x91aA\xDCV[\x87aE\xB3V[\x93a\x19~\x89`\x0F\x0B\x92aA\xDCV[aE*V[\x84\x16\x90`\x80\x1B\x17\x94\x01\x92`\x0F\x0B\x82\x84T\x16aF\x04V[\x16\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82T\x16\x17\x90Ua\x19\"V[\x91Pa\x19\xE3\x93P\x91a\x19\xDDa\x19\ta\x19\x19\x94aA\xDCV[\x90aE*V[o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x19\"V[\x80\x8F\x91Qa\x1A:W[\x01Qa\x1A\x10W[\x8Ea\x17\xC8V[a\x1A5\x84\x82`\x04\x91`\x02\x0B_R\x01` R_`\x02`@\x82 \x82\x81U\x82`\x01\x82\x01U\x01UV[a\x1A\nV[a\x1A_\x84\x84`\x04\x91`\x02\x0B_R\x01` R_`\x02`@\x82 \x82\x81U\x82`\x01\x82\x01U\x01UV[a\x1A\x03V[\x7F\xAE\xFE\xB9$\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[a\x17\xA5`@\x9Fa\x18y\x9Ca\x17\x9F\x91a\x18\x8B\x9Fo\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x1A\xBC\x8A`\x0F\x0B\x83aF\x04V[\x16\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x84T\x16\x17\x83Ua\x17tV[\x90\x9A\x90\x84\x13a\x1B\x0FW`\x02\x80`\x01\x8D\x01T`\x01\x84\x01T\x90\x03\x9C\x01T\x91\x01T\x90\x03\x9Ca\x16\xFAV[\x99`\x02`\x01\x8B\x01T`\x01\x8D\x01T\x90\x03`\x01\x83\x01T\x90\x03\x9B\x81\x80\x8D\x01T\x91\x01T\x90\x03\x91\x01T\x90\x03\x9Ca\x16\xFAV[\x88`\x02\x0B_R`\x04\x88\x01` R\x88o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ \x80T\x90a\x1B\x95\x83\x83\x16\x92\x8Da\x1Bv\x88`\x0F\x0B\x86aF\x04V[\x94\x15\x96\x87\x87\x87\x16\x15\x14\x15\x97a\x1D\xE5W[PP\x86`\x0F\x0B\x90`\x80\x1Da;\\V[`\x80\x1B\x82\x17\x90U\x16` \x8C\x01R\x8AR\x81`\x02\x0B_R`\x04\x88\x01` R`@_ \x80T\x90o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16a\x1B\xD8\x84`\x0F\x0B\x82aF\x04V[\x90\x15\x92\x83o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x16\x15\x14\x15\x93a\x1D\xBEW[\x84`\x0F\x0B\x90`\x80\x1D`\x0F\x0B\x03\x91o\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x13\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x84\x12\x17a\x1D\x91W\x82o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x93P`\x80\x1B\x82\x17\x90U\x16``\x8C\x01R`@\x8B\x01R\x89\x8C_\x83`\x0F\x0B\x12\x15a\x1C\xB9W[PQa\x1C\x9FW[`@\x8A\x01Q\x15a\x16\xAEWa\x1C\x9A`\x80\x8D\x01Q`\x02\x0B\x83`\x05\x8B\x01aA\xA3V[a\x16\xAEV[a\x1C\xB4`\x80\x8D\x01Q`\x02\x0B\x8A`\x05\x8B\x01aA\xA3V[a\x1C{V[`\x01o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF` `\x80\x82\x94\x01Q`\x02\x0B\x94\x01Q\x16\x92\x80\x80\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xF2v\x18\x05\x02\x81\x80b\r\x89\xE8\x05\x02\x03\x05\x01\x81\x04\x16\x80\x91\x11a\x1DeWo\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF``\x8C\x01Q\x16\x11a\x1D9W\x89\x8Ca\x1CtV[P\x7F\xB8\xE3\xC3\x85\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04R`$_\xFD[\x89\x7F\xB8\xE3\xC3\x85\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04R`$_\xFD[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x11`\x04R`$_\xFD[\x8BT`\xA0\x1C`\x02\x0B\x86\x13a\x1B\xF8W`\x01\x8C\x01T`\x01\x84\x01U`\x02\x8C\x01T`\x02\x84\x01Ua\x1B\xF8V[\x81T`\xA0\x1C`\x02\x0B\x12\x15a\x1D\xFAW[\x8Fa\x1B\x86V[\x80`\x01`\x02\x92\x01T`\x01\x86\x01U\x01T`\x02\x84\x01U\x8Da\x1D\xF4V[\x7F\x1A\xD7w\xF8\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04R`$_\xFD[\x87\x7F\xD5\xE2\xF7\xAB\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04R`$_\xFD[\x87\x7F\xC4C>\xD5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04R`$R`D_\xFD[_`@\x83\x01Q\x13\x80\x80\x91a\x1FkW[\x15a\x1E\xFDWPPa\x1E\xF3\x91a\x12\xE1\x89a\x12\xB5\x87\x87`@Q\x96\x87\x94\x7F%\x99\x82\xE5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x87\x01R3`$\x87\x01a3\x87V[P[\x87\x85\x81a\x15\xF0V[\x15\x90\x81a\x1F]W[Pa\x1F\x12W[PPa\x1E\xF5V[a\x1FU\x91a\x12\xE1\x89a\x12\xB5\x87\x87`@Q\x96\x87\x94\x7F!\xD0\xEEp\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x87\x01R3`$\x87\x01a3\x87V[P\x87\x85a\x1F\x0BV[a\x02\0\x91P\x16\x15\x15\x8Aa\x1F\x05V[Pa\x08\0\x82\x16\x15\x15a\x1E\xA9V[4a\x030W``\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030Wa\x1F\xAFa,\nV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x1F\xCCa,-V[\x91\x16_R`\x05` Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ \x91\x16_R` R`@_ `D5_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x030W`@\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030Wa Ga,\nV[`$5\x90\x81\x15\x15\x80\x92\x03a\x030Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x903_R`\x03` R`@_ \x82\x82\x16_R` R`@_ \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\x81T\x16`\xFF\x85\x16\x17\x90U`@Q\x92\x83R\x16\x90\x7F\xCE\xB5v\xD9\xF1^N \x0F\xDBP\x96\xD6M]\xFDf~\x16\xDE\xF2\x0C\x1E\xEF\xD1BV\xD8\xE3\xFA\xA2g` 3\x92\xA3` `@Q`\x01\x81R\xF3[4a\x030W`\xC0\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030Wa!\x1F6a-LV[a!'a-:V[\x90b\x80\0\0b\xFF\xFF\xFF`@\x83\x01Q\x16\x14\x80\x15\x90a!\xDBW[a!\xB3W`\xA0\x90a!O\x83a3NV[ _R`\x06` R`@_ \x90a!e\x82a24V[\x81T\x7F\xFF\xFF\xFF\0\0\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\xD0\x91\x90\x91\x1B|\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x17\x90U\0[\x7F0\xD2\x16A\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[Ps\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x82\x01Q\x163\x14\x15a!?V[4a\x030W` \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030W`\x045g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x030Wa\"N\x906\x90`\x04\x01a.\x18V[\x7F\xC0\x90\xFCF\x83bL\xFC8\x84\xE9\xD8\xDE^\xCA\x13/-\x0E\xC0b\xAF\xF7]C\xC0F]\\\xEE\xAB#\\a$4Wa\"\xDA\x91_\x91`\x01\x7F\xC0\x90\xFCF\x83bL\xFC8\x84\xE9\xD8\xDE^\xCA\x13/-\x0E\xC0b\xAF\xF7]C\xC0F]\\\xEE\xAB#]`@Q\x93\x84\x92\x83\x92\x7F\x91\xDDsF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x84R` `\x04\x85\x01R`$\x84\x01\x91a/qV[\x03\x81\x833Z\xF1\x90\x81\x15a$)W_\x91a#\xAFW[P\x7F}K1d\xC6\xE4[\x97\xE7\xD8{q%\xA4LX(\xD0\x05\xAF\x88\xF9\xD7Q\xCF\xD7\x87)\xC5\xD9\x9A\x0B\\a#\x87W`@` \x91_\x7F\xC0\x90\xFCF\x83bL\xFC8\x84\xE9\xD8\xDE^\xCA\x13/-\x0E\xC0b\xAF\xF7]C\xC0F]\\\xEE\xAB#]\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0`\x1F\x83Q\x94\x85\x93\x81\x85R\x80Q\x91\x82\x91\x82\x82\x88\x01R\x01\x86\x86\x01^_\x85\x82\x86\x01\x01R\x01\x16\x81\x01\x03\x01\x90\xF3[\x7FR\x12\xCB\xA1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x90P=\x80_\x83>a#\xC0\x81\x83a,\xF9V[\x81\x01\x90` \x81\x83\x03\x12a\x030W\x80Q\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x030W\x01\x81`\x1F\x82\x01\x12\x15a\x030W\x80Q\x90a#\xF7\x82a/7V[\x92a$\x05`@Q\x94\x85a,\xF9V[\x82\x84R` \x83\x83\x01\x01\x11a\x030W\x81_\x92` \x80\x93\x01\x83\x86\x01^\x83\x01\x01R\x81a\"\xEEV[`@Q=_\x82>=\x90\xFD[\x7FP\x90\xD6\xC6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[4a\x030Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa$\x7F6a,PV[\x91\x92\x90\x923_R`\x05` R`@_ \x82\x82\x16_R` R`@_ \x84_R` R\x82`@_ U`@Q\x92\x83R\x16\x90\x7F\xB3\xFDPq\x83X\x87Vz\x06q\x15\x11!\x89M\xDC\xCC(B\xF1\xD1\x0B\xED\xAD\x13\xE0\xD1|\xAC\xE9\xA7` 3\x92\xA4` `@Q`\x01\x81R\xF3[4a\x030W`@\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030W`\x045` _R`$5`\x05\x1B\x80` R`@\x01\x80\x91`\x01` `@[\x83T\x81R\x01\x91\x01\x90\x82\x81\x10\x15a\n\x07W` `\x01\x91a%,V[4a\x030W` \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030W`\x045s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x80\x91\x03a\x030W` \x7F\xB4\xBD\x8E\xF5=\xF6\x90\xB9\x94=3\x18\x99`\x06\xDB\xB8*%\xF5G\x19\xD8\xC8\x03[Qj*[\x8A\xCC\x91a%\xDCs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF_T\x163\x14a.\xD2V[\x80\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x02T\x16\x17`\x02U`@Q\x90\x81R\xA1\0[4a\x030Wa\x01\0\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030Wa&H6a-LV[`\xC45\x90`\xA45`\xE45g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x030Wa&o\x906\x90`\x04\x01a.\x18V[\x91\x90\x93\x7F\xC0\x90\xFCF\x83bL\xFC8\x84\xE9\xD8\xDE^\xCA\x13/-\x0E\xC0b\xAF\xF7]C\xC0F]\\\xEE\xAB#\\\x15a\x04\xD9Wa&\xA1a1\xCDV[`\xA0\x84 _R`\x06` R`@_ \x94a&\xBA\x86a24V[`\x80\x85\x01\x94\x85Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x90\x813\x03a(.W[PPo\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x03\x88\x01T\x16\x95\x86\x15a(\x06W` \x97a'\r\x86a0\x18V[_\x03a'\x18\x86a0\x18V[_\x03o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90`\x80\x1B\x17\x97\x86a'\xEDW[\x85a'\xD2W[PPa'K3\x88\x84a3\x10V[Q\x92s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x84\x16\x93\x843\x03a'wW[\x88\x88`@Q\x90\x81R\xF3[`\x10\x16a'\x85W[\x80a'mV[a'\xC6\x95a\x12\xE1\x93a\x12\xB5\x92`@Q\x97\x88\x95\x7F\xE1\xB4\xAFi\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x8D\x88\x01R3`$\x88\x01a2zV[P\x82\x80\x80\x80\x80\x80a'\x7FV[a'\xDE`\x02\x91\x87a>\nV[\x91\x01\x90\x81T\x01\x90U\x88\x80a'>V[a'\xF7\x81\x88a>\nV[`\x01\x83\x01\x90\x81T\x01\x90Ua'8V[\x7F\xA7O\x97\xAB\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[` \x16a(<W[\x80a&\xE1V[`@Q\x7F\xB6\xA8\xB0\xFA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01Ra(\x7F\x91a\x12\xE1\x82a\x12\xB5\x8A\x88\x8A\x8C\x8A3`$\x88\x01a2zV[P\x87a(6V[4a\x030W` \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030W`\x045T_R` _\xF3[4a\x030Wa(\xCE6a,PV[\x90\x91\x7F\xC0\x90\xFCF\x83bL\xFC8\x84\xE9\xD8\xDE^\xCA\x13/-\x0E\xC0b\xAF\xF7]C\xC0F]\\\xEE\xAB#\\\x15a\x04\xD9W\x7F\x1B=~\xDB.\x9C\x0B\x0E|R[ \xAA\xAE\xF0\xF5\x94\r.\xD7\x16c\xC7\xD3\x92f\xEC\xAF\xACr\x88Ya\x03\xEFs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF_\x93a)Ma)>\x87a0\x18V[\x86\x03`\x0F\x0B3\x90\x84\x8A\x16a0^V[\x16\x93\x84\x84R`\x04` R`@\x84 \x86\x85R` R`@\x84 a\x02_\x82\x82Ta.\xC5V[4a\x030W``\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030Wa)\xA7a,\nV[a)\xAFa,-V[`D5\x90\x7F\xC0\x90\xFCF\x83bL\xFC8\x84\xE9\xD8\xDE^\xCA\x13/-\x0E\xC0b\xAF\xF7]C\xC0F]\\\xEE\xAB#\\\x15a\x04\xD9Wa)\xFC\x92a)\xF7a)\xEA\x84a0\x18V[_\x03`\x0F\x0B3\x90\x83a0^V[a1NV[\0[4a\x030Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa*!6a,PV[\x91\x92\x90\x923_R`\x04` R`@_ \x84_R` R`@_ a*F\x84\x82Ta.\xB8V[\x90U\x16\x90\x81_R`\x04` R`@_ \x83_R` R`@_ a*k\x82\x82Ta.\xC5V[\x90U`@\x80Q3\x80\x82R` \x82\x01\x93\x90\x93R\x7F\x1B=~\xDB.\x9C\x0B\x0E|R[ \xAA\xAE\xF0\xF5\x94\r.\xD7\x16c\xC7\xD3\x92f\xEC\xAF\xACr\x88Y\x91\x81\x90\x81\x01a\x02yV[4a\x030W_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030W` `@Q`\x01\x81R\xF3[4a\x030W` \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030W`\x045\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81\x16\x80\x91\x03a\x030W\x80\x7F\x01\xFF\xC9\xA7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x92\x14\x90\x81\x15a+vW[P`@Q\x90\x15\x15\x81R\xF3[\x7F\x0Fc/\xB3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91P\x14\x82a+kV[4a\x030W`@\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030W` \x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa+\xEFa,\nV[\x16_R`\x04\x82R`@_ `$5_R\x82R`@_ T\x81R\xF3[`\x045\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x82\x03a\x030WV[`$5\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x82\x03a\x030WV[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC``\x91\x01\x12a\x030W`\x045s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x81\x03a\x030W\x90`$5\x90`D5\x90V[`\x80\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x08gW`@RV[`\xC0\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x08gW`@RV[`\xA0\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x08gW`@RV[\x90`\x1F\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x91\x01\x16\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x08gW`@RV[`\xA45\x90b\xFF\xFF\xFF\x82\x16\x82\x03a\x030WV[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC`\xA0\x91\x01\x12a\x030W`@Q\x90a-\x83\x82a,\xDDV[\x81`\x045s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x81\x03a\x030W\x81R`$5s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x81\x03a\x030W` \x82\x01R`D5b\xFF\xFF\xFF\x81\x16\x81\x03a\x030W`@\x82\x01R`d5\x80`\x02\x0B\x81\x03a\x030W``\x82\x01R`\x845\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x82\x03a\x030W`\x80\x01RV[\x91\x81`\x1F\x84\x01\x12\x15a\x030W\x825\x91g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11a\x030W` \x83\x81\x86\x01\x95\x01\x01\x11a\x030WV[\x90` \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC\x83\x01\x12a\x030W`\x045g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x030W\x82`#\x82\x01\x12\x15a\x030W\x80`\x04\x015\x92g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x84\x11a\x030W`$\x84`\x05\x1B\x83\x01\x01\x11a\x030W`$\x01\x91\x90V[\x91\x90\x82\x03\x91\x82\x11a\x1D\x91WV[\x91\x90\x82\x01\x80\x92\x11a\x1D\x91WV[\x15a.\xD9WV[`d`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` `\x04\x82\x01R`\x0C`$\x82\x01R\x7FUNAUTHORIZED\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R\xFD[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x08gW`\x1F\x01\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x16` \x01\x90V[`\x1F\x82` \x94\x93\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x93\x81\x86R\x86\x86\x017_\x85\x82\x86\x01\x01R\x01\x16\x01\x01\x90V[\x90a/\xB9\x82a8\xFFV[\x91\x82\x90\x83\x15a/\xF0W[\x7F\x1E\x07E\xA7\xDB\x16#\x98\x1F\x0B*]B26L\0xrf\xEBu\xADTo\x19\x0El\xEB\xE9\xBD\x95_R` R`@_ ]V[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x91Pa/\xC3V[o\x80\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81\x10\x15a06W`\x0F\x0B\x90V[c\x93\xDA\xFD\xF1_R`\x04`\x1C\xFD[\x91\x90\x91_\x83\x82\x01\x93\x84\x12\x91\x12\x90\x80\x15\x82\x16\x91\x15\x16\x17a\x1D\x91WV[\x90`\x0F\x0B\x91\x82\x15a1IW\x80_R\x81` Ra0\x7F`@_ \\\x93\x84a0CV[\x92\x83a0\xF9WP\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F}K1d\xC6\xE4[\x97\xE7\xD8{q%\xA4LX(\xD0\x05\xAF\x88\xF9\xD7Q\xCF\xD7\x87)\xC5\xD9\x9A\x0B\\\x01\x7F}K1d\xC6\xE4[\x97\xE7\xD8{q%\xA4LX(\xD0\x05\xAF\x88\xF9\xD7Q\xCF\xD7\x87)\xC5\xD9\x9A\x0B][_R` R`@_ ]V[a0\xEDW`\x01\x7F}K1d\xC6\xE4[\x97\xE7\xD8{q%\xA4LX(\xD0\x05\xAF\x88\xF9\xD7Q\xCF\xD7\x87)\xC5\xD9\x9A\x0B\\\x01\x7F}K1d\xC6\xE4[\x97\xE7\xD8{q%\xA4LX(\xD0\x05\xAF\x88\xF9\xD7Q\xCF\xD7\x87)\xC5\xD9\x9A\x0B]a0\xEDV[PPPV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16a1\x86WP_\x80\x80\x93\x81\x93Z\xF1\x15a1yWV[c\xF4\xB3\xB1\xBC_R`\x04`\x1C\xFD[`\x10_`D\x92` \x95\x82\x95`\x14R`4Ro\xA9\x05\x9C\xBB\0\0\0\0\0\0\0\0\0\0\0\0\x82RZ\xF1=\x15`\x01_Q\x14\x17\x16\x15a1\xC0W_`4RV[c\xF2\x7Fd\xE4_R`\x04`\x1C\xFD[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x160\x03a2\x0CWV[\x7F\r\x89C\x8E\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x15a2RWV[\x7FHj\xA3\x07\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x91\x92a2\xF5a\x01 \x94s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa3\r\x99\x97\x94\x16\x85R` \x85\x01\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x80\x92\x82\x81Q\x16\x85R\x82` \x82\x01Q\x16` \x86\x01Rb\xFF\xFF\xFF`@\x82\x01Q\x16`@\x86\x01R``\x81\x01Q`\x02\x0B``\x86\x01R\x01Q\x16\x91\x01RV[`\xC0\x83\x01R`\xE0\x82\x01R\x81a\x01\0\x82\x01R\x01\x91a/qV[\x90V[\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF` a3L\x94\x93a3?\x85\x84\x83Q\x16\x86`\x80\x1D\x90a0^V[\x01Q\x16\x90`\x0F\x0B\x90a0^V[V[b\xFF\xFF\xFFb\x0FB@\x91\x16\x11a3_WV[\x7F\xFC[\xEE\x12\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x90a3\r\x95\x93a4\x04a\x01`\x94s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa43\x94\x16\x85R` \x85\x01\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x80\x92\x82\x81Q\x16\x85R\x82` \x82\x01Q\x16` \x86\x01Rb\xFF\xFF\xFF`@\x82\x01Q\x16`@\x86\x01R``\x81\x01Q`\x02\x0B``\x86\x01R\x01Q\x16\x91\x01RV[\x80Q`\x02\x90\x81\x0B`\xC0\x85\x01R` \x82\x01Q\x90\x0B`\xE0\x84\x01R`@\x81\x01Qa\x01\0\x84\x01R``\x01Qa\x01 \x83\x01RV[\x81a\x01@\x82\x01R\x01\x91a/qV[\x80o\x80\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01`\x80\x1C\x15a4iWc\x93\xDA\xFD\xF1_R`\x04`\x1C\xFD[`\x0F\x0B\x90V[\x91a\x01\x80\x93a4\xEDa5\x1C\x92s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa3\r\x9A\x98\x95\x16\x86R` \x86\x01\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x80\x92\x82\x81Q\x16\x85R\x82` \x82\x01Q\x16` \x86\x01Rb\xFF\xFF\xFF`@\x82\x01Q\x16`@\x86\x01R``\x81\x01Q`\x02\x0B``\x86\x01R\x01Q\x16\x91\x01RV[\x80Q`\x02\x90\x81\x0B`\xC0\x86\x01R` \x82\x01Q\x90\x0B`\xE0\x85\x01R`@\x81\x01Qa\x01\0\x85\x01R``\x01Qa\x01 \x84\x01RV[a\x01@\x82\x01R\x81a\x01`\x82\x01R\x01\x91a/qV[\x92\x95\x93\x94_\x95s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x85\x163\x14a6xW\x87_`@\x86\x01Q\x13_\x14a6\nWa\x04\0\x86\x16a5sW[PPPPPPV[a5\xFE\x96\x98\x97Pa5\xEB\x92a5\xF7\x96\x95\x94\x92a5\xBF\x92`@Q\x96\x87\x95\x7FZ*\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x88\x01R3`$\x88\x01a4oV[\x03\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x81\x01\x83R\x82a,\xF9V[`\x02\x82\x16\x15\x15\x91aF\x10V[\x80\x92aF'V[\x91_\x80\x80\x80\x80\x80a5kV[\x94\x93\x92\x91\x90a\x01\0\x85\x16a6 WPPPPPPV[a5\xFE\x96\x98P\x85\x97Pa6l\x92\x91a5\xBF\x91a5\xF7\x97`@Q\x96\x87\x95\x7F\x8D\xB2\xB6R\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x88\x01R3`$\x88\x01a4oV[`\x01\x82\x16\x15\x15\x91aF\x10V[P_\x95PPPPPV[`\x80\x81\x16\x15\x80a74W[a7\nW`@\x81\x16\x15\x80a7(W[a7\nWa\x04\0\x81\x16\x15\x80a7\x1CW[a7\nWa\x01\0\x81\x16\x15\x80a7\x10W[a7\nWs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16a6\xEAWPb\xFF\xFF\xFF\x16b\x80\0\0\x14\x15\x90V[a?\xFF\x16\x15\x90\x81\x15\x91a6\xFBWP\x90V[b\x80\0\0\x91Pb\xFF\xFF\xFF\x16\x14\x90V[PP_\x90V[P`\x01\x81\x16\x15\x15a6\xBCV[P`\x02\x81\x16\x15\x15a6\xACV[P`\x04\x81\x16\x15\x15a6\x9CV[P`\x08\x81\x16\x15\x15a6\x8DV[b\x80\0\0b\xFF\xFF\xFF\x82\x16\x14a7XWa3\r\x81a3NV[P_\x90V[_\x91_\x91s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x02T\x16\x80a7\x83WPPV[\x91\x93P\x91PZ\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x80\x91\x10a8\xD7W_\x92\x83\x80\x93`@Qa88` \x82\x01\x94\x7FU;\xFC7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x86R`$\x83\x01\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x80\x92\x82\x81Q\x16\x85R\x82` \x82\x01Q\x16` \x86\x01Rb\xFF\xFF\xFF`@\x82\x01Q\x16`@\x86\x01R``\x81\x01Q`\x02\x0B``\x86\x01R\x01Q\x16\x91\x01RV[`\xA4\x81Ra8G`\xC4\x82a,\xF9V[Q\x93\xF1=\x15a8\xCFW=\x90a8[\x82a/7V[\x91a8i`@Q\x93\x84a,\xF9V[\x82R=_` \x84\x01>[\x15\x80\x15a8\xC4W[a8\xBDW` \x01Qb\xFF\xFF\xFF\x81\x16\x90\x81\x81\x14\x90\x81a8\xA5W[P\x15a8\x9FW`\x01\x91V[P_\x80\x91V[\x90Pa\x03\xE9a\x0F\xFFb>\x90\0\x84\x10\x92\x16\x10\x16_a8\x94V[P_\x90_\x90V[P` \x81Q\x11a8{V[``\x90a8sV[\x7F\x1E\xE4\x97\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x80a9\x1FWPG\x90V[` `$\x91`@Q\x92\x83\x80\x92\x7Fp\xA0\x821\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82R0`\x04\x83\x01RZ\xFA\x90\x81\x15a$)W_\x91a9gWP\x90V[\x90P` \x81=` \x11a9\x8EW[\x81a9\x82` \x93\x83a,\xF9V[\x81\x01\x03\x12a\x030WQ\x90V[=\x91Pa9uV[\x94\x91\x92\x94_\x94_\x94` \x81\x01Q\x97s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x84\x163\x14a;OW`\x80\x84\x16a9\xD1W[PPPPPV[a:\xC3a:sa:\xBD\x87a5\xBF`@\x95b\x80\0\0\x98a:\xA9b\xFF\xFF\xFF\x99\x89Q\x97\x88\x96\x7FW^$\xB4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x89\x01R3`$\x89\x01R`D\x88\x01\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x80\x92\x82\x81Q\x16\x85R\x82` \x82\x01Q\x16` \x86\x01Rb\xFF\xFF\xFF`@\x82\x01Q\x16`@\x86\x01R``\x81\x01Q`\x02\x0B``\x86\x01R\x01Q\x16\x91\x01RV[\x80Q\x15\x15`\xE4\x87\x01R` \x81\x01Qa\x01\x04\x87\x01R`@\x01Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x01$\x86\x01RV[a\x01@a\x01D\x85\x01Ra\x01d\x84\x01\x91a/qV[\x85a=GV[\x94\x01Q\x16\x14a;CW[`\x08\x16a:\xDEW[\x80\x80\x80\x80a9\xCAV[`@\x01Q\x92P`\x80\x83\x90\x1D`\x0F\x0B\x80\x15a:\xD5Wa:\xFF\x90_\x86\x12\x95a0CV[\x93\x15a;;W_\x84\x13[a;\x13W_a:\xD5V[\x7F\xFA\x0Bq\xD6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[_\x84\x12a;\tV[``\x82\x01Q\x93Pa:\xCDV[P_\x96P\x86\x95PPPPPV[\x90`\x0F\x0B\x90`\x0F\x0B\x01\x90\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x12o\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x13\x17a\x1D\x91WV[\x91\x96\x95\x93\x94\x92\x94s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x163\x14a=:W\x84`\x80\x1D\x94`\x0F\x0B\x93\x88`@\x85\x16a<bW[PPPPP_\x94\x81`\x0F\x0B\x15\x80\x15\x90a<VW[a;\xFAW[PPP\x91\x90V[a<1\x93\x95P_` \x82\x01Q\x12\x90Q\x15\x15\x14_\x14a<9Wo\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90`\x80\x1B\x17[\x80\x93aF'V[_\x80\x80a;\xF3V[\x90o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90`\x80\x1B\x17a<*V[P\x82`\x0F\x0B\x15\x15a;\xEEV[a=\x1Ea=*\x94a5\xBFa\x19\x19\x95a=0\x99\x98\x95a=\x03a:s\x96`@Q\x97\x88\x96\x7F\xB4{/\xB1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x89\x01R3`$\x89\x01R`D\x88\x01\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x80\x92\x82\x81Q\x16\x85R\x82` \x82\x01Q\x16` \x86\x01Rb\xFF\xFF\xFF`@\x82\x01Q\x16`@\x86\x01R``\x81\x01Q`\x02\x0B``\x86\x01R\x01Q\x16\x91\x01RV[\x8Ca\x01D\x85\x01Ra\x01`a\x01d\x85\x01Ra\x01\x84\x84\x01\x91a/qV[`\x04\x82\x16\x15\x15\x91aF\x10V[\x90a;\\V[_\x80\x80\x80\x88a;\xDAV[PPPPP\x90\x91P\x90_\x90V[_\x80\x93\x92\x81\x92` \x82Q\x92\x01\x95\x86\x91Z\xF1\x15a=\xEFW`@Q\x91\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0`?=\x01\x16\x83\x01`@R=\x83R\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x80=` \x86\x01\x90_\x82>Q\x92Q\x16\x91\x16\x03a=\xC7WV[\x7F\x1E\x04\x8E\x1D\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[=\x15a=\xFDW=_\x80>=_\xFD[c6\xBCH\xC5_R`\x04`\x1C\xFD[\x90\x81`\x80\x1B\x90\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFp\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x84\t\x92\x82\x80\x85\x10\x94\x03\x93\x80\x85\x03\x94\x85\x84\x11\x15a\x030W\x14a>\xC4Wp\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x91\t\x81\x80_\x03\x16\x80\x92\x04`\x02\x81`\x03\x02\x18\x80\x82\x02`\x02\x03\x02\x80\x82\x02`\x02\x03\x02\x80\x82\x02`\x02\x03\x02\x80\x82\x02`\x02\x03\x02\x80\x82\x02`\x02\x03\x02\x80\x91\x02`\x02\x03\x02\x93`\x01\x83\x80_\x03\x04\x01\x90\x84\x83\x11\x90\x03\x02\x92\x03\x04\x17\x02\x90V[P\x91P\x04\x90V[\x90\x80\x82\x02\x91\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x82\t\x91\x83\x80\x84\x10\x93\x03\x92\x80\x84\x03\x93\x84p\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x11\x15a\x030W\x14a?DWp\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\t\x90\x82\x82\x11\x90\x03`\x80\x1B\x91\x03`\x80\x1C\x17\x90V[PPP`\x80\x1C\x90V[\x90\x80\x82\x02\x91\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x82\t\x91\x83\x80\x84\x10\x93\x03\x92\x80\x84\x03\x93\x84l\x01\0\0\0\0\0\0\0\0\0\0\0\0\x11\x15a\x030W\x14a?\xBEWl\x01\0\0\0\0\0\0\0\0\0\0\0\0\x91\t\x90\x82\x82\x11\x90\x03`\xA0\x1B\x91\x03``\x1C\x17\x90V[PPP``\x1C\x90V[\x81\x81\x02\x90\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x82\t\x90\x82\x80\x83\x10\x92\x03\x91\x80\x83\x03\x92\x83b\x0FB@\x11\x15a\x030W\x14a@FW\x7F\xDE\x8Fl\xEF\xEDcEI\xB6,wWOr.\x1A\xC5~#\xF2M\x8F\xD5\xCBy\x0F\xB6Vh\xC2a9\x93b\x0FB@\x91\t\x90\x82\x82\x11\x90\x03`\xFA\x1B\x91\x03`\x06\x1C\x17\x02\x90V[PPb\x0FB@\x91P\x04\x90V[\x90\x81``\x1B\x90\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFl\x01\0\0\0\0\0\0\0\0\0\0\0\0\x84\t\x92\x82\x80\x85\x10\x94\x03\x93\x80\x85\x03\x94\x85\x84\x11\x15a\x030W\x14a>\xC4Wl\x01\0\0\0\0\0\0\0\0\0\0\0\0\x82\x91\t\x81\x80_\x03\x16\x80\x92\x04`\x02\x81`\x03\x02\x18\x80\x82\x02`\x02\x03\x02\x80\x82\x02`\x02\x03\x02\x80\x82\x02`\x02\x03\x02\x80\x82\x02`\x02\x03\x02\x80\x82\x02`\x02\x03\x02\x80\x91\x02`\x02\x03\x02\x93`\x01\x83\x80_\x03\x04\x01\x90\x84\x83\x11\x90\x03\x02\x92\x03\x04\x17\x02\x90V[\x91\x81\x83\x02\x91\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x85\t\x93\x83\x80\x86\x10\x95\x03\x94\x80\x86\x03\x95\x86\x85\x11\x15a\x030W\x14aA\x9BW\x90\x82\x91\t\x81\x80_\x03\x16\x80\x92\x04`\x02\x81`\x03\x02\x18\x80\x82\x02`\x02\x03\x02\x80\x82\x02`\x02\x03\x02\x80\x82\x02`\x02\x03\x02\x80\x82\x02`\x02\x03\x02\x80\x82\x02`\x02\x03\x02\x80\x91\x02`\x02\x03\x02\x93`\x01\x83\x80_\x03\x04\x01\x90\x84\x83\x11\x90\x03\x02\x92\x03\x04\x17\x02\x90V[PP\x91P\x04\x90V[\x91\x90\x81\x81\x07aA\xC9W\x05\x90\x81`\x08\x1D_R` R`\x01`\xFF`@_ \x92\x16\x1B\x81T\x18\x90UV[c\xD4\xD8\xF3\xE6_R` R`@R`D`\x1C\xFD[\x80`\xFF\x1D\x81\x81\x01\x18b\r\x89\xE8\x81\x11aE\x1DWc\xFF\xFF\xFF\xFF\x91`\x01\x82\x16p\x01\xFF\xFC\xB93\xBDo\xAD7\xAA-\x16-\x1AY@\x01\x02p\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x18\x91`\x02\x81\x16aE\x01W[`\x04\x81\x16aD\xE5W[`\x08\x81\x16aD\xC9W[`\x10\x81\x16aD\xADW[` \x81\x16aD\x91W[`@\x81\x16aDuW[`\x80\x81\x16aDYW[a\x01\0\x81\x16aD=W[a\x02\0\x81\x16aD!W[a\x04\0\x81\x16aD\x05W[a\x08\0\x81\x16aC\xE9W[a\x10\0\x81\x16aC\xCDW[a \0\x81\x16aC\xB1W[a@\0\x81\x16aC\x95W[a\x80\0\x81\x16aCyW[b\x01\0\0\x81\x16aC]W[b\x02\0\0\x81\x16aCBW[b\x04\0\0\x81\x16aC'W[b\x08\0\0\x16aC\x0EW[_\x12aB\xE7W[\x01` \x1C\x90V[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x04aB\xE0V[k\x04\x8A\x17\x03\x91\xF7\xDCBDN\x8F\xA2\x90\x91\x02`\x80\x1C\x90aB\xD9V[m\"\x16\xE5\x84\xF5\xFA\x1E\xA9&\x04\x1B\xED\xFE\x98\x90\x92\x02`\x80\x1C\x91aB\xCFV[\x91n]j\xF8\xDE\xDB\x81\x19f\x99\xC3)\"^\xE6\x04\x02`\x80\x1C\x91aB\xC4V[\x91o\t\xAAP\x8B[z\x84\xE1\xC6w\xDET\xF3\xE9\x9B\xC9\x02`\x80\x1C\x91aB\xB9V[\x91o1\xBE\x13_\x97\xD0\x8F\xD9\x81#\x15\x05T/\xCF\xA6\x02`\x80\x1C\x91aB\xAEV[\x91op\xD8i\xA1V\xD2\xA1\xB8\x90\xBB=\xF6+\xAF2\xF7\x02`\x80\x1C\x91aB\xA4V[\x91o\xA9\xF7FF-\x87\x0F\xDF\x8Ae\xDC\x1F\x90\xE0a\xE5\x02`\x80\x1C\x91aB\x9AV[\x91o\xD0\x97\xF3\xBD\xFD \"\xB8\x84Z\xD8\xF7\x92\xAAX%\x02`\x80\x1C\x91aB\x90V[\x91o\xE7\x15\x94u\xA2\xC2\x9BtC\xB2\x9C\x7F\xA6\xE8\x89\xD9\x02`\x80\x1C\x91aB\x86V[\x91o\xF39+\x08\"\xB7\0\x05\x94\x0Cz9\x8EKp\xF3\x02`\x80\x1C\x91aB|V[\x91o\xF9\x87\xA7%:\xC4\x13\x17o+\x07L\xF7\x81^T\x02`\x80\x1C\x91aBrV[\x91o\xFC\xBE\x86\xC7\x90\n\x88\xAE\xDC\xFF\xC8;G\x9A\xA3\xA4\x02`\x80\x1C\x91aBhV[\x91o\xFE]\xEE\x04j\x99\xA2\xA8\x11\xC4a\xF1\x96\x9C0S\x02`\x80\x1C\x91aB^V[\x91o\xFF.\xA1df\xC9j8C\xECx\xB3&\xB5(a\x02`\x80\x1C\x91aBUV[\x91o\xFF\x97;A\xFA\x98\xC0\x81G.h\x96\xDF\xB2T\xC0\x02`\x80\x1C\x91aBLV[\x91o\xFF\xCB\x98C\xD6\x0FaY\xC9\xDBX\x83\\\x92fD\x02`\x80\x1C\x91aBCV[\x91o\xFF\xE5\xCA\xCA~\x10\xE4\xE6\x1C6$\xEA\xA0\x94\x1C\xD0\x02`\x80\x1C\x91aB:V[\x91o\xFF\xF2\xE5\x0F_ei2\xEF\x125|\xF3\xC7\xFD\xCC\x02`\x80\x1C\x91aB1V[\x91o\xFF\xF9rr7=A2Y\xA4i\x90X\x0E!:\x02`\x80\x1C\x91aB(V[c\xCE\x8E\xF7\xFC_R`\x04`\x1C\xFD[_\x83`\x0F\x0B\x12_\x14aEgW\x91aEb\x91a3\r\x93\x03\x80`\xFF\x1D\x90\x81\x01\x18\x90_\x03o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a?MV[aZ&V[\x90l\x01\0\0\0\0\0\0\0\0\0\0\0\0`\x01\x91aE\xAE\x94o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x93\x03\x80`\xFF\x1D\x90\x81\x01\x18aE\xA3\x81\x85a?MV[\x93\t\x15\x15\x16\x01aZ&V[_\x03\x90V[\x91_\x81`\x0F\x0B\x12_\x14aE\xE3W\x91aEb\x91a3\r\x93_\x03o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x91aZ\xE0V[\x91aEb\x91aE\xAE\x93o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x91aZ;V[\x01\x90\x81`\x80\x1Ca06WV[\x90aF\x1A\x91a=GV[\x90\x15a7XW`@\x01Q\x90V[aFJ\x90aF<\x83`\x80\x1D\x82`\x80\x1D\x03a4AV[\x92`\x0F\x0B\x90`\x0F\x0B\x03a4AV[o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90`\x80\x1B\x17\x90V[s\xFF\xFD\x89c\xEF\xD1\xFCjPd\x88I]\x95\x1DQc\x96\x16\x82\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFE\xFF\xFD\x89]\x82\x01\x11aI\x93Ww\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\x81` \x1B\x16\x80o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11`\x07\x1B\x90\x81\x1Cg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11`\x06\x1B\x90\x81\x1Cc\xFF\xFF\xFF\xFF\x81\x11`\x05\x1B\x90\x81\x1Ca\xFF\xFF\x81\x11`\x04\x1B\x90\x81\x1C\x90`\xFF\x82\x11`\x03\x1B\x91\x82\x1C\x92`\x0F\x84\x11`\x02\x1B\x93\x84\x1C\x94`\x01`\x03\x87\x11\x81\x1B\x96\x87\x1C\x11\x96\x17\x17\x17\x17\x17\x17\x17\x90`\x80\x82\x10\x15_\x14aI\x89W\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x82\x01\x1C[\x80\x02\x80`\x7F\x1C\x81`\xFF\x1C\x1C\x80\x02\x80`\x7F\x1C\x81`\xFF\x1C\x1C\x80\x02\x80`\x7F\x1C\x81`\xFF\x1C\x1C\x80\x02\x80`\x7F\x1C\x81`\xFF\x1C\x1C\x80\x02\x80`\x7F\x1C\x81`\xFF\x1C\x1C\x80\x02\x80`\x7F\x1C\x81`\xFF\x1C\x1C\x80\x02\x90\x81`\x7F\x1C\x82`\xFF\x1C\x1C\x80\x02\x92\x83`\x7F\x1C\x84`\xFF\x1C\x1C\x80\x02\x94\x85`\x7F\x1C\x86`\xFF\x1C\x1C\x80\x02\x96\x87`\x7F\x1C\x88`\xFF\x1C\x1C\x80\x02\x98\x89`\x7F\x1C\x8A`\xFF\x1C\x1C\x80\x02\x9A\x8B`\x7F\x1C\x8C`\xFF\x1C\x1C\x80\x02\x9C\x8D\x80`\x7F\x1C\x90`\xFF\x1C\x1C\x80\x02`\xCD\x1Cf\x04\0\0\0\0\0\0\x16\x9D`\xCC\x1Cf\x08\0\0\0\0\0\0\x16\x9C`\xCB\x1Cf\x10\0\0\0\0\0\0\x16\x9B`\xCA\x1Cf \0\0\0\0\0\0\x16\x9A`\xC9\x1Cf@\0\0\0\0\0\0\x16\x99`\xC8\x1Cf\x80\0\0\0\0\0\0\x16\x98`\xC7\x1Cg\x01\0\0\0\0\0\0\0\x16\x97`\xC6\x1Cg\x02\0\0\0\0\0\0\0\x16\x96`\xC5\x1Cg\x04\0\0\0\0\0\0\0\x16\x95`\xC4\x1Cg\x08\0\0\0\0\0\0\0\x16\x94`\xC3\x1Cg\x10\0\0\0\0\0\0\0\x16\x93`\xC2\x1Cg \0\0\0\0\0\0\0\x16\x92`\xC1\x1Cg@\0\0\0\0\0\0\0\x16\x91`\xC0\x1Cg\x80\0\0\0\0\0\0\0\x16\x90\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x01`@\x1B\x17\x17\x17\x17\x17\x17\x17\x17\x17\x17\x17\x17\x17\x17i6'\xA3\x01\xD7\x10UwL\x85\x02\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFDp\x9B~T\x80\xFB\xA5\xA5\x0F\xED^b\xFF\xC5V\x81\x01`\x80\x1D`\x02\x0B\x90o\xDB-\xF0\x9E\x81\x95\x9A\x81E^&\x07\x99\xA0c/\x01`\x80\x1D`\x02\x0B\x91\x82\x82\x14_\x14aIFWP\x90P\x90V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFaIz\x84aA\xDCV[\x16\x11aI\x84WP\x90V[\x90P\x90V[\x81`\x7F\x03\x1BaG^V[c1\xEF\xAF\xE8_R`\x04`\x1C\xFD[\x81\x15aI\xAAW\x04\x90V[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x12`\x04R`$_\xFD[\x90_`@QaI\xE5\x81a,\xC1V[_\x81R` \x81\x01\x90_\x82R`@\x81\x01\x95_\x87R``\x82\x01\x94_\x86R`\x80\x83\x01\x91_\x83R_`\xA0\x85\x01R\x83\x98\x88T\x93` \x84\x01Q\x15\x98o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x03\x8C\x01T\x16\x92\x8A\x15_\x14aZ\x17W_a\x0F\xFF\x88`\xB8\x1C\x16\x99[`@\x88\x01Q\x8ARR\x86s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90R\x85`\xA0\x1C`\x02\x0B\x90R\x88\x15_\x14aZ\x0CW`\x01\x8A\x01T\x90[R`\xA0\x85\x01\x81\x90R`\x80\x83\x01Qb@\0\0\x81\x16\x15aY\xFDWb\xBF\xFF\xFF\x16aJ\xA4\x81a3NV[a\xFF\xFF\x87\x16aY\xDCW\x90[\x81\x94_`@\x86\x01Q\x12\x92\x83\x15\x97\x88\x80\x99aY\xCBW[aY\xA3W`@\x87\x01Q\x15aY\x8DWPP\x89aY\x19W``\x85\x01s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81Q\x16\x82s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81\x10\x15aX\xD4WPQs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16d\x01\0\x02v\xA3\x81\x11\x15aX\xA9WP[`@Q`\x80R`\xE0`\x80Q\x01`\x80Q\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x08gW`@R_`\x80QR_` `\x80Q\x01R_`@`\x80Q\x01R_```\x80Q\x01R_`\x80\x80Q\x01R_`\xA0`\x80Q\x01R_`\xC0`\x80Q\x01R[\x8BQ\x15\x80\x15aXlW[aW\x1CWs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@\x8D\x01Q\x16`\x80QR``\x8C\x01Q`\x02\x0B\x85Q`\x02\x0B\x90\x81_\x81\x83\x07\x12\x91\x05\x03\x8C\x8C\x15_\x14aT\x8EWP`\xFF\x81\x16\x91\x8D`\x05`\x01\x85\x1B\x91\x84`\x08\x1D`\x01\x0B_R\x01` R\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ \x91\x80\x01\x01\x90T\x16\x91\x82\x15\x92\x83\x15\x93\x84_\x14aTYW\x81\x95_\x91a\x030W\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xF2v\x18\x96\x83p\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\xFF\x95\x10\x15aTJW[P\x80h\x01\0\0\0\0\0\0\0\0`\x02\x92\x10\x15aT<W[d\x01\0\0\0\0\x81\x10\x15aT.W[b\x01\0\0\x81\x10\x15aT W[a\x01\0\x81\x10\x15aT\x12W[`\x10\x81\x10\x15aT\x04W[`\x04\x81\x10\x15aS\xF7W[\x10\x15aS\xEAW[\x03\x16`\x02\x0B\x90\x03`\x02\x0B\x02`\x02\x0B[\x90[\x15\x15`@`\x80Q\x01R`\x02\x0B\x80` `\x80Q\x01R\x13\x15aS\xBDW[b\r\x89\xE8` `\x80Q\x01Q`\x02\x0B\x12\x15aS\xADW[\x8Bs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@\x81aM>` `\x80Q\x01Q`\x02\x0BaA\xDCV[\x16\x92\x83```\x80Q\x01R\x01Q\x16\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF``\x88\x01Q\x16\x90\x81\x8D\x15\x81\x83\x10\x18\x91\x18\x02\x18\x90\x8Do\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\xA0\x82\x01Q\x16\x90Q\x90b\xFF\xFF\xFF\x8A\x16\x92s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x85\x16\x81\x10\x15\x91_\x84\x12_\x14aQ\xF3W\x84b\x0FB@\x03aM\xCC\x81\x86_\x03a?\xC7V[\x96\x84\x15aQ\xC1WaM\xDE\x83\x85\x83aZ;V[\x95[\x86\x89\x10aP\xC9WPs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x97P\x95\x86\x91b\x0FB@\x82\x03aP\xBAWPP\x84[\x93[\x15aP\xACW\x91aN+\x92\x03\x80`\xFF\x1D\x90\x81\x01\x18\x90a?MV[\x90[`\xC0`\x80Q\x01R`\xA0`\x80Q\x01R`\x80\x80Q\x01R\x16`@\x8D\x01R\x86_\x14aPlWaN]`\xA0`\x80Q\x01QaZ&V[\x8CQ\x03\x8CR` \x8C\x01\x80Q\x90aN\x82aEb`\x80\x80Q\x01Q`\xC0`\x80Q\x01Q\x90a.\xC5V[\x91_\x83\x82\x03\x93\x12\x81\x84\x12\x81\x16\x91\x84\x13\x90\x15\x16\x17a\x1D\x91WR[a\xFF\xFF\x88\x16aP9W[o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\xA0\x8D\x01Q\x16\x80aP\x19W[Ps\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@\x8D\x01Q\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF```\x80Q\x01Q\x16\x81\x14_\x14aO\xDBWP`@`\x80Q\x01QaO*W[\x89\x15` `\x80Q\x01Q`\x02\x0B\x03`\x02\x0B``\x8D\x01RaK\x93V[\x89aO\xB2Wo\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFaO\x99\x8D\x8D`\x80\x82\x01Q\x90`\x04`\x02\x82\x01T\x91[` `\x80Q\x01Q`\x02\x0B`\x02\x0B_R\x01` R`@_ \x91`\x01\x83\x01\x90\x81T\x90\x03\x90U`\x02\x82\x01\x90\x81T\x90\x03\x90UT`\x80\x1D\x90\x8D\x15aO\xA4W[`\xA0\x01Q\x83\x16aF\x04V[\x16`\xA0\x8D\x01RaO\x10V[_\x91\x90\x91\x03`\x0F\x0B\x90aO\x8EV[o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFaO\x99\x8D\x8D`\x01\x81\x01T\x90`\x04`\x80\x84\x01Q\x91aOTV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80QQ\x16\x81\x03aP\x02W[PaK\x93V[aP\x0B\x90aFdV[`\x02\x0B``\x8D\x01R_aO\xFCV[aP)\x90`\xC0`\x80Q\x01Qa>\nV[`\x80\x8D\x01\x90\x81Q\x01\x90R_aN\xC2V[\x97b\x0FB@`\x80\x80Q\x01Qa\xFF\xFF\x8A\x16\x90`\xC0`\x80Q\x01Q\x01\x02\x04\x90\x81`\xC0`\x80Q\x01Q\x03`\xC0`\x80Q\x01R\x01\x97aN\xA5V[aP\x82`\x80\x80Q\x01Q`\xC0`\x80Q\x01Q\x01aZ&V[\x8CQ\x01\x8CR` \x8C\x01aP\xA5\x81QaP\x9F`\xA0`\x80Q\x01QaZ&V[\x90a0CV[\x90RaN\x9BV[aP\xB5\x92aZ\xE0V[aN+V[aP\xC4\x91\x87a[uV[aN\x10V[\x95PPP\x80\x94P\x15\x81\x15\x17aQ\xB4Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x94\x82\x15aQPWaP\xFF\x90\x85\x83a\\\x13V[\x93[\x84\x80\x82\x84\x86\x15aQ\x1FWaQ\x14\x92aZ;V[\x80\x95\x01_\x03\x93aN\x12V[\x90P\x03\x80`\xFF\x1D\x90\x81\x01\x18`\x01l\x01\0\0\0\0\0\0\0\0\0\0\0\0aQD\x83\x86a?MV[\x92\x85\t\x15\x15\x16\x01aQ\x14V[aQ\x8C\x90aQ\x87\x90\x87\x81\x11aQ\x92WaQ\x7F\x90o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x88\x16\x90``\x1BaI\xA0V[\x87\x84\x16a.\xC5V[a\\\xA1V[\x93aQ\x01V[aQ\xAF\x90o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x88\x16\x90a@RV[aQ\x7FV[cO$a\xB8_R`\x04`\x1C\xFD[\x80\x84\x03\x80`\xFF\x1D\x90\x81\x01\x18`\x01l\x01\0\0\0\0\0\0\0\0\0\0\0\0aQ\xE6\x83\x87a?MV[\x92\x86\t\x15\x15\x16\x01\x95aM\xE0V[\x90\x94\x91\x93\x92\x91\x84\x15aS\x9CWaR\x13\x86\x82\x03\x80`\xFF\x1D\x90\x81\x01\x18\x83a?MV[\x92[\x83\x81\x10aR\x8EWP\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x95aRY\x92\x80\x96[\x15aR^W\x90aRK\x92\x91aZ;V[\x80\x93\x80b\x0FB@\x03\x91a[uV[aN-V[l\x01\0\0\0\0\0\0\0\0\0\0\0\0\x90`\x01\x92\x03\x80`\xFF\x1D\x90\x81\x01\x18aR\x83\x81\x85a?MV[\x93\t\x15\x15\x16\x01aRKV[\x92PP\x81\x81\x15\x86\x15\x17aQ\xB4W\x84\x15aSrWs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11aS\x19W``\x1Bo\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x80\x82\x06\x15\x15\x91\x04\x01\x90[\x81\x86\x11\x15aS\x0CW\x85s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFaRY\x93\x81\x80\x99\x16\x03\x16[\x80\x96aR;V[cC#\xA5U_R`\x04`\x1C\xFD[o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16aSD\x81l\x01\0\0\0\0\0\0\0\0\0\0\0\0\x84aA\x04V[\x91\x81\x15aI\xAAWl\x01\0\0\0\0\0\0\0\0\0\0\0\0\x90\taSfW[\x90aR\xDCV[`\x01\x01\x80aS`W_\x80\xFD[\x90\x85aS\x97aRY\x93\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x99a[\x9EV[aS\x05V[aS\xA7\x82\x82\x88aZ\xE0V[\x92aR\x15V[b\r\x89\xE8` `\x80Q\x01RaM\x13V[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xF2v\x18` `\x80Q\x01RaL\xFEV[\x90`\x01\x83\x91\x01\x16\x90aL\xD2V[\x92\x81\x01\x84\x16\x92\x81\x1CaL\xCBV[`\x04\x93\x84\x01\x85\x16\x93\x1CaL\xC1V[`\x08\x93\x84\x01\x85\x16\x93\x1CaL\xB7V[`\x10\x93\x84\x01\x85\x16\x93\x1CaL\xACV[` \x93\x84\x01\x85\x16\x93\x1CaL\xA0V[`@\x93\x84\x01\x85\x16\x93\x1CaL\x92V[`\x80\x93P\x83\x1C\x90P`\x02aL|V[PP\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xF2v\x18\x93`\x02\x0B\x90\x03`\x02\x0B\x02`\x02\x0BaL\xE1V[\x90`\x01\x01\x91\x82`\x02\x0B\x92`\x05\x81`\xFF\x16\x93\x85`\x08\x1D`\x01\x0B_R\x01` R\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x01`\xFF`@_ \x93\x16\x1B\x01\x19\x90T\x16\x92\x83\x15\x93\x84\x15\x93\x84_\x14aV\xE2W\x81\x95a\x030W\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xF2v\x18\x95`\xFF\x92\x83\x90o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x15aV\xD8WPP`\x7F[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x15aV\xCEW\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xC0\x01\x83\x16[c\xFF\xFF\xFF\xFF\x82\x16\x15aV\xC4W\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x01\x83\x16[a\xFF\xFF\x82\x16\x15aV\xBAW\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xF0\x01\x83\x16[\x81\x84\x16\x15aV\xB0W\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xF8\x01\x83\x16[`\x0F\x82\x16\x15aV\xA6W\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC\x01\x83\x16[`\x03\x82\x16\x15aV\x9AW\x83\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFE`\x01\x92\x01\x16\x91[\x16aVqW[\x03\x16`\x02\x0B\x01`\x02\x0B\x02`\x02\x0B[\x90aL\xE3V[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x01\x82\x16aV]V[\x90`\x01\x90`\x02\x1CaVWV[\x90`\x04\x1C\x90aV%V[\x90`\x08\x1C\x90aU\xF7V[\x90`\x10\x1C\x90aU\xCAV[\x90` \x1C\x90aU\x9BV[\x90`@\x1C\x90aUjV[`\x80\x1C\x91PaU5V[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xF2v\x18\x95P`\xFF\x80\x92P\x03\x16`\x02\x0B\x01`\x02\x0B\x02`\x02\x0BaVkV[\x91\x95P\x91\x99\x96\x98\x92\x95P\x96\x92\x96``\x87\x01Q`\xA0\x1Bv\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@\x8A\x01Q\x16\x92\x16\x17\x17\x82Uo\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\xA0\x87\x01Q\x16\x80\x91\x03aX'W[P\x81\x15aX\x18W`\x02`\x80\x86\x01Q\x91\x01U[\x15\x14aW\xFBWaW\xE1`@aW\xD5` \x85\x01Qa4AV[\x92\x01Q\x83Q\x90\x03a4AV[o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90`\x80\x1B\x17\x93V[`@\x01Q\x81QaX\x0B\x91\x03a4AV[aW\xE1` \x83\x01Qa4AV[`\x01`\x80\x86\x01Q\x91\x01UaW\xBDV[o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x03\x83\x01T\x16\x17`\x03\x82\x01U_aW\xABV[Ps\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@\x8D\x01Q\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF``\x87\x01Q\x16\x14aK\x9DV[\x7F\x9EM|\xC7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04R`$_\xFD[\x82\x7F|\x9Cn\x8F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x04R`$R`D_\xFD[``\x85\x01s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81Q\x16\x82s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81\x11\x15aX\xD4WPQs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFD\x89c\xEF\xD1\xFCjPd\x88I]\x95\x1DRc\x98\x8D&\x81\x10\x15aX\xA9WPaK:V[\x9AP\x9APPPP\x97PPPPPP_\x92_\x92\x91\x90V[\x7F\x96 bF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[Pb\x0FB@b\xFF\xFF\xFF\x83\x16\x14aJ\xC4V[\x80a\xFF\xFF\x88\x16\x02b\x0FB@\x80\x82\x06\x15\x15\x91\x04\x01\x90a\xFF\xFF\x88\x16\x01\x03\x90aJ\xAFV[P\x83`\xD0\x1Cb\xFF\xFF\xFF\x16aJ\xA4V[`\x02\x8A\x01T\x90aJ~V[_a\x0F\xFF\x88`\xC4\x1C\x16\x99aJEV[_\x81\x12\x15a3\rWc\x93\xDA\xFD\xF1_R`\x04`\x1C\xFD[\x91s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x84\x16\x11aZ\xD8W[\x82\x15aZ\xCCWs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x91aZ\xBF\x91{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\x84\x86\x81\x85\x16\x94\x03\x16\x91``\x1B\x16a[uV[\x91\x16\x80\x82\x06\x15\x15\x91\x04\x01\x90V[b\xBF\xC9!_R`\x04`\x1C\xFD[\x91\x90\x91aZpV[\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x16\x11a[oW[\x81\x15aZ\xCCWa[gs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x91a3\r\x94{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\x84\x86\x81\x85\x16\x94\x03\x16\x91``\x1B\x16aA\x04V[\x91\x16\x90aI\xA0V[\x90a[\x15V[\x92\x91\x90a[\x83\x82\x82\x86aA\x04V[\x93\x82\x15aI\xAAW\ta[\x91WV[\x90`\x01\x01\x90\x81\x15a\x030WV[\x90\x82\x15a\\\rW{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\x90``\x1B\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x92\x83\x81\x02\x92\x83\x83\x11\x91\x84\x04\x14\x16\x15a\\\0Wa3\r\x92aQ\x87\x92\x82\x03\x91a[uV[c\xF5\xC7\x87\xF1_R`\x04`\x1C\xFD[P\x90P\x90V[\x90\x91\x80\x15a\\\rWs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\x81\x94``\x1B\x16\x92\x16\x80\x82\x02\x81a\\c\x84\x83aI\xA0V[\x14a\\\x89W[P\x90a\\xa\\}\x92\x84aI\xA0V[a.\xC5V[\x80\x82\x06\x15\x15\x91\x04\x01\x16\x90V[\x83\x01\x83\x81\x10a\\iW\x91Pa\\\x9D\x92a[uV[\x16\x90V[t\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81\x10\x15a06Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90V\xFE\xA2dipfsX\"\x12 l\xDB8\xC1\xD8P\x9Fk\xD2\x0B\xB1\xA6nI\x98>5\xDE\xA0\x9F,\x8Dm+\x81\xE8\xE5\x85'\xC8\xAC\x7FdsolcC\0\x08\x1A\x003",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x60a0806040526004361015610012575f80fd5b5f3560e01c908162fdd58e14612ba05750806301ffc9a714612ae157806307eff0dd14612aa8578063095bcdb6146129fe5780630b0d9c0914612970578063156e29f6146128c05780631e2eaeaf14612886578063234266d71461260f5780632d7713891461254657806335fd631a146124e0578063426a84931461245c57806348c89491146121ff57806352759651146120e7578063558a729714612010578063598af9e714611f785780635a6bcfda146114ba57806360460f0614611480578063695c5bf514610f555780636a256b2914610df35780637e87ce7d14610cc45780638161b87414610bcc5780638da5cb5b14610b7c57806397e8cd4e14610b195780639bf6645f14610add578063a584119414610a9c578063b6363cf214610a0b578063dbd035ff146109cb578063f02de3b21461097a578063f135baaa14610940578063f2fde38b14610894578063f3cd914c14610501578063f5298aca146103345763fe99049a14610186575f80fd5b346103305760807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610330576101bd612c0a565b6101c5612c2d565b90604435917f1b3d7edb2e9c0b0e7c525b20aaaef0f5940d2ed71663c7d39266ecafac72885961027973ffffffffffffffffffffffffffffffffffffffff80606435951693843314158061030d575b610287575b845f52600460205260405f20875f5260205260405f2061023a878254612eb8565b90551693845f52600460205260405f20865f5260205260405f2061025f828254612ec5565b905560408051338152602081019290925290918291820190565b0390a4602060405160018152f35b845f52600560205260405f208233165f5260205260405f20875f5260205260405f2054867fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82036102da575b5050610219565b6102e391612eb8565b855f52600560205260405f208333165f5260205260405f20885f5260205260405f20555f866102d3565b50845f52600360205260405f208233165f5260205260ff60405f20541615610214565b5f80fd5b346103305761034236612c50565b7fc090fc4683624cfc3884e9d8de5eca132f2d0ec062aff75d43c0465d5ceeab239291925c156104d9577f1b3d7edb2e9c0b0e7c525b20aaaef0f5940d2ed71663c7d39266ecafac7288596103ef73ffffffffffffffffffffffffffffffffffffffff5f946103bd6103b386613018565b3390848a1661305e565b169233841415806104a2575b6103f4575b8385526004602052604085208686526020526040852061025f828254612eb8565b0390a4005b83855260056020526040852073ffffffffffffffffffffffffffffffffffffffff33168652602052604085208686526020526040852054817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff820361045b575b50506103ce565b61046491612eb8565b84865260056020526040862073ffffffffffffffffffffffffffffffffffffffff331687526020526040862087875260205260408620558681610454565b5083855260036020526040852073ffffffffffffffffffffffffffffffffffffffff3316865260205260ff604086205416156103c9565b7f54e3ca0d000000000000000000000000000000000000000000000000000000005f5260045ffd5b34610330576101207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103305761053a36612d4c565b60607fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff5c36011261033057604051906060820182811067ffffffffffffffff8211176108675760405260a4358015158103610330578252602082019060c435825260e4359073ffffffffffffffffffffffffffffffffffffffff8216820361033057604084019182526101043567ffffffffffffffff8111610330576105e3903690600401612e18565b9490937fc090fc4683624cfc3884e9d8de5eca132f2d0ec062aff75d43c0465d5ceeab235c156104d9576106156131cd565b511561083f57819060a0822095865f52600660205260405f209561063887613234565b6080840196848383868b5173ffffffffffffffffffffffffffffffffffffffff169361066394613996565b90959198606088015160020b9983511515915173ffffffffffffffffffffffffffffffffffffffff16916040519b61069a8d612cdd565b8c5260208c015260408b015260608a015262ffffff166080890152805115155f14997f40e9cecb9f5f1f1c5b9c97dec2917b7ee92e57ba5563708daca94dd84ad7112f60e062ffffff6107136107bf9c60209f9b6107ac9c61081f575173ffffffffffffffffffffffffffffffffffffffff16976149d7565b9392988291926107f0575b505073ffffffffffffffffffffffffffffffffffffffff6040840151169260606fffffffffffffffffffffffffffffffff60a08301511691015160020b90604051943386528a60801d600f0b60208701528a600f0b60408701526060860152608085015260a08401521660c0820152a28673ffffffffffffffffffffffffffffffffffffffff8a5116613ba3565b809491946107c7575b5050823391613310565b604051908152f35b73ffffffffffffffffffffffffffffffffffffffff6107e99251169083613310565b84806107b5565b73ffffffffffffffffffffffffffffffffffffffff165f5260206001905260405f209081540190555f8061071e565b6020015173ffffffffffffffffffffffffffffffffffffffff16976149d7565b7fbe8b8507000000000000000000000000000000000000000000000000000000005f5260045ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b346103305760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610330577fffffffffffffffffffffffff00000000000000000000000000000000000000006108ec612c0a565b73ffffffffffffffffffffffffffffffffffffffff5f54916109118284163314612ed2565b1691829116175f55337f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e05f80a3005b346103305760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610330576004355c5f5260205ff35b34610330575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261033057602073ffffffffffffffffffffffffffffffffffffffff60025416604051908152f35b34610330576109d936612e46565b604060045f3760051b604001809160208060405b83355481520191019082811015610a0757602080916109ed565b825ff35b346103305760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261033057610a42612c0a565b73ffffffffffffffffffffffffffffffffffffffff610a5f612c2d565b91165f52600360205273ffffffffffffffffffffffffffffffffffffffff60405f2091165f52602052602060ff60405f2054166040519015158152f35b346103305760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103305760206107bf610ad8612c0a565b612faf565b3461033057610aeb36612e46565b604060045f3760051b604001809160208060405b83355c81520191019082811015610a075760208091610aff565b346103305760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103305773ffffffffffffffffffffffffffffffffffffffff610b65612c0a565b165f526001602052602060405f2054604051908152f35b34610330575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261033057602073ffffffffffffffffffffffffffffffffffffffff5f5416604051908152f35b346103305760607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261033057610c03612c0a565b610c0b612c2d565b9060443573ffffffffffffffffffffffffffffffffffffffff600254163303610c9c576020926107bf9180610c94575073ffffffffffffffffffffffffffffffffffffffff81165f526001845260405f20549283915b73ffffffffffffffffffffffffffffffffffffffff81165f526001865260405f20610c8d848254612eb8565b905561314e565b928391610c61565b7f48f5c3ed000000000000000000000000000000000000000000000000000000005f5260045ffd5b346103305760c07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261033057610cfc36612d4c565b610d04612d3a565b9073ffffffffffffffffffffffffffffffffffffffff600254163303610c9c57623e900082106103e9610fff8416101615610dcb57602060a07fe9c42593e71f84403b84352cd168d693e2c9fcd1fdbcc3feb21d92b43e6696f9922092835f526006825260405f20610d7581613234565b805479ffffff00000000000000000000000000000000000000000000008360b81b16907fffffffffffff000000ffffffffffffffffffffffffffffffffffffffffffffff1617905562ffffff60405191168152a2005b7fba97f838000000000000000000000000000000000000000000000000000000005f5260045ffd5b60207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261033057610e25612c0a565b7fc090fc4683624cfc3884e9d8de5eca132f2d0ec062aff75d43c0465d5ceeab235c156104d95773ffffffffffffffffffffffffffffffffffffffff8116610e80576020906107bf34915b610e7983613018565b339161305e565b34610f2d577f1e0745a7db1623981f0b2a5d4232364c00787266eb75ad546f190e6cebe9bd955f528060205260405f205c908115610f0557817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60209314610efe575b610ef86107bf91610ef384612faf565b612eb8565b91610e70565b505f610ee3565b7f8774be48000000000000000000000000000000000000000000000000000000005f5260045ffd5b7f19d245cf000000000000000000000000000000000000000000000000000000005f5260045ffd5b346103305760e07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261033057610f8d36612d4c565b60a43573ffffffffffffffffffffffffffffffffffffffff81168082036103305760c43567ffffffffffffffff811161033057610fce903690600401612e18565b610fd66131cd565b6060850192617fff845160020b13611458576001845160020b126114305773ffffffffffffffffffffffffffffffffffffffff86511692602087019373ffffffffffffffffffffffffffffffffffffffff855116111561140857608087019473ffffffffffffffffffffffffffffffffffffffff86511695604089019661106362ffffff89511682613682565b156113dd575061107862ffffff885116613740565b93815173ffffffffffffffffffffffffffffffffffffffff811690813303611319575b505060a08a20936110ab8b61375d565b9a9050855f52600660205260405f2090815473ffffffffffffffffffffffffffffffffffffffff166112f1576110e090614664565b9a8b9760d01b7cffffff00000000000000000000000000000000000000000000000000001690848960a01b76ffffff000000000000000000000000000000000000000016179060b81b79ffffff0000000000000000000000000000000000000000000000161717905582519173ffffffffffffffffffffffffffffffffffffffff831692833314159c7f3fd553db44f207b1f41348cfc4d251860814af9eadc470e8e7895e4d120511f49960809960209f9662ffffff9673ffffffffffffffffffffffffffffffffffffffff989689979688976111ef575b5050505050505116985116985116925160020b915116916040519384528984015260408301526060820152a36040519060020b8152f35b611000166111fe575b806111b8565b6112b56112e1926112e696604051966020947fa910f80f000000000000000000000000000000000000000000000000000000008996870152336024870152611293604487018c73ffffffffffffffffffffffffffffffffffffffff6080809282815116855282602082015116602086015262ffffff6040820151166040860152606081015160020b6060860152015116910152565b60e486015260020b610104850152610120610124850152610144840191612f71565b037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08101845283612cf9565b613d47565b508e8d8180806111f8565b7f7983c051000000000000000000000000000000000000000000000000000000005f5260045ffd5b61200016611328575b8061109b565b6113d690604051907f3440d8200000000000000000000000000000000000000000000000000000000060208301523360248301526113b48d604484019073ffffffffffffffffffffffffffffffffffffffff6080809282815116855282602082015116602086015262ffffff6040820151166040860152606081015160020b6060860152015116910152565b8360e48301526101006101048301526112e1826112b561012482018c8b612f71565b508a611322565b7fe65af6a0000000000000000000000000000000000000000000000000000000005f5260045260245ffd5b7feaa6c6eb000000000000000000000000000000000000000000000000000000005f5260045ffd5b7f16fe7696000000000000000000000000000000000000000000000000000000005f5260045ffd5b7fb02b5dc2000000000000000000000000000000000000000000000000000000005f5260045ffd5b34610330575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610330576020604051617fff8152f35b34610330576101407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610330576114f336612d4c565b60807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff5c360112610330576040519061152a82612ca5565b60a4358060020b810361033057825260c4358060020b810361033057602083015260e435604083015260608201916101043583526101243567ffffffffffffffff81116103305761157f903690600401612e18565b907fc090fc4683624cfc3884e9d8de5eca132f2d0ec062aff75d43c0465d5ceeab235c156104d9576115af6131cd565b60a0842091825f52600660205260405f20916115ca83613234565b60808601518573ffffffffffffffffffffffffffffffffffffffff821691823303611e9a575b5090505160020b93602086015160020b9561160e6040820151613441565b96606089015160020b99516040519a6116268c612cc1565b338c528860208d01528260408d015289600f0b60608d015260808c015260a08b01525f9080881215611e6b577ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff276188812611e3f57620d89e88113611e1457604051986116908a612ca5565b5f8a525f60208b01525f60408b01525f60608b015280600f0b611b3b575b60048801988060020b5f528960205260405f20998360020b5f5260205260405f20895460a01c60020b8281125f14611ae9575060028060018d0154600184015490039c015491015490039c5b60a073ffffffffffffffffffffffffffffffffffffffff82511691015160265283600652816003525f52603a600c205f6026525f526006890160205260405f20986fffffffffffffffffffffffffffffffff8a54169a83600f0b155f14611a8c578b15611a64576117a560409f6118799c61179f9161188b9f5b6001830195611797600261178b848a548503613ecb565b95019283548503613ecb565b965555613018565b91613018565b6fffffffffffffffffffffffffffffffff169060801b179b5f84600f0b126119fa575b5082600f0b6118c3575b505050506117f96117ea8960801d8360801d01613441565b9189600f0b90600f0b01613441565b6fffffffffffffffffffffffffffffffff169060801b1791815160020b90602083015160020b8b840151908c5193845260208401528b8301527f541c041c2cce48e614b3de043c9280f06b6164c0a1741649e2de3c3d375f797460603393a38773ffffffffffffffffffffffffffffffffffffffff608082015116613530565b80949194611897575b50833391613310565b82519182526020820152f35b6118bd9073ffffffffffffffffffffffffffffffffffffffff6080840151169083613310565b85611882565b809192939450548060a01c60020b9073ffffffffffffffffffffffffffffffffffffffff16908381125f1461192b57505050916119199161191361190961191e956141dc565b91600f0b926141dc565b906145b3565b613441565b60801b5b8a8080806117d2565b948091939295125f146119c6576fffffffffffffffffffffffffffffffff926119836119196119999461197061191960039661196a8b600f0b916141dc565b876145b3565b9361197e89600f0b926141dc565b61452a565b84169060801b17940192600f0b82845416614604565b167fffffffffffffffffffffffffffffffff00000000000000000000000000000000825416179055611922565b91506119e39350916119dd611909611919946141dc565b9061452a565b6fffffffffffffffffffffffffffffffff16611922565b808f9151611a3a575b0151611a10575b8e6117c8565b611a35848260049160020b5f52016020525f6002604082208281558260018201550155565b611a0a565b611a5f848460049160020b5f52016020525f6002604082208281558260018201550155565b611a03565b7faefeb924000000000000000000000000000000000000000000000000000000005f5260045ffd5b6117a560409f6118799c61179f9161188b9f6fffffffffffffffffffffffffffffffff611abc8a600f0b83614604565b167fffffffffffffffffffffffffffffffff00000000000000000000000000000000845416178355611774565b909a908413611b0f5760028060018d0154600184015490039c015491015490039c6116fa565b99600260018b015460018d01549003600183015490039b81808d0154910154900391015490039c6116fa565b8860020b5f5260048801602052886fffffffffffffffffffffffffffffffff60405f20805490611b95838316928d611b7688600f0b86614604565b9415968787871615141597611de5575b505086600f0b9060801d613b5c565b60801b821790551660208c01528a528160020b5f526004880160205260405f208054906fffffffffffffffffffffffffffffffff8216611bd884600f0b82614604565b901592836fffffffffffffffffffffffffffffffff831615141593611dbe575b84600f0b9060801d600f0b03916f7fffffffffffffffffffffffffffffff83137fffffffffffffffffffffffffffffffff80000000000000000000000000000000841217611d9157826fffffffffffffffffffffffffffffffff935060801b821790551660608c015260408b0152898c5f83600f0b1215611cb9575b5051611c9f575b60408a0151156116ae57611c9a60808d015160020b8360058b016141a3565b6116ae565b611cb460808d015160020b8a60058b016141a3565b611c7b565b60016fffffffffffffffffffffffffffffffff602060808294015160020b940151169280807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff2761805028180620d89e80502030501810416809111611d65576fffffffffffffffffffffffffffffffff60608c01511611611d3957898c611c74565b507fb8e3c385000000000000000000000000000000000000000000000000000000005f5260045260245ffd5b897fb8e3c385000000000000000000000000000000000000000000000000000000005f5260045260245ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b8b5460a01c60020b8613611bf85760018c0154600184015560028c01546002840155611bf8565b815460a01c60020b1215611dfa575b8f611b86565b80600160029201546001860155015460028401558d611df4565b7f1ad777f8000000000000000000000000000000000000000000000000000000005f5260045260245ffd5b877fd5e2f7ab000000000000000000000000000000000000000000000000000000005f5260045260245ffd5b877fc4433ed5000000000000000000000000000000000000000000000000000000005f5260045260245260445ffd5b5f604083015113808091611f6b575b15611efd575050611ef3916112e1896112b587876040519687947f259982e50000000000000000000000000000000000000000000000000000000060208701523360248701613387565b505b8785816115f0565b159081611f5d575b50611f12575b5050611ef5565b611f55916112e1896112b587876040519687947f21d0ee700000000000000000000000000000000000000000000000000000000060208701523360248701613387565b508785611f0b565b61020091501615158a611f05565b5061080082161515611ea9565b346103305760607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261033057611faf612c0a565b73ffffffffffffffffffffffffffffffffffffffff611fcc612c2d565b91165f52600560205273ffffffffffffffffffffffffffffffffffffffff60405f2091165f5260205260405f206044355f52602052602060405f2054604051908152f35b346103305760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261033057612047612c0a565b602435908115158092036103305773ffffffffffffffffffffffffffffffffffffffff90335f52600360205260405f208282165f5260205260405f207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0081541660ff851617905560405192835216907fceb576d9f15e4e200fdb5096d64d5dfd667e16def20c1eefd14256d8e3faa26760203392a3602060405160018152f35b346103305760c07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103305761211f36612d4c565b612127612d3a565b906280000062ffffff604083015116148015906121db575b6121b35760a09061214f8361334e565b205f52600660205260405f209061216582613234565b81547fffffff000000ffffffffffffffffffffffffffffffffffffffffffffffffffff1660d09190911b7cffffff000000000000000000000000000000000000000000000000000016179055005b7f30d21641000000000000000000000000000000000000000000000000000000005f5260045ffd5b5073ffffffffffffffffffffffffffffffffffffffff60808201511633141561213f565b346103305760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103305760043567ffffffffffffffff81116103305761224e903690600401612e18565b7fc090fc4683624cfc3884e9d8de5eca132f2d0ec062aff75d43c0465d5ceeab235c612434576122da915f9160017fc090fc4683624cfc3884e9d8de5eca132f2d0ec062aff75d43c0465d5ceeab235d60405193849283927f91dd7346000000000000000000000000000000000000000000000000000000008452602060048501526024840191612f71565b038183335af1908115612429575f916123af575b507f7d4b3164c6e45b97e7d87b7125a44c5828d005af88f9d751cfd78729c5d99a0b5c6123875760406020915f7fc090fc4683624cfc3884e9d8de5eca132f2d0ec062aff75d43c0465d5ceeab235d7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f835194859381855280519182918282880152018686015e5f85828601015201168101030190f35b7f5212cba1000000000000000000000000000000000000000000000000000000005f5260045ffd5b90503d805f833e6123c08183612cf9565b8101906020818303126103305780519067ffffffffffffffff8211610330570181601f82011215610330578051906123f782612f37565b926124056040519485612cf9565b8284526020838301011161033057815f9260208093018386015e83010152816122ee565b6040513d5f823e3d90fd5b7f5090d6c6000000000000000000000000000000000000000000000000000000005f5260045ffd5b346103305773ffffffffffffffffffffffffffffffffffffffff61247f36612c50565b91929092335f52600560205260405f208282165f5260205260405f20845f526020528260405f205560405192835216907fb3fd5071835887567a0671151121894ddccc2842f1d10bedad13e0d17cace9a760203392a4602060405160018152f35b346103305760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103305760043560205f5260243560051b8060205260400180916001602060405b835481520191019082811015610a0757602060019161252c565b346103305760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103305760043573ffffffffffffffffffffffffffffffffffffffff81168091036103305760207fb4bd8ef53df690b9943d3318996006dbb82a25f54719d8c8035b516a2a5b8acc916125dc73ffffffffffffffffffffffffffffffffffffffff5f54163314612ed2565b807fffffffffffffffffffffffff00000000000000000000000000000000000000006002541617600255604051908152a1005b34610330576101007ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103305761264836612d4c565b60c4359060a43560e43567ffffffffffffffff81116103305761266f903690600401612e18565b9190937fc090fc4683624cfc3884e9d8de5eca132f2d0ec062aff75d43c0465d5ceeab235c156104d9576126a16131cd565b60a084205f52600660205260405f20946126ba86613234565b6080850194855173ffffffffffffffffffffffffffffffffffffffff81169081330361282e575b50506fffffffffffffffffffffffffffffffff6003880154169586156128065760209761270d86613018565b5f0361271886613018565b5f036fffffffffffffffffffffffffffffffff169060801b1797866127ed575b856127d2575b505061274b338884613310565b519273ffffffffffffffffffffffffffffffffffffffff841693843303612777575b8888604051908152f35b601016612785575b8061276d565b6127c6956112e1936112b5926040519788957fe1b4af69000000000000000000000000000000000000000000000000000000008d880152336024880161327a565b5082808080808061277f565b6127de60029187613e0a565b9101908154019055888061273e565b6127f78188613e0a565b60018301908154019055612738565b7fa74f97ab000000000000000000000000000000000000000000000000000000005f5260045ffd5b60201661283c575b806126e1565b6040517fb6a8b0fa00000000000000000000000000000000000000000000000000000000602082015261287f916112e1826112b58a888a8c8a336024880161327a565b5087612836565b346103305760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261033057600435545f5260205ff35b34610330576128ce36612c50565b90917fc090fc4683624cfc3884e9d8de5eca132f2d0ec062aff75d43c0465d5ceeab235c156104d9577f1b3d7edb2e9c0b0e7c525b20aaaef0f5940d2ed71663c7d39266ecafac7288596103ef73ffffffffffffffffffffffffffffffffffffffff5f9361294d61293e87613018565b8603600f0b3390848a1661305e565b16938484526004602052604084208685526020526040842061025f828254612ec5565b346103305760607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610330576129a7612c0a565b6129af612c2d565b604435907fc090fc4683624cfc3884e9d8de5eca132f2d0ec062aff75d43c0465d5ceeab235c156104d9576129fc926129f76129ea84613018565b5f03600f0b33908361305e565b61314e565b005b346103305773ffffffffffffffffffffffffffffffffffffffff612a2136612c50565b91929092335f52600460205260405f20845f5260205260405f20612a46848254612eb8565b90551690815f52600460205260405f20835f5260205260405f20612a6b828254612ec5565b9055604080513380825260208201939093527f1b3d7edb2e9c0b0e7c525b20aaaef0f5940d2ed71663c7d39266ecafac7288599181908101610279565b34610330575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261033057602060405160018152f35b346103305760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610330576004357fffffffff00000000000000000000000000000000000000000000000000000000811680910361033057807f01ffc9a70000000000000000000000000000000000000000000000000000000060209214908115612b76575b506040519015158152f35b7f0f632fb30000000000000000000000000000000000000000000000000000000091501482612b6b565b346103305760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103305760209073ffffffffffffffffffffffffffffffffffffffff612bef612c0a565b165f526004825260405f206024355f52825260405f20548152f35b6004359073ffffffffffffffffffffffffffffffffffffffff8216820361033057565b6024359073ffffffffffffffffffffffffffffffffffffffff8216820361033057565b7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc60609101126103305760043573ffffffffffffffffffffffffffffffffffffffff8116810361033057906024359060443590565b6080810190811067ffffffffffffffff82111761086757604052565b60c0810190811067ffffffffffffffff82111761086757604052565b60a0810190811067ffffffffffffffff82111761086757604052565b90601f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0910116810190811067ffffffffffffffff82111761086757604052565b60a4359062ffffff8216820361033057565b7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc60a09101126103305760405190612d8382612cdd565b8160043573ffffffffffffffffffffffffffffffffffffffff8116810361033057815260243573ffffffffffffffffffffffffffffffffffffffff8116810361033057602082015260443562ffffff811681036103305760408201526064358060020b81036103305760608201526084359073ffffffffffffffffffffffffffffffffffffffff821682036103305760800152565b9181601f840112156103305782359167ffffffffffffffff8311610330576020838186019501011161033057565b9060207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc8301126103305760043567ffffffffffffffff811161033057826023820112156103305780600401359267ffffffffffffffff84116103305760248460051b83010111610330576024019190565b91908203918211611d9157565b91908201809211611d9157565b15612ed957565b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600c60248201527f554e415554484f52495a454400000000000000000000000000000000000000006044820152fd5b67ffffffffffffffff811161086757601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01660200190565b601f82602094937fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe093818652868601375f8582860101520116010190565b90612fb9826138ff565b9182908315612ff0575b7f1e0745a7db1623981f0b2a5d4232364c00787266eb75ad546f190e6cebe9bd955f5260205260405f205d565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff9150612fc3565b6f8000000000000000000000000000000081101561303657600f0b90565b6393dafdf15f526004601cfd5b9190915f8382019384129112908015821691151617611d9157565b90600f0b91821561314957805f528160205261307f60405f205c9384613043565b92836130f957507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f7d4b3164c6e45b97e7d87b7125a44c5828d005af88f9d751cfd78729c5d99a0b5c017f7d4b3164c6e45b97e7d87b7125a44c5828d005af88f9d751cfd78729c5d99a0b5d5b5f5260205260405f205d565b6130ed5760017f7d4b3164c6e45b97e7d87b7125a44c5828d005af88f9d751cfd78729c5d99a0b5c017f7d4b3164c6e45b97e7d87b7125a44c5828d005af88f9d751cfd78729c5d99a0b5d6130ed565b505050565b73ffffffffffffffffffffffffffffffffffffffff811661318657505f80809381935af11561317957565b63f4b3b1bc5f526004601cfd5b60105f60449260209582956014526034526fa9059cbb00000000000000000000000082525af13d1560015f51141716156131c0575f603452565b63f27f64e45f526004601cfd5b73ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016300361320c57565b7f0d89438e000000000000000000000000000000000000000000000000000000005f5260045ffd5b5473ffffffffffffffffffffffffffffffffffffffff161561325257565b7f486aa307000000000000000000000000000000000000000000000000000000005f5260045ffd5b91926132f56101209473ffffffffffffffffffffffffffffffffffffffff61330d999794168552602085019073ffffffffffffffffffffffffffffffffffffffff6080809282815116855282602082015116602086015262ffffff6040820151166040860152606081015160020b6060860152015116910152565b60c083015260e0820152816101008201520191612f71565b90565b9073ffffffffffffffffffffffffffffffffffffffff602061334c949361333f85848351168660801d9061305e565b01511690600f0b9061305e565b565b62ffffff620f424091161161335f57565b7ffc5bee12000000000000000000000000000000000000000000000000000000005f5260045ffd5b9061330d95936134046101609473ffffffffffffffffffffffffffffffffffffffff61343394168552602085019073ffffffffffffffffffffffffffffffffffffffff6080809282815116855282602082015116602086015262ffffff6040820151166040860152606081015160020b6060860152015116910152565b8051600290810b60c08501526020820151900b60e0840152604081015161010084015260600151610120830152565b816101408201520191612f71565b806f800000000000000000000000000000000160801c15613469576393dafdf15f526004601cfd5b600f0b90565b91610180936134ed61351c9273ffffffffffffffffffffffffffffffffffffffff61330d9a9895168652602086019073ffffffffffffffffffffffffffffffffffffffff6080809282815116855282602082015116602086015262ffffff6040820151166040860152606081015160020b6060860152015116910152565b8051600290810b60c08601526020820151900b60e0850152604081015161010085015260600151610120840152565b610140820152816101608201520191612f71565b929593945f9573ffffffffffffffffffffffffffffffffffffffff8516331461367857875f6040860151135f1461360a576104008616613573575b505050505050565b6135fe969897506135eb926135f7969594926135bf926040519687957f5a2a8100000000000000000000000000000000000000000000000000000000006020880152336024880161346f565b037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08101835282612cf9565b60028216151591614610565b8092614627565b915f808080808061356b565b9493929190610100851661362057505050505050565b6135fe96985085975061366c92916135bf916135f7976040519687957f8db2b652000000000000000000000000000000000000000000000000000000006020880152336024880161346f565b60018216151591614610565b505f955050505050565b608081161580613734575b61370a57604081161580613728575b61370a576104008116158061371c575b61370a5761010081161580613710575b61370a5773ffffffffffffffffffffffffffffffffffffffff81166136ea575062ffffff1662800000141590565b613fff1615908115916136fb575090565b62800000915062ffffff161490565b50505f90565b506001811615156136bc565b506002811615156136ac565b5060048116151561369c565b5060088116151561368d565b6280000062ffffff8216146137585761330d8161334e565b505f90565b5f915f9173ffffffffffffffffffffffffffffffffffffffff6002541680613783575050565b91935091505a7f00000000000000000000000000000000000000000000000000000000000000008091106138d7575f9283809360405161383860208201947f553bfc37000000000000000000000000000000000000000000000000000000008652602483019073ffffffffffffffffffffffffffffffffffffffff6080809282815116855282602082015116602086015262ffffff6040820151166040860152606081015160020b6060860152015116910152565b60a4815261384760c482612cf9565b5193f13d156138cf573d9061385b82612f37565b916138696040519384612cf9565b82523d5f602084013e5b1580156138c4575b6138bd576020015162ffffff81169081811490816138a5575b501561389f57600191565b505f8091565b90506103e9610fff623e90008410921610165f613894565b505f905f90565b50602081511161387b565b606090613873565b7f1ee49702000000000000000000000000000000000000000000000000000000005f5260045ffd5b73ffffffffffffffffffffffffffffffffffffffff168061391f57504790565b6020602491604051928380927f70a082310000000000000000000000000000000000000000000000000000000082523060048301525afa908115612429575f91613967575090565b90506020813d60201161398e575b8161398260209383612cf9565b81010312610330575190565b3d9150613975565b949192945f945f9460208101519773ffffffffffffffffffffffffffffffffffffffff84163314613b4f57608084166139d1575b5050505050565b613ac3613a73613abd876135bf6040956280000098613aa962ffffff9989519788967f575e24b4000000000000000000000000000000000000000000000000000000006020890152336024890152604488019073ffffffffffffffffffffffffffffffffffffffff6080809282815116855282602082015116602086015262ffffff6040820151166040860152606081015160020b6060860152015116910152565b8051151560e487015260208101516101048701526040015173ffffffffffffffffffffffffffffffffffffffff16610124860152565b610140610144850152610164840191612f71565b85613d47565b9401511614613b43575b600816613ade575b808080806139ca565b604001519250608083901d600f0b8015613ad557613aff905f861295613043565b9315613b3b575f84135b613b13575f613ad5565b7ffa0b71d6000000000000000000000000000000000000000000000000000000005f5260045ffd5b5f8412613b09565b60608201519350613acd565b505f965086955050505050565b90600f0b90600f0b01907fffffffffffffffffffffffffffffffff8000000000000000000000000000000082126f7fffffffffffffffffffffffffffffff831317611d9157565b9196959394929473ffffffffffffffffffffffffffffffffffffffff83163314613d3a578460801d94600f0b938860408516613c62575b50505050505f9481600f0b15801590613c56575b613bfa575b5050509190565b613c319395505f60208201511290511515145f14613c39576fffffffffffffffffffffffffffffffff169060801b175b8093614627565b5f8080613bf3565b906fffffffffffffffffffffffffffffffff169060801b17613c2a565b5082600f0b1515613bee565b613d1e613d2a946135bf61191995613d30999895613d03613a73966040519788967fb47b2fb1000000000000000000000000000000000000000000000000000000006020890152336024890152604488019073ffffffffffffffffffffffffffffffffffffffff6080809282815116855282602082015116602086015262ffffff6040820151166040860152606081015160020b6060860152015116910152565b8c610144850152610160610164850152610184840191612f71565b60048216151591614610565b90613b5c565b5f80808088613bda565b5050505050909150905f90565b5f80939281926020825192019586915af115613def57604051917fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0603f3d011683016040523d83527fffffffff00000000000000000000000000000000000000000000000000000000803d60208601905f823e51925116911603613dc757565b7f1e048e1d000000000000000000000000000000000000000000000000000000005f5260045ffd5b3d15613dfd573d5f803e3d5ffd5b6336bc48c55f526004601cfd5b908160801b907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7001000000000000000000000000000000008409928280851094039380850394858411156103305714613ec45770010000000000000000000000000000000082910981805f03168092046002816003021880820260020302808202600203028082026002030280820260020302808202600203028091026002030293600183805f03040190848311900302920304170290565b5091500490565b90808202917fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8282099183808410930392808403938470010000000000000000000000000000000011156103305714613f4457700100000000000000000000000000000000910990828211900360801b910360801c1790565b50505060801c90565b90808202917fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff828209918380841093039280840393846c0100000000000000000000000011156103305714613fbe576c01000000000000000000000000910990828211900360a01b910360601c1790565b50505060601c90565b818102907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff83820990828083109203918083039283620f424011156103305714614046577fde8f6cefed634549b62c77574f722e1ac57e23f24d8fd5cb790fb65668c2613993620f4240910990828211900360fa1b910360061c170290565b5050620f424091500490565b908160601b907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff6c010000000000000000000000008409928280851094039380850394858411156103305714613ec4576c0100000000000000000000000082910981805f03168092046002816003021880820260020302808202600203028082026002030280820260020302808202600203028091026002030293600183805f03040190848311900302920304170290565b91818302917fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff81850993838086109503948086039586851115610330571461419b579082910981805f03168092046002816003021880820260020302808202600203028082026002030280820260020302808202600203028091026002030293600183805f03040190848311900302920304170290565b505091500490565b91908181076141c95705908160081d5f52602052600160ff60405f2092161b8154189055565b63d4d8f3e65f526020526040526044601cfd5b8060ff1d81810118620d89e8811161451d5763ffffffff91600182167001fffcb933bd6fad37aa2d162d1a59400102700100000000000000000000000000000000189160028116614501575b600481166144e5575b600881166144c9575b601081166144ad575b60208116614491575b60408116614475575b60808116614459575b610100811661443d575b6102008116614421575b6104008116614405575b61080081166143e9575b61100081166143cd575b61200081166143b1575b6140008116614395575b6180008116614379575b62010000811661435d575b620200008116614342575b620400008116614327575b620800001661430e575b5f126142e7575b0160201c90565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff046142e0565b6b048a170391f7dc42444e8fa290910260801c906142d9565b6d2216e584f5fa1ea926041bedfe9890920260801c916142cf565b916e5d6af8dedb81196699c329225ee6040260801c916142c4565b916f09aa508b5b7a84e1c677de54f3e99bc90260801c916142b9565b916f31be135f97d08fd981231505542fcfa60260801c916142ae565b916f70d869a156d2a1b890bb3df62baf32f70260801c916142a4565b916fa9f746462d870fdf8a65dc1f90e061e50260801c9161429a565b916fd097f3bdfd2022b8845ad8f792aa58250260801c91614290565b916fe7159475a2c29b7443b29c7fa6e889d90260801c91614286565b916ff3392b0822b70005940c7a398e4b70f30260801c9161427c565b916ff987a7253ac413176f2b074cf7815e540260801c91614272565b916ffcbe86c7900a88aedcffc83b479aa3a40260801c91614268565b916ffe5dee046a99a2a811c461f1969c30530260801c9161425e565b916fff2ea16466c96a3843ec78b326b528610260801c91614255565b916fff973b41fa98c081472e6896dfb254c00260801c9161424c565b916fffcb9843d60f6159c9db58835c9266440260801c91614243565b916fffe5caca7e10e4e61c3624eaa0941cd00260801c9161423a565b916ffff2e50f5f656932ef12357cf3c7fdcc0260801c91614231565b916ffff97272373d413259a46990580e213a0260801c91614228565b63ce8ef7fc5f526004601cfd5b5f83600f0b125f1461456757916145629161330d93038060ff1d90810118905f036fffffffffffffffffffffffffffffffff16613f4d565b615a26565b906c010000000000000000000000006001916145ae946fffffffffffffffffffffffffffffffff1693038060ff1d908101186145a38185613f4d565b930915151601615a26565b5f0390565b915f81600f0b125f146145e357916145629161330d935f036fffffffffffffffffffffffffffffffff1691615ae0565b91614562916145ae936fffffffffffffffffffffffffffffffff1691615a3b565b01908160801c61303657565b9061461a91613d47565b9015613758576040015190565b61464a9061463c8360801d8260801d03613441565b92600f0b90600f0b03613441565b6fffffffffffffffffffffffffffffffff169060801b1790565b73fffd8963efd1fc6a506488495d951d51639616827ffffffffffffffffffffffffffffffffffffffffffffffffffffffffefffd895d8201116149935777ffffffffffffffffffffffffffffffffffffffff000000008160201b16806fffffffffffffffffffffffffffffffff811160071b90811c67ffffffffffffffff811160061b90811c63ffffffff811160051b90811c61ffff811160041b90811c9060ff821160031b91821c92600f841160021b93841c94600160038711811b96871c1196171717171717179060808210155f14614989577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8182011c5b800280607f1c8160ff1c1c800280607f1c8160ff1c1c800280607f1c8160ff1c1c800280607f1c8160ff1c1c800280607f1c8160ff1c1c800280607f1c8160ff1c1c80029081607f1c8260ff1c1c80029283607f1c8460ff1c1c80029485607f1c8660ff1c1c80029687607f1c8860ff1c1c80029889607f1c8a60ff1c1c80029a8b607f1c8c60ff1c1c80029c8d80607f1c9060ff1c1c800260cd1c6604000000000000169d60cc1c6608000000000000169c60cb1c6610000000000000169b60ca1c6620000000000000169a60c91c6640000000000000169960c81c6680000000000000169860c71c670100000000000000169760c61c670200000000000000169660c51c670400000000000000169560c41c670800000000000000169460c31c671000000000000000169360c21c672000000000000000169260c11c674000000000000000169160c01c67800000000000000016907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff800160401b1717171717171717171717171717693627a301d71055774c85027ffffffffffffffffffffffffffffffffffd709b7e5480fba5a50fed5e62ffc556810160801d60020b906fdb2df09e81959a81455e260799a0632f0160801d60020b918282145f146149465750905090565b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff61497a846141dc565b1611614984575090565b905090565b81607f031b61475e565b6331efafe85f526004601cfd5b81156149aa570490565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b905f6040516149e581612cc1565b5f815260208101905f825260408101955f875260608201945f865260808301915f83525f60a08501528398885493602084015115986fffffffffffffffffffffffffffffffff60038c015416928a155f14615a17575f610fff8860b81c16995b60408801518a52528673ffffffffffffffffffffffffffffffffffffffff1690528560a01c60020b905288155f14615a0c5760018a0154905b5260a085018190526080830151624000008116156159fd5762bfffff16614aa48161334e565b61ffff87166159dc57905b81945f604086015112928315978880996159cb575b6159a35760408701511561598d57505089615919576060850173ffffffffffffffffffffffffffffffffffffffff8151168273ffffffffffffffffffffffffffffffffffffffff168110156158d457505173ffffffffffffffffffffffffffffffffffffffff166401000276a38111156158a957505b60405160805260e060805101608051811067ffffffffffffffff821117610867576040525f608051525f602060805101525f604060805101525f606060805101525f6080805101525f60a060805101525f60c060805101525b8b5115801561586c575b61571c5773ffffffffffffffffffffffffffffffffffffffff60408d0151166080515260608c015160020b855160020b90815f818307129105038c8c155f1461548e575060ff8116918d60056001851b918460081d60010b5f52016020527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60405f209180010190541691821592831593845f146154595781955f91610330577ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff27618968370010000000000000000000000000000000060ff95101561544a575b508068010000000000000000600292101561543c575b64010000000081101561542e575b62010000811015615420575b610100811015615412575b6010811015615404575b60048110156153f7575b10156153ea575b031660020b900360020b0260020b5b905b15156040608051015260020b806020608051015213156153bd575b620d89e86020608051015160020b12156153ad575b8b73ffffffffffffffffffffffffffffffffffffffff604081614d3e6020608051015160020b6141dc565b169283606060805101520151169073ffffffffffffffffffffffffffffffffffffffff60608801511690818d158183101891180218908d6fffffffffffffffffffffffffffffffff60a08201511690519062ffffff8a169273ffffffffffffffffffffffffffffffffffffffff8516811015915f84125f146151f35784620f424003614dcc81865f03613fc7565b9684156151c157614dde838583615a3b565b955b8689106150c9575073ffffffffffffffffffffffffffffffffffffffff9750958691620f424082036150ba575050845b935b156150ac5791614e2b92038060ff1d9081011890613f4d565b905b60c0608051015260a060805101526080805101521660408d0152865f1461506c57614e5d60a06080510151615a26565b8c51038c5260208c01805190614e8261456260808051015160c0608051015190612ec5565b915f8382039312818412811691841390151617611d9157525b61ffff8816615039575b6fffffffffffffffffffffffffffffffff60a08d01511680615019575b5073ffffffffffffffffffffffffffffffffffffffff60408d01511673ffffffffffffffffffffffffffffffffffffffff606060805101511681145f14614fdb575060406080510151614f2a575b89156020608051015160020b0360020b60608d0152614b93565b89614fb2576fffffffffffffffffffffffffffffffff614f998d8d60808201519060046002820154915b6020608051015160020b60020b5f520160205260405f2091600183019081549003905560028201908154900390555460801d908d15614fa4575b60a001518316614604565b1660a08d0152614f10565b5f91909103600f0b90614f8e565b6fffffffffffffffffffffffffffffffff614f998d8d6001810154906004608084015191614f54565b73ffffffffffffffffffffffffffffffffffffffff60805151168103615002575b50614b93565b61500b90614664565b60020b60608d01525f614ffc565b6150299060c06080510151613e0a565b60808d019081510190525f614ec2565b97620f424060808051015161ffff8a169060c06080510151010204908160c060805101510360c060805101520197614ea5565b61508260808051015160c0608051015101615a26565b8c51018c5260208c016150a5815161509f60a06080510151615a26565b90613043565b9052614e9b565b6150b592615ae0565b614e2b565b6150c49187615b75565b614e10565b95505050809450158115176151b45773ffffffffffffffffffffffffffffffffffffffff948215615150576150ff908583615c13565b935b84808284861561511f5761511492615a3b565b8095015f0393614e12565b9050038060ff1d9081011860016c010000000000000000000000006151448386613f4d565b92850915151601615114565b61518c90615187908781116151925761517f906fffffffffffffffffffffffffffffffff88169060601b6149a0565b878416612ec5565b615ca1565b93615101565b6151af906fffffffffffffffffffffffffffffffff881690614052565b61517f565b634f2461b85f526004601cfd5b8084038060ff1d9081011860016c010000000000000000000000006151e68387613f4d565b9286091515160195614de0565b909491939291841561539c576152138682038060ff1d9081011883613f4d565b925b83811061528e57509073ffffffffffffffffffffffffffffffffffffffff956152599280965b1561525e579061524b9291615a3b565b809380620f42400391615b75565b614e2d565b6c0100000000000000000000000090600192038060ff1d908101186152838185613f4d565b93091515160161524b565b9250508181158615176151b45784156153725773ffffffffffffffffffffffffffffffffffffffff81116153195760601b6fffffffffffffffffffffffffffffffff82168082061515910401905b8186111561530c578573ffffffffffffffffffffffffffffffffffffffff615259938180991603165b809661523b565b634323a5555f526004601cfd5b6fffffffffffffffffffffffffffffffff8216615344816c0100000000000000000000000084614104565b9181156149aa576c010000000000000000000000009009615366575b906152dc565b60010180615360575f80fd5b9085615397615259938373ffffffffffffffffffffffffffffffffffffffff99615b9e565b615305565b6153a7828288615ae0565b92615215565b620d89e860206080510152614d13565b7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff2761860206080510152614cfe565b9060018391011690614cd2565b928101841692811c614ccb565b60049384018516931c614cc1565b60089384018516931c614cb7565b60109384018516931c614cac565b60209384018516931c614ca0565b60409384018516931c614c92565b60809350831c90506002614c7c565b50507ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff276189360020b900360020b0260020b614ce1565b90600101918260020b9260058160ff16938560081d60010b5f52016020527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff600160ff60405f2093161b011990541692831593841593845f146156e2578195610330577ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff276189560ff9283906fffffffffffffffffffffffffffffffff8116156156d8575050607f5b67ffffffffffffffff8216156156ce577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc00183165b63ffffffff8216156156c4577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe00183165b61ffff8216156156ba577ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00183165b818416156156b0577ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff80183165b600f8216156156a6577ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc0183165b600382161561569a57837ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe6001920116915b16615671575b031660020b0160020b0260020b5b90614ce3565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff01821661565d565b9060019060021c615657565b9060041c90615625565b9060081c906155f7565b9060101c906155ca565b9060201c9061559b565b9060401c9061556a565b60801c9150615535565b7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff27618955060ff809250031660020b0160020b0260020b61566b565b91955091999698929550969296606087015160a01b76ffffff0000000000000000000000000000000000000000167fffffffffffffffffff000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff60408a0151169216171782556fffffffffffffffffffffffffffffffff60a087015116809103615827575b50811561581857600260808601519101555b15146157fb576157e160406157d56020850151613441565b92015183519003613441565b6fffffffffffffffffffffffffffffffff169060801b1793565b60400151815161580b9103613441565b6157e16020830151613441565b600160808601519101556157bd565b6fffffffffffffffffffffffffffffffff167fffffffffffffffffffffffffffffffff000000000000000000000000000000006003830154161760038201555f6157ab565b5073ffffffffffffffffffffffffffffffffffffffff60408d01511673ffffffffffffffffffffffffffffffffffffffff60608701511614614b9d565b7f9e4d7cc7000000000000000000000000000000000000000000000000000000005f5260045260245ffd5b827f7c9c6e8f000000000000000000000000000000000000000000000000000000005f5273ffffffffffffffffffffffffffffffffffffffff1660045260245260445ffd5b6060850173ffffffffffffffffffffffffffffffffffffffff8151168273ffffffffffffffffffffffffffffffffffffffff168111156158d457505173ffffffffffffffffffffffffffffffffffffffff1673fffd8963efd1fc6a506488495d951d5263988d268110156158a95750614b3a565b9a509a50505050975050505050505f925f929190565b7f96206246000000000000000000000000000000000000000000000000000000005f5260045ffd5b50620f424062ffffff831614614ac4565b8061ffff881602620f424080820615159104019061ffff8816010390614aaf565b508360d01c62ffffff16614aa4565b60028a015490614a7e565b5f610fff8860c41c1699614a45565b5f81121561330d576393dafdf15f526004601cfd5b9173ffffffffffffffffffffffffffffffffffffffff821673ffffffffffffffffffffffffffffffffffffffff841611615ad8575b8215615acc5773ffffffffffffffffffffffffffffffffffffffff91615abf917bffffffffffffffffffffffffffffffff00000000000000000000000084868185169403169160601b16615b75565b9116808206151591040190565b62bfc9215f526004601cfd5b919091615a70565b9073ffffffffffffffffffffffffffffffffffffffff811673ffffffffffffffffffffffffffffffffffffffff831611615b6f575b8115615acc57615b6773ffffffffffffffffffffffffffffffffffffffff9161330d947bffffffffffffffffffffffffffffffff00000000000000000000000084868185169403169160601b16614104565b9116906149a0565b90615b15565b929190615b83828286614104565b9382156149aa5709615b9157565b9060010190811561033057565b908215615c0d577bffffffffffffffffffffffffffffffff0000000000000000000000009060601b1673ffffffffffffffffffffffffffffffffffffffff82169283810292838311918404141615615c005761330d9261518792820391615b75565b63f5c787f15f526004601cfd5b50905090565b90918015615c0d5773ffffffffffffffffffffffffffffffffffffffff7bffffffffffffffffffffffffffffffff000000000000000000000000819460601b16921680820281615c6384836149a0565b14615c89575b5090615c78615c7d92846149a0565b612ec5565b80820615159104011690565b8301838110615c69579150615c9d92615b75565b1690565b740100000000000000000000000000000000000000008110156130365773ffffffffffffffffffffffffffffffffffffffff169056fea26469706673582212206cdb38c1d8509f6bd20bb1a66e49983e35dea09f2c8d6d2b81e8e58527c8ac7f64736f6c634300081a0033
    /// ```
    #[rustfmt::skip]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\xA0\x80`@R`\x046\x10\x15a\0\x12W_\x80\xFD[_5`\xE0\x1C\x90\x81b\xFD\xD5\x8E\x14a+\xA0WP\x80c\x01\xFF\xC9\xA7\x14a*\xE1W\x80c\x07\xEF\xF0\xDD\x14a*\xA8W\x80c\t[\xCD\xB6\x14a)\xFEW\x80c\x0B\r\x9C\t\x14a)pW\x80c\x15n)\xF6\x14a(\xC0W\x80c\x1E.\xAE\xAF\x14a(\x86W\x80c#Bf\xD7\x14a&\x0FW\x80c-w\x13\x89\x14a%FW\x80c5\xFDc\x1A\x14a$\xE0W\x80cBj\x84\x93\x14a$\\W\x80cH\xC8\x94\x91\x14a!\xFFW\x80cRu\x96Q\x14a \xE7W\x80cU\x8Ar\x97\x14a \x10W\x80cY\x8A\xF9\xE7\x14a\x1FxW\x80cZk\xCF\xDA\x14a\x14\xBAW\x80c`F\x0F\x06\x14a\x14\x80W\x80ci\\[\xF5\x14a\x0FUW\x80cj%k)\x14a\r\xF3W\x80c~\x87\xCE}\x14a\x0C\xC4W\x80c\x81a\xB8t\x14a\x0B\xCCW\x80c\x8D\xA5\xCB[\x14a\x0B|W\x80c\x97\xE8\xCDN\x14a\x0B\x19W\x80c\x9B\xF6d_\x14a\n\xDDW\x80c\xA5\x84\x11\x94\x14a\n\x9CW\x80c\xB66<\xF2\x14a\n\x0BW\x80c\xDB\xD05\xFF\x14a\t\xCBW\x80c\xF0-\xE3\xB2\x14a\tzW\x80c\xF15\xBA\xAA\x14a\t@W\x80c\xF2\xFD\xE3\x8B\x14a\x08\x94W\x80c\xF3\xCD\x91L\x14a\x05\x01W\x80c\xF5)\x8A\xCA\x14a\x034Wc\xFE\x99\x04\x9A\x14a\x01\x86W_\x80\xFD[4a\x030W`\x80\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030Wa\x01\xBDa,\nV[a\x01\xC5a,-V[\x90`D5\x91\x7F\x1B=~\xDB.\x9C\x0B\x0E|R[ \xAA\xAE\xF0\xF5\x94\r.\xD7\x16c\xC7\xD3\x92f\xEC\xAF\xACr\x88Ya\x02ys\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80`d5\x95\x16\x93\x843\x14\x15\x80a\x03\rW[a\x02\x87W[\x84_R`\x04` R`@_ \x87_R` R`@_ a\x02:\x87\x82Ta.\xB8V[\x90U\x16\x93\x84_R`\x04` R`@_ \x86_R` R`@_ a\x02_\x82\x82Ta.\xC5V[\x90U`@\x80Q3\x81R` \x81\x01\x92\x90\x92R\x90\x91\x82\x91\x82\x01\x90V[\x03\x90\xA4` `@Q`\x01\x81R\xF3[\x84_R`\x05` R`@_ \x823\x16_R` R`@_ \x87_R` R`@_ T\x86\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x03a\x02\xDAW[PPa\x02\x19V[a\x02\xE3\x91a.\xB8V[\x85_R`\x05` R`@_ \x833\x16_R` R`@_ \x88_R` R`@_ U_\x86a\x02\xD3V[P\x84_R`\x03` R`@_ \x823\x16_R` R`\xFF`@_ T\x16\x15a\x02\x14V[_\x80\xFD[4a\x030Wa\x03B6a,PV[\x7F\xC0\x90\xFCF\x83bL\xFC8\x84\xE9\xD8\xDE^\xCA\x13/-\x0E\xC0b\xAF\xF7]C\xC0F]\\\xEE\xAB#\x92\x91\x92\\\x15a\x04\xD9W\x7F\x1B=~\xDB.\x9C\x0B\x0E|R[ \xAA\xAE\xF0\xF5\x94\r.\xD7\x16c\xC7\xD3\x92f\xEC\xAF\xACr\x88Ya\x03\xEFs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF_\x94a\x03\xBDa\x03\xB3\x86a0\x18V[3\x90\x84\x8A\x16a0^V[\x16\x923\x84\x14\x15\x80a\x04\xA2W[a\x03\xF4W[\x83\x85R`\x04` R`@\x85 \x86\x86R` R`@\x85 a\x02_\x82\x82Ta.\xB8V[\x03\x90\xA4\0[\x83\x85R`\x05` R`@\x85 s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x16\x86R` R`@\x85 \x86\x86R` R`@\x85 T\x81\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x03a\x04[W[PPa\x03\xCEV[a\x04d\x91a.\xB8V[\x84\x86R`\x05` R`@\x86 s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x16\x87R` R`@\x86 \x87\x87R` R`@\x86 U\x86\x81a\x04TV[P\x83\x85R`\x03` R`@\x85 s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x16\x86R` R`\xFF`@\x86 T\x16\x15a\x03\xC9V[\x7FT\xE3\xCA\r\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[4a\x030Wa\x01 \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030Wa\x05:6a-LV[``\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\\6\x01\x12a\x030W`@Q\x90``\x82\x01\x82\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x08gW`@R`\xA45\x80\x15\x15\x81\x03a\x030W\x82R` \x82\x01\x90`\xC45\x82R`\xE45\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x82\x03a\x030W`@\x84\x01\x91\x82Ra\x01\x045g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x030Wa\x05\xE3\x906\x90`\x04\x01a.\x18V[\x94\x90\x93\x7F\xC0\x90\xFCF\x83bL\xFC8\x84\xE9\xD8\xDE^\xCA\x13/-\x0E\xC0b\xAF\xF7]C\xC0F]\\\xEE\xAB#\\\x15a\x04\xD9Wa\x06\x15a1\xCDV[Q\x15a\x08?W\x81\x90`\xA0\x82 \x95\x86_R`\x06` R`@_ \x95a\x068\x87a24V[`\x80\x84\x01\x96\x84\x83\x83\x86\x8BQs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x93a\x06c\x94a9\x96V[\x90\x95\x91\x98``\x88\x01Q`\x02\x0B\x99\x83Q\x15\x15\x91Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x91`@Q\x9Ba\x06\x9A\x8Da,\xDDV[\x8CR` \x8C\x01R`@\x8B\x01R``\x8A\x01Rb\xFF\xFF\xFF\x16`\x80\x89\x01R\x80Q\x15\x15_\x14\x99\x7F@\xE9\xCE\xCB\x9F_\x1F\x1C[\x9C\x97\xDE\xC2\x91{~\xE9.W\xBAUcp\x8D\xAC\xA9M\xD8J\xD7\x11/`\xE0b\xFF\xFF\xFFa\x07\x13a\x07\xBF\x9C` \x9F\x9Ba\x07\xAC\x9Ca\x08\x1FWQs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x97aI\xD7V[\x93\x92\x98\x82\x91\x92a\x07\xF0W[PPs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@\x84\x01Q\x16\x92``o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\xA0\x83\x01Q\x16\x91\x01Q`\x02\x0B\x90`@Q\x943\x86R\x8A`\x80\x1D`\x0F\x0B` \x87\x01R\x8A`\x0F\x0B`@\x87\x01R``\x86\x01R`\x80\x85\x01R`\xA0\x84\x01R\x16`\xC0\x82\x01R\xA2\x86s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x8AQ\x16a;\xA3V[\x80\x94\x91\x94a\x07\xC7W[PP\x823\x91a3\x10V[`@Q\x90\x81R\xF3[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x07\xE9\x92Q\x16\x90\x83a3\x10V[\x84\x80a\x07\xB5V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16_R` `\x01\x90R`@_ \x90\x81T\x01\x90U_\x80a\x07\x1EV[` \x01Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x97aI\xD7V[\x7F\xBE\x8B\x85\x07\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`A`\x04R`$_\xFD[4a\x030W` \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030W\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x08\xECa,\nV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF_T\x91a\t\x11\x82\x84\x163\x14a.\xD2V[\x16\x91\x82\x91\x16\x17_U3\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0_\x80\xA3\0[4a\x030W` \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030W`\x045\\_R` _\xF3[4a\x030W_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030W` s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x02T\x16`@Q\x90\x81R\xF3[4a\x030Wa\t\xD96a.FV[`@`\x04_7`\x05\x1B`@\x01\x80\x91` \x80`@[\x835T\x81R\x01\x91\x01\x90\x82\x81\x10\x15a\n\x07W` \x80\x91a\t\xEDV[\x82_\xF3[4a\x030W`@\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030Wa\nBa,\nV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\n_a,-V[\x91\x16_R`\x03` Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ \x91\x16_R` R` `\xFF`@_ T\x16`@Q\x90\x15\x15\x81R\xF3[4a\x030W` \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030W` a\x07\xBFa\n\xD8a,\nV[a/\xAFV[4a\x030Wa\n\xEB6a.FV[`@`\x04_7`\x05\x1B`@\x01\x80\x91` \x80`@[\x835\\\x81R\x01\x91\x01\x90\x82\x81\x10\x15a\n\x07W` \x80\x91a\n\xFFV[4a\x030W` \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x0Bea,\nV[\x16_R`\x01` R` `@_ T`@Q\x90\x81R\xF3[4a\x030W_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030W` s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF_T\x16`@Q\x90\x81R\xF3[4a\x030W``\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030Wa\x0C\x03a,\nV[a\x0C\x0Ba,-V[\x90`D5s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x02T\x163\x03a\x0C\x9CW` \x92a\x07\xBF\x91\x80a\x0C\x94WPs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16_R`\x01\x84R`@_ T\x92\x83\x91[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16_R`\x01\x86R`@_ a\x0C\x8D\x84\x82Ta.\xB8V[\x90Ua1NV[\x92\x83\x91a\x0CaV[\x7FH\xF5\xC3\xED\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[4a\x030W`\xC0\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030Wa\x0C\xFC6a-LV[a\r\x04a-:V[\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x02T\x163\x03a\x0C\x9CWb>\x90\0\x82\x10a\x03\xE9a\x0F\xFF\x84\x16\x10\x16\x15a\r\xCBW` `\xA0\x7F\xE9\xC4%\x93\xE7\x1F\x84@;\x845,\xD1h\xD6\x93\xE2\xC9\xFC\xD1\xFD\xBC\xC3\xFE\xB2\x1D\x92\xB4>f\x96\xF9\x92 \x92\x83_R`\x06\x82R`@_ a\ru\x81a24V[\x80Ty\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x83`\xB8\x1B\x16\x90\x7F\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x17\x90Ub\xFF\xFF\xFF`@Q\x91\x16\x81R\xA2\0[\x7F\xBA\x97\xF88\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[` \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030Wa\x0E%a,\nV[\x7F\xC0\x90\xFCF\x83bL\xFC8\x84\xE9\xD8\xDE^\xCA\x13/-\x0E\xC0b\xAF\xF7]C\xC0F]\\\xEE\xAB#\\\x15a\x04\xD9Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16a\x0E\x80W` \x90a\x07\xBF4\x91[a\x0Ey\x83a0\x18V[3\x91a0^V[4a\x0F-W\x7F\x1E\x07E\xA7\xDB\x16#\x98\x1F\x0B*]B26L\0xrf\xEBu\xADTo\x19\x0El\xEB\xE9\xBD\x95_R\x80` R`@_ \\\x90\x81\x15a\x0F\x05W\x81\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF` \x93\x14a\x0E\xFEW[a\x0E\xF8a\x07\xBF\x91a\x0E\xF3\x84a/\xAFV[a.\xB8V[\x91a\x0EpV[P_a\x0E\xE3V[\x7F\x87t\xBEH\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x7F\x19\xD2E\xCF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[4a\x030W`\xE0\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030Wa\x0F\x8D6a-LV[`\xA45s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x80\x82\x03a\x030W`\xC45g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x030Wa\x0F\xCE\x906\x90`\x04\x01a.\x18V[a\x0F\xD6a1\xCDV[``\x85\x01\x92a\x7F\xFF\x84Q`\x02\x0B\x13a\x14XW`\x01\x84Q`\x02\x0B\x12a\x140Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x86Q\x16\x92` \x87\x01\x93s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x85Q\x16\x11\x15a\x14\x08W`\x80\x87\x01\x94s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x86Q\x16\x95`@\x89\x01\x96a\x10cb\xFF\xFF\xFF\x89Q\x16\x82a6\x82V[\x15a\x13\xDDWPa\x10xb\xFF\xFF\xFF\x88Q\x16a7@V[\x93\x81Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x90\x813\x03a\x13\x19W[PP`\xA0\x8A \x93a\x10\xAB\x8Ba7]V[\x9A\x90P\x85_R`\x06` R`@_ \x90\x81Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x12\xF1Wa\x10\xE0\x90aFdV[\x9A\x8B\x97`\xD0\x1B|\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90\x84\x89`\xA0\x1Bv\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x17\x90`\xB8\x1By\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x17\x17\x90U\x82Q\x91s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x16\x92\x833\x14\x15\x9C\x7F?\xD5S\xDBD\xF2\x07\xB1\xF4\x13H\xCF\xC4\xD2Q\x86\x08\x14\xAF\x9E\xAD\xC4p\xE8\xE7\x89^M\x12\x05\x11\xF4\x99`\x80\x99` \x9F\x96b\xFF\xFF\xFF\x96s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x98\x96\x89\x97\x96\x88\x97a\x11\xEFW[PPPPPPQ\x16\x98Q\x16\x98Q\x16\x92Q`\x02\x0B\x91Q\x16\x91`@Q\x93\x84R\x89\x84\x01R`@\x83\x01R``\x82\x01R\xA3`@Q\x90`\x02\x0B\x81R\xF3[a\x10\0\x16a\x11\xFEW[\x80a\x11\xB8V[a\x12\xB5a\x12\xE1\x92a\x12\xE6\x96`@Q\x96` \x94\x7F\xA9\x10\xF8\x0F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x89\x96\x87\x01R3`$\x87\x01Ra\x12\x93`D\x87\x01\x8Cs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x80\x92\x82\x81Q\x16\x85R\x82` \x82\x01Q\x16` \x86\x01Rb\xFF\xFF\xFF`@\x82\x01Q\x16`@\x86\x01R``\x81\x01Q`\x02\x0B``\x86\x01R\x01Q\x16\x91\x01RV[`\xE4\x86\x01R`\x02\x0Ba\x01\x04\x85\x01Ra\x01 a\x01$\x85\x01Ra\x01D\x84\x01\x91a/qV[\x03\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x81\x01\x84R\x83a,\xF9V[a=GV[P\x8E\x8D\x81\x80\x80a\x11\xF8V[\x7Fy\x83\xC0Q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[a \0\x16a\x13(W[\x80a\x10\x9BV[a\x13\xD6\x90`@Q\x90\x7F4@\xD8 \0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x83\x01R3`$\x83\x01Ra\x13\xB4\x8D`D\x84\x01\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x80\x92\x82\x81Q\x16\x85R\x82` \x82\x01Q\x16` \x86\x01Rb\xFF\xFF\xFF`@\x82\x01Q\x16`@\x86\x01R``\x81\x01Q`\x02\x0B``\x86\x01R\x01Q\x16\x91\x01RV[\x83`\xE4\x83\x01Ra\x01\0a\x01\x04\x83\x01Ra\x12\xE1\x82a\x12\xB5a\x01$\x82\x01\x8C\x8Ba/qV[P\x8Aa\x13\"V[\x7F\xE6Z\xF6\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04R`$_\xFD[\x7F\xEA\xA6\xC6\xEB\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x7F\x16\xFEv\x96\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x7F\xB0+]\xC2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[4a\x030W_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030W` `@Qa\x7F\xFF\x81R\xF3[4a\x030Wa\x01@\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030Wa\x14\xF36a-LV[`\x80\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\\6\x01\x12a\x030W`@Q\x90a\x15*\x82a,\xA5V[`\xA45\x80`\x02\x0B\x81\x03a\x030W\x82R`\xC45\x80`\x02\x0B\x81\x03a\x030W` \x83\x01R`\xE45`@\x83\x01R``\x82\x01\x91a\x01\x045\x83Ra\x01$5g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x030Wa\x15\x7F\x906\x90`\x04\x01a.\x18V[\x90\x7F\xC0\x90\xFCF\x83bL\xFC8\x84\xE9\xD8\xDE^\xCA\x13/-\x0E\xC0b\xAF\xF7]C\xC0F]\\\xEE\xAB#\\\x15a\x04\xD9Wa\x15\xAFa1\xCDV[`\xA0\x84 \x91\x82_R`\x06` R`@_ \x91a\x15\xCA\x83a24V[`\x80\x86\x01Q\x85s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x91\x823\x03a\x1E\x9AW[P\x90PQ`\x02\x0B\x93` \x86\x01Q`\x02\x0B\x95a\x16\x0E`@\x82\x01Qa4AV[\x96``\x89\x01Q`\x02\x0B\x99Q`@Q\x9Aa\x16&\x8Ca,\xC1V[3\x8CR\x88` \x8D\x01R\x82`@\x8D\x01R\x89`\x0F\x0B``\x8D\x01R`\x80\x8C\x01R`\xA0\x8B\x01R_\x90\x80\x88\x12\x15a\x1EkW\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xF2v\x18\x88\x12a\x1E?Wb\r\x89\xE8\x81\x13a\x1E\x14W`@Q\x98a\x16\x90\x8Aa,\xA5V[_\x8AR_` \x8B\x01R_`@\x8B\x01R_``\x8B\x01R\x80`\x0F\x0Ba\x1B;W[`\x04\x88\x01\x98\x80`\x02\x0B_R\x89` R`@_ \x99\x83`\x02\x0B_R` R`@_ \x89T`\xA0\x1C`\x02\x0B\x82\x81\x12_\x14a\x1A\xE9WP`\x02\x80`\x01\x8D\x01T`\x01\x84\x01T\x90\x03\x9C\x01T\x91\x01T\x90\x03\x9C[`\xA0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82Q\x16\x91\x01Q`&R\x83`\x06R\x81`\x03R_R`:`\x0C _`&R_R`\x06\x89\x01` R`@_ \x98o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x8AT\x16\x9A\x83`\x0F\x0B\x15_\x14a\x1A\x8CW\x8B\x15a\x1AdWa\x17\xA5`@\x9Fa\x18y\x9Ca\x17\x9F\x91a\x18\x8B\x9F[`\x01\x83\x01\x95a\x17\x97`\x02a\x17\x8B\x84\x8AT\x85\x03a>\xCBV[\x95\x01\x92\x83T\x85\x03a>\xCBV[\x96UUa0\x18V[\x91a0\x18V[o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90`\x80\x1B\x17\x9B_\x84`\x0F\x0B\x12a\x19\xFAW[P\x82`\x0F\x0Ba\x18\xC3W[PPPPa\x17\xF9a\x17\xEA\x89`\x80\x1D\x83`\x80\x1D\x01a4AV[\x91\x89`\x0F\x0B\x90`\x0F\x0B\x01a4AV[o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90`\x80\x1B\x17\x91\x81Q`\x02\x0B\x90` \x83\x01Q`\x02\x0B\x8B\x84\x01Q\x90\x8CQ\x93\x84R` \x84\x01R\x8B\x83\x01R\x7FT\x1C\x04\x1C,\xCEH\xE6\x14\xB3\xDE\x04<\x92\x80\xF0kad\xC0\xA1t\x16I\xE2\xDE<=7_yt``3\x93\xA3\x87s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x82\x01Q\x16a50V[\x80\x94\x91\x94a\x18\x97W[P\x833\x91a3\x10V[\x82Q\x91\x82R` \x82\x01R\xF3[a\x18\xBD\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x84\x01Q\x16\x90\x83a3\x10V[\x85a\x18\x82V[\x80\x91\x92\x93\x94PT\x80`\xA0\x1C`\x02\x0B\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90\x83\x81\x12_\x14a\x19+WPPP\x91a\x19\x19\x91a\x19\x13a\x19\ta\x19\x1E\x95aA\xDCV[\x91`\x0F\x0B\x92aA\xDCV[\x90aE\xB3V[a4AV[`\x80\x1B[\x8A\x80\x80\x80a\x17\xD2V[\x94\x80\x91\x93\x92\x95\x12_\x14a\x19\xC6Wo\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x92a\x19\x83a\x19\x19a\x19\x99\x94a\x19pa\x19\x19`\x03\x96a\x19j\x8B`\x0F\x0B\x91aA\xDCV[\x87aE\xB3V[\x93a\x19~\x89`\x0F\x0B\x92aA\xDCV[aE*V[\x84\x16\x90`\x80\x1B\x17\x94\x01\x92`\x0F\x0B\x82\x84T\x16aF\x04V[\x16\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82T\x16\x17\x90Ua\x19\"V[\x91Pa\x19\xE3\x93P\x91a\x19\xDDa\x19\ta\x19\x19\x94aA\xDCV[\x90aE*V[o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x19\"V[\x80\x8F\x91Qa\x1A:W[\x01Qa\x1A\x10W[\x8Ea\x17\xC8V[a\x1A5\x84\x82`\x04\x91`\x02\x0B_R\x01` R_`\x02`@\x82 \x82\x81U\x82`\x01\x82\x01U\x01UV[a\x1A\nV[a\x1A_\x84\x84`\x04\x91`\x02\x0B_R\x01` R_`\x02`@\x82 \x82\x81U\x82`\x01\x82\x01U\x01UV[a\x1A\x03V[\x7F\xAE\xFE\xB9$\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[a\x17\xA5`@\x9Fa\x18y\x9Ca\x17\x9F\x91a\x18\x8B\x9Fo\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x1A\xBC\x8A`\x0F\x0B\x83aF\x04V[\x16\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x84T\x16\x17\x83Ua\x17tV[\x90\x9A\x90\x84\x13a\x1B\x0FW`\x02\x80`\x01\x8D\x01T`\x01\x84\x01T\x90\x03\x9C\x01T\x91\x01T\x90\x03\x9Ca\x16\xFAV[\x99`\x02`\x01\x8B\x01T`\x01\x8D\x01T\x90\x03`\x01\x83\x01T\x90\x03\x9B\x81\x80\x8D\x01T\x91\x01T\x90\x03\x91\x01T\x90\x03\x9Ca\x16\xFAV[\x88`\x02\x0B_R`\x04\x88\x01` R\x88o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ \x80T\x90a\x1B\x95\x83\x83\x16\x92\x8Da\x1Bv\x88`\x0F\x0B\x86aF\x04V[\x94\x15\x96\x87\x87\x87\x16\x15\x14\x15\x97a\x1D\xE5W[PP\x86`\x0F\x0B\x90`\x80\x1Da;\\V[`\x80\x1B\x82\x17\x90U\x16` \x8C\x01R\x8AR\x81`\x02\x0B_R`\x04\x88\x01` R`@_ \x80T\x90o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16a\x1B\xD8\x84`\x0F\x0B\x82aF\x04V[\x90\x15\x92\x83o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x16\x15\x14\x15\x93a\x1D\xBEW[\x84`\x0F\x0B\x90`\x80\x1D`\x0F\x0B\x03\x91o\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x13\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x84\x12\x17a\x1D\x91W\x82o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x93P`\x80\x1B\x82\x17\x90U\x16``\x8C\x01R`@\x8B\x01R\x89\x8C_\x83`\x0F\x0B\x12\x15a\x1C\xB9W[PQa\x1C\x9FW[`@\x8A\x01Q\x15a\x16\xAEWa\x1C\x9A`\x80\x8D\x01Q`\x02\x0B\x83`\x05\x8B\x01aA\xA3V[a\x16\xAEV[a\x1C\xB4`\x80\x8D\x01Q`\x02\x0B\x8A`\x05\x8B\x01aA\xA3V[a\x1C{V[`\x01o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF` `\x80\x82\x94\x01Q`\x02\x0B\x94\x01Q\x16\x92\x80\x80\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xF2v\x18\x05\x02\x81\x80b\r\x89\xE8\x05\x02\x03\x05\x01\x81\x04\x16\x80\x91\x11a\x1DeWo\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF``\x8C\x01Q\x16\x11a\x1D9W\x89\x8Ca\x1CtV[P\x7F\xB8\xE3\xC3\x85\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04R`$_\xFD[\x89\x7F\xB8\xE3\xC3\x85\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04R`$_\xFD[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x11`\x04R`$_\xFD[\x8BT`\xA0\x1C`\x02\x0B\x86\x13a\x1B\xF8W`\x01\x8C\x01T`\x01\x84\x01U`\x02\x8C\x01T`\x02\x84\x01Ua\x1B\xF8V[\x81T`\xA0\x1C`\x02\x0B\x12\x15a\x1D\xFAW[\x8Fa\x1B\x86V[\x80`\x01`\x02\x92\x01T`\x01\x86\x01U\x01T`\x02\x84\x01U\x8Da\x1D\xF4V[\x7F\x1A\xD7w\xF8\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04R`$_\xFD[\x87\x7F\xD5\xE2\xF7\xAB\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04R`$_\xFD[\x87\x7F\xC4C>\xD5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04R`$R`D_\xFD[_`@\x83\x01Q\x13\x80\x80\x91a\x1FkW[\x15a\x1E\xFDWPPa\x1E\xF3\x91a\x12\xE1\x89a\x12\xB5\x87\x87`@Q\x96\x87\x94\x7F%\x99\x82\xE5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x87\x01R3`$\x87\x01a3\x87V[P[\x87\x85\x81a\x15\xF0V[\x15\x90\x81a\x1F]W[Pa\x1F\x12W[PPa\x1E\xF5V[a\x1FU\x91a\x12\xE1\x89a\x12\xB5\x87\x87`@Q\x96\x87\x94\x7F!\xD0\xEEp\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x87\x01R3`$\x87\x01a3\x87V[P\x87\x85a\x1F\x0BV[a\x02\0\x91P\x16\x15\x15\x8Aa\x1F\x05V[Pa\x08\0\x82\x16\x15\x15a\x1E\xA9V[4a\x030W``\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030Wa\x1F\xAFa,\nV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x1F\xCCa,-V[\x91\x16_R`\x05` Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ \x91\x16_R` R`@_ `D5_R` R` `@_ T`@Q\x90\x81R\xF3[4a\x030W`@\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030Wa Ga,\nV[`$5\x90\x81\x15\x15\x80\x92\x03a\x030Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x903_R`\x03` R`@_ \x82\x82\x16_R` R`@_ \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\x81T\x16`\xFF\x85\x16\x17\x90U`@Q\x92\x83R\x16\x90\x7F\xCE\xB5v\xD9\xF1^N \x0F\xDBP\x96\xD6M]\xFDf~\x16\xDE\xF2\x0C\x1E\xEF\xD1BV\xD8\xE3\xFA\xA2g` 3\x92\xA3` `@Q`\x01\x81R\xF3[4a\x030W`\xC0\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030Wa!\x1F6a-LV[a!'a-:V[\x90b\x80\0\0b\xFF\xFF\xFF`@\x83\x01Q\x16\x14\x80\x15\x90a!\xDBW[a!\xB3W`\xA0\x90a!O\x83a3NV[ _R`\x06` R`@_ \x90a!e\x82a24V[\x81T\x7F\xFF\xFF\xFF\0\0\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\xD0\x91\x90\x91\x1B|\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x17\x90U\0[\x7F0\xD2\x16A\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[Ps\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x82\x01Q\x163\x14\x15a!?V[4a\x030W` \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030W`\x045g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x030Wa\"N\x906\x90`\x04\x01a.\x18V[\x7F\xC0\x90\xFCF\x83bL\xFC8\x84\xE9\xD8\xDE^\xCA\x13/-\x0E\xC0b\xAF\xF7]C\xC0F]\\\xEE\xAB#\\a$4Wa\"\xDA\x91_\x91`\x01\x7F\xC0\x90\xFCF\x83bL\xFC8\x84\xE9\xD8\xDE^\xCA\x13/-\x0E\xC0b\xAF\xF7]C\xC0F]\\\xEE\xAB#]`@Q\x93\x84\x92\x83\x92\x7F\x91\xDDsF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x84R` `\x04\x85\x01R`$\x84\x01\x91a/qV[\x03\x81\x833Z\xF1\x90\x81\x15a$)W_\x91a#\xAFW[P\x7F}K1d\xC6\xE4[\x97\xE7\xD8{q%\xA4LX(\xD0\x05\xAF\x88\xF9\xD7Q\xCF\xD7\x87)\xC5\xD9\x9A\x0B\\a#\x87W`@` \x91_\x7F\xC0\x90\xFCF\x83bL\xFC8\x84\xE9\xD8\xDE^\xCA\x13/-\x0E\xC0b\xAF\xF7]C\xC0F]\\\xEE\xAB#]\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0`\x1F\x83Q\x94\x85\x93\x81\x85R\x80Q\x91\x82\x91\x82\x82\x88\x01R\x01\x86\x86\x01^_\x85\x82\x86\x01\x01R\x01\x16\x81\x01\x03\x01\x90\xF3[\x7FR\x12\xCB\xA1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x90P=\x80_\x83>a#\xC0\x81\x83a,\xF9V[\x81\x01\x90` \x81\x83\x03\x12a\x030W\x80Q\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x030W\x01\x81`\x1F\x82\x01\x12\x15a\x030W\x80Q\x90a#\xF7\x82a/7V[\x92a$\x05`@Q\x94\x85a,\xF9V[\x82\x84R` \x83\x83\x01\x01\x11a\x030W\x81_\x92` \x80\x93\x01\x83\x86\x01^\x83\x01\x01R\x81a\"\xEEV[`@Q=_\x82>=\x90\xFD[\x7FP\x90\xD6\xC6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[4a\x030Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa$\x7F6a,PV[\x91\x92\x90\x923_R`\x05` R`@_ \x82\x82\x16_R` R`@_ \x84_R` R\x82`@_ U`@Q\x92\x83R\x16\x90\x7F\xB3\xFDPq\x83X\x87Vz\x06q\x15\x11!\x89M\xDC\xCC(B\xF1\xD1\x0B\xED\xAD\x13\xE0\xD1|\xAC\xE9\xA7` 3\x92\xA4` `@Q`\x01\x81R\xF3[4a\x030W`@\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030W`\x045` _R`$5`\x05\x1B\x80` R`@\x01\x80\x91`\x01` `@[\x83T\x81R\x01\x91\x01\x90\x82\x81\x10\x15a\n\x07W` `\x01\x91a%,V[4a\x030W` \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030W`\x045s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x80\x91\x03a\x030W` \x7F\xB4\xBD\x8E\xF5=\xF6\x90\xB9\x94=3\x18\x99`\x06\xDB\xB8*%\xF5G\x19\xD8\xC8\x03[Qj*[\x8A\xCC\x91a%\xDCs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF_T\x163\x14a.\xD2V[\x80\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x02T\x16\x17`\x02U`@Q\x90\x81R\xA1\0[4a\x030Wa\x01\0\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030Wa&H6a-LV[`\xC45\x90`\xA45`\xE45g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x030Wa&o\x906\x90`\x04\x01a.\x18V[\x91\x90\x93\x7F\xC0\x90\xFCF\x83bL\xFC8\x84\xE9\xD8\xDE^\xCA\x13/-\x0E\xC0b\xAF\xF7]C\xC0F]\\\xEE\xAB#\\\x15a\x04\xD9Wa&\xA1a1\xCDV[`\xA0\x84 _R`\x06` R`@_ \x94a&\xBA\x86a24V[`\x80\x85\x01\x94\x85Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x90\x813\x03a(.W[PPo\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x03\x88\x01T\x16\x95\x86\x15a(\x06W` \x97a'\r\x86a0\x18V[_\x03a'\x18\x86a0\x18V[_\x03o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90`\x80\x1B\x17\x97\x86a'\xEDW[\x85a'\xD2W[PPa'K3\x88\x84a3\x10V[Q\x92s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x84\x16\x93\x843\x03a'wW[\x88\x88`@Q\x90\x81R\xF3[`\x10\x16a'\x85W[\x80a'mV[a'\xC6\x95a\x12\xE1\x93a\x12\xB5\x92`@Q\x97\x88\x95\x7F\xE1\xB4\xAFi\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x8D\x88\x01R3`$\x88\x01a2zV[P\x82\x80\x80\x80\x80\x80a'\x7FV[a'\xDE`\x02\x91\x87a>\nV[\x91\x01\x90\x81T\x01\x90U\x88\x80a'>V[a'\xF7\x81\x88a>\nV[`\x01\x83\x01\x90\x81T\x01\x90Ua'8V[\x7F\xA7O\x97\xAB\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[` \x16a(<W[\x80a&\xE1V[`@Q\x7F\xB6\xA8\xB0\xFA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01Ra(\x7F\x91a\x12\xE1\x82a\x12\xB5\x8A\x88\x8A\x8C\x8A3`$\x88\x01a2zV[P\x87a(6V[4a\x030W` \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030W`\x045T_R` _\xF3[4a\x030Wa(\xCE6a,PV[\x90\x91\x7F\xC0\x90\xFCF\x83bL\xFC8\x84\xE9\xD8\xDE^\xCA\x13/-\x0E\xC0b\xAF\xF7]C\xC0F]\\\xEE\xAB#\\\x15a\x04\xD9W\x7F\x1B=~\xDB.\x9C\x0B\x0E|R[ \xAA\xAE\xF0\xF5\x94\r.\xD7\x16c\xC7\xD3\x92f\xEC\xAF\xACr\x88Ya\x03\xEFs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF_\x93a)Ma)>\x87a0\x18V[\x86\x03`\x0F\x0B3\x90\x84\x8A\x16a0^V[\x16\x93\x84\x84R`\x04` R`@\x84 \x86\x85R` R`@\x84 a\x02_\x82\x82Ta.\xC5V[4a\x030W``\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030Wa)\xA7a,\nV[a)\xAFa,-V[`D5\x90\x7F\xC0\x90\xFCF\x83bL\xFC8\x84\xE9\xD8\xDE^\xCA\x13/-\x0E\xC0b\xAF\xF7]C\xC0F]\\\xEE\xAB#\\\x15a\x04\xD9Wa)\xFC\x92a)\xF7a)\xEA\x84a0\x18V[_\x03`\x0F\x0B3\x90\x83a0^V[a1NV[\0[4a\x030Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa*!6a,PV[\x91\x92\x90\x923_R`\x04` R`@_ \x84_R` R`@_ a*F\x84\x82Ta.\xB8V[\x90U\x16\x90\x81_R`\x04` R`@_ \x83_R` R`@_ a*k\x82\x82Ta.\xC5V[\x90U`@\x80Q3\x80\x82R` \x82\x01\x93\x90\x93R\x7F\x1B=~\xDB.\x9C\x0B\x0E|R[ \xAA\xAE\xF0\xF5\x94\r.\xD7\x16c\xC7\xD3\x92f\xEC\xAF\xACr\x88Y\x91\x81\x90\x81\x01a\x02yV[4a\x030W_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030W` `@Q`\x01\x81R\xF3[4a\x030W` \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030W`\x045\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81\x16\x80\x91\x03a\x030W\x80\x7F\x01\xFF\xC9\xA7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x92\x14\x90\x81\x15a+vW[P`@Q\x90\x15\x15\x81R\xF3[\x7F\x0Fc/\xB3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91P\x14\x82a+kV[4a\x030W`@\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x030W` \x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa+\xEFa,\nV[\x16_R`\x04\x82R`@_ `$5_R\x82R`@_ T\x81R\xF3[`\x045\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x82\x03a\x030WV[`$5\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x82\x03a\x030WV[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC``\x91\x01\x12a\x030W`\x045s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x81\x03a\x030W\x90`$5\x90`D5\x90V[`\x80\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x08gW`@RV[`\xC0\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x08gW`@RV[`\xA0\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x08gW`@RV[\x90`\x1F\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x91\x01\x16\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x08gW`@RV[`\xA45\x90b\xFF\xFF\xFF\x82\x16\x82\x03a\x030WV[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC`\xA0\x91\x01\x12a\x030W`@Q\x90a-\x83\x82a,\xDDV[\x81`\x045s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x81\x03a\x030W\x81R`$5s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x81\x03a\x030W` \x82\x01R`D5b\xFF\xFF\xFF\x81\x16\x81\x03a\x030W`@\x82\x01R`d5\x80`\x02\x0B\x81\x03a\x030W``\x82\x01R`\x845\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x82\x03a\x030W`\x80\x01RV[\x91\x81`\x1F\x84\x01\x12\x15a\x030W\x825\x91g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11a\x030W` \x83\x81\x86\x01\x95\x01\x01\x11a\x030WV[\x90` \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC\x83\x01\x12a\x030W`\x045g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x030W\x82`#\x82\x01\x12\x15a\x030W\x80`\x04\x015\x92g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x84\x11a\x030W`$\x84`\x05\x1B\x83\x01\x01\x11a\x030W`$\x01\x91\x90V[\x91\x90\x82\x03\x91\x82\x11a\x1D\x91WV[\x91\x90\x82\x01\x80\x92\x11a\x1D\x91WV[\x15a.\xD9WV[`d`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` `\x04\x82\x01R`\x0C`$\x82\x01R\x7FUNAUTHORIZED\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R\xFD[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x08gW`\x1F\x01\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x16` \x01\x90V[`\x1F\x82` \x94\x93\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x93\x81\x86R\x86\x86\x017_\x85\x82\x86\x01\x01R\x01\x16\x01\x01\x90V[\x90a/\xB9\x82a8\xFFV[\x91\x82\x90\x83\x15a/\xF0W[\x7F\x1E\x07E\xA7\xDB\x16#\x98\x1F\x0B*]B26L\0xrf\xEBu\xADTo\x19\x0El\xEB\xE9\xBD\x95_R` R`@_ ]V[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x91Pa/\xC3V[o\x80\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81\x10\x15a06W`\x0F\x0B\x90V[c\x93\xDA\xFD\xF1_R`\x04`\x1C\xFD[\x91\x90\x91_\x83\x82\x01\x93\x84\x12\x91\x12\x90\x80\x15\x82\x16\x91\x15\x16\x17a\x1D\x91WV[\x90`\x0F\x0B\x91\x82\x15a1IW\x80_R\x81` Ra0\x7F`@_ \\\x93\x84a0CV[\x92\x83a0\xF9WP\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F}K1d\xC6\xE4[\x97\xE7\xD8{q%\xA4LX(\xD0\x05\xAF\x88\xF9\xD7Q\xCF\xD7\x87)\xC5\xD9\x9A\x0B\\\x01\x7F}K1d\xC6\xE4[\x97\xE7\xD8{q%\xA4LX(\xD0\x05\xAF\x88\xF9\xD7Q\xCF\xD7\x87)\xC5\xD9\x9A\x0B][_R` R`@_ ]V[a0\xEDW`\x01\x7F}K1d\xC6\xE4[\x97\xE7\xD8{q%\xA4LX(\xD0\x05\xAF\x88\xF9\xD7Q\xCF\xD7\x87)\xC5\xD9\x9A\x0B\\\x01\x7F}K1d\xC6\xE4[\x97\xE7\xD8{q%\xA4LX(\xD0\x05\xAF\x88\xF9\xD7Q\xCF\xD7\x87)\xC5\xD9\x9A\x0B]a0\xEDV[PPPV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16a1\x86WP_\x80\x80\x93\x81\x93Z\xF1\x15a1yWV[c\xF4\xB3\xB1\xBC_R`\x04`\x1C\xFD[`\x10_`D\x92` \x95\x82\x95`\x14R`4Ro\xA9\x05\x9C\xBB\0\0\0\0\0\0\0\0\0\0\0\0\x82RZ\xF1=\x15`\x01_Q\x14\x17\x16\x15a1\xC0W_`4RV[c\xF2\x7Fd\xE4_R`\x04`\x1C\xFD[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x160\x03a2\x0CWV[\x7F\r\x89C\x8E\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x15a2RWV[\x7FHj\xA3\x07\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x91\x92a2\xF5a\x01 \x94s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa3\r\x99\x97\x94\x16\x85R` \x85\x01\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x80\x92\x82\x81Q\x16\x85R\x82` \x82\x01Q\x16` \x86\x01Rb\xFF\xFF\xFF`@\x82\x01Q\x16`@\x86\x01R``\x81\x01Q`\x02\x0B``\x86\x01R\x01Q\x16\x91\x01RV[`\xC0\x83\x01R`\xE0\x82\x01R\x81a\x01\0\x82\x01R\x01\x91a/qV[\x90V[\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF` a3L\x94\x93a3?\x85\x84\x83Q\x16\x86`\x80\x1D\x90a0^V[\x01Q\x16\x90`\x0F\x0B\x90a0^V[V[b\xFF\xFF\xFFb\x0FB@\x91\x16\x11a3_WV[\x7F\xFC[\xEE\x12\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x90a3\r\x95\x93a4\x04a\x01`\x94s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa43\x94\x16\x85R` \x85\x01\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x80\x92\x82\x81Q\x16\x85R\x82` \x82\x01Q\x16` \x86\x01Rb\xFF\xFF\xFF`@\x82\x01Q\x16`@\x86\x01R``\x81\x01Q`\x02\x0B``\x86\x01R\x01Q\x16\x91\x01RV[\x80Q`\x02\x90\x81\x0B`\xC0\x85\x01R` \x82\x01Q\x90\x0B`\xE0\x84\x01R`@\x81\x01Qa\x01\0\x84\x01R``\x01Qa\x01 \x83\x01RV[\x81a\x01@\x82\x01R\x01\x91a/qV[\x80o\x80\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01`\x80\x1C\x15a4iWc\x93\xDA\xFD\xF1_R`\x04`\x1C\xFD[`\x0F\x0B\x90V[\x91a\x01\x80\x93a4\xEDa5\x1C\x92s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa3\r\x9A\x98\x95\x16\x86R` \x86\x01\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x80\x92\x82\x81Q\x16\x85R\x82` \x82\x01Q\x16` \x86\x01Rb\xFF\xFF\xFF`@\x82\x01Q\x16`@\x86\x01R``\x81\x01Q`\x02\x0B``\x86\x01R\x01Q\x16\x91\x01RV[\x80Q`\x02\x90\x81\x0B`\xC0\x86\x01R` \x82\x01Q\x90\x0B`\xE0\x85\x01R`@\x81\x01Qa\x01\0\x85\x01R``\x01Qa\x01 \x84\x01RV[a\x01@\x82\x01R\x81a\x01`\x82\x01R\x01\x91a/qV[\x92\x95\x93\x94_\x95s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x85\x163\x14a6xW\x87_`@\x86\x01Q\x13_\x14a6\nWa\x04\0\x86\x16a5sW[PPPPPPV[a5\xFE\x96\x98\x97Pa5\xEB\x92a5\xF7\x96\x95\x94\x92a5\xBF\x92`@Q\x96\x87\x95\x7FZ*\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x88\x01R3`$\x88\x01a4oV[\x03\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x81\x01\x83R\x82a,\xF9V[`\x02\x82\x16\x15\x15\x91aF\x10V[\x80\x92aF'V[\x91_\x80\x80\x80\x80\x80a5kV[\x94\x93\x92\x91\x90a\x01\0\x85\x16a6 WPPPPPPV[a5\xFE\x96\x98P\x85\x97Pa6l\x92\x91a5\xBF\x91a5\xF7\x97`@Q\x96\x87\x95\x7F\x8D\xB2\xB6R\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x88\x01R3`$\x88\x01a4oV[`\x01\x82\x16\x15\x15\x91aF\x10V[P_\x95PPPPPV[`\x80\x81\x16\x15\x80a74W[a7\nW`@\x81\x16\x15\x80a7(W[a7\nWa\x04\0\x81\x16\x15\x80a7\x1CW[a7\nWa\x01\0\x81\x16\x15\x80a7\x10W[a7\nWs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16a6\xEAWPb\xFF\xFF\xFF\x16b\x80\0\0\x14\x15\x90V[a?\xFF\x16\x15\x90\x81\x15\x91a6\xFBWP\x90V[b\x80\0\0\x91Pb\xFF\xFF\xFF\x16\x14\x90V[PP_\x90V[P`\x01\x81\x16\x15\x15a6\xBCV[P`\x02\x81\x16\x15\x15a6\xACV[P`\x04\x81\x16\x15\x15a6\x9CV[P`\x08\x81\x16\x15\x15a6\x8DV[b\x80\0\0b\xFF\xFF\xFF\x82\x16\x14a7XWa3\r\x81a3NV[P_\x90V[_\x91_\x91s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x02T\x16\x80a7\x83WPPV[\x91\x93P\x91PZ\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x80\x91\x10a8\xD7W_\x92\x83\x80\x93`@Qa88` \x82\x01\x94\x7FU;\xFC7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x86R`$\x83\x01\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x80\x92\x82\x81Q\x16\x85R\x82` \x82\x01Q\x16` \x86\x01Rb\xFF\xFF\xFF`@\x82\x01Q\x16`@\x86\x01R``\x81\x01Q`\x02\x0B``\x86\x01R\x01Q\x16\x91\x01RV[`\xA4\x81Ra8G`\xC4\x82a,\xF9V[Q\x93\xF1=\x15a8\xCFW=\x90a8[\x82a/7V[\x91a8i`@Q\x93\x84a,\xF9V[\x82R=_` \x84\x01>[\x15\x80\x15a8\xC4W[a8\xBDW` \x01Qb\xFF\xFF\xFF\x81\x16\x90\x81\x81\x14\x90\x81a8\xA5W[P\x15a8\x9FW`\x01\x91V[P_\x80\x91V[\x90Pa\x03\xE9a\x0F\xFFb>\x90\0\x84\x10\x92\x16\x10\x16_a8\x94V[P_\x90_\x90V[P` \x81Q\x11a8{V[``\x90a8sV[\x7F\x1E\xE4\x97\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x80a9\x1FWPG\x90V[` `$\x91`@Q\x92\x83\x80\x92\x7Fp\xA0\x821\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82R0`\x04\x83\x01RZ\xFA\x90\x81\x15a$)W_\x91a9gWP\x90V[\x90P` \x81=` \x11a9\x8EW[\x81a9\x82` \x93\x83a,\xF9V[\x81\x01\x03\x12a\x030WQ\x90V[=\x91Pa9uV[\x94\x91\x92\x94_\x94_\x94` \x81\x01Q\x97s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x84\x163\x14a;OW`\x80\x84\x16a9\xD1W[PPPPPV[a:\xC3a:sa:\xBD\x87a5\xBF`@\x95b\x80\0\0\x98a:\xA9b\xFF\xFF\xFF\x99\x89Q\x97\x88\x96\x7FW^$\xB4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x89\x01R3`$\x89\x01R`D\x88\x01\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x80\x92\x82\x81Q\x16\x85R\x82` \x82\x01Q\x16` \x86\x01Rb\xFF\xFF\xFF`@\x82\x01Q\x16`@\x86\x01R``\x81\x01Q`\x02\x0B``\x86\x01R\x01Q\x16\x91\x01RV[\x80Q\x15\x15`\xE4\x87\x01R` \x81\x01Qa\x01\x04\x87\x01R`@\x01Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x01$\x86\x01RV[a\x01@a\x01D\x85\x01Ra\x01d\x84\x01\x91a/qV[\x85a=GV[\x94\x01Q\x16\x14a;CW[`\x08\x16a:\xDEW[\x80\x80\x80\x80a9\xCAV[`@\x01Q\x92P`\x80\x83\x90\x1D`\x0F\x0B\x80\x15a:\xD5Wa:\xFF\x90_\x86\x12\x95a0CV[\x93\x15a;;W_\x84\x13[a;\x13W_a:\xD5V[\x7F\xFA\x0Bq\xD6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[_\x84\x12a;\tV[``\x82\x01Q\x93Pa:\xCDV[P_\x96P\x86\x95PPPPPV[\x90`\x0F\x0B\x90`\x0F\x0B\x01\x90\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x12o\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x13\x17a\x1D\x91WV[\x91\x96\x95\x93\x94\x92\x94s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x163\x14a=:W\x84`\x80\x1D\x94`\x0F\x0B\x93\x88`@\x85\x16a<bW[PPPPP_\x94\x81`\x0F\x0B\x15\x80\x15\x90a<VW[a;\xFAW[PPP\x91\x90V[a<1\x93\x95P_` \x82\x01Q\x12\x90Q\x15\x15\x14_\x14a<9Wo\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90`\x80\x1B\x17[\x80\x93aF'V[_\x80\x80a;\xF3V[\x90o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90`\x80\x1B\x17a<*V[P\x82`\x0F\x0B\x15\x15a;\xEEV[a=\x1Ea=*\x94a5\xBFa\x19\x19\x95a=0\x99\x98\x95a=\x03a:s\x96`@Q\x97\x88\x96\x7F\xB4{/\xB1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x89\x01R3`$\x89\x01R`D\x88\x01\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x80\x92\x82\x81Q\x16\x85R\x82` \x82\x01Q\x16` \x86\x01Rb\xFF\xFF\xFF`@\x82\x01Q\x16`@\x86\x01R``\x81\x01Q`\x02\x0B``\x86\x01R\x01Q\x16\x91\x01RV[\x8Ca\x01D\x85\x01Ra\x01`a\x01d\x85\x01Ra\x01\x84\x84\x01\x91a/qV[`\x04\x82\x16\x15\x15\x91aF\x10V[\x90a;\\V[_\x80\x80\x80\x88a;\xDAV[PPPPP\x90\x91P\x90_\x90V[_\x80\x93\x92\x81\x92` \x82Q\x92\x01\x95\x86\x91Z\xF1\x15a=\xEFW`@Q\x91\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0`?=\x01\x16\x83\x01`@R=\x83R\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x80=` \x86\x01\x90_\x82>Q\x92Q\x16\x91\x16\x03a=\xC7WV[\x7F\x1E\x04\x8E\x1D\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[=\x15a=\xFDW=_\x80>=_\xFD[c6\xBCH\xC5_R`\x04`\x1C\xFD[\x90\x81`\x80\x1B\x90\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFp\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x84\t\x92\x82\x80\x85\x10\x94\x03\x93\x80\x85\x03\x94\x85\x84\x11\x15a\x030W\x14a>\xC4Wp\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x91\t\x81\x80_\x03\x16\x80\x92\x04`\x02\x81`\x03\x02\x18\x80\x82\x02`\x02\x03\x02\x80\x82\x02`\x02\x03\x02\x80\x82\x02`\x02\x03\x02\x80\x82\x02`\x02\x03\x02\x80\x82\x02`\x02\x03\x02\x80\x91\x02`\x02\x03\x02\x93`\x01\x83\x80_\x03\x04\x01\x90\x84\x83\x11\x90\x03\x02\x92\x03\x04\x17\x02\x90V[P\x91P\x04\x90V[\x90\x80\x82\x02\x91\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x82\t\x91\x83\x80\x84\x10\x93\x03\x92\x80\x84\x03\x93\x84p\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x11\x15a\x030W\x14a?DWp\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\t\x90\x82\x82\x11\x90\x03`\x80\x1B\x91\x03`\x80\x1C\x17\x90V[PPP`\x80\x1C\x90V[\x90\x80\x82\x02\x91\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x82\t\x91\x83\x80\x84\x10\x93\x03\x92\x80\x84\x03\x93\x84l\x01\0\0\0\0\0\0\0\0\0\0\0\0\x11\x15a\x030W\x14a?\xBEWl\x01\0\0\0\0\0\0\0\0\0\0\0\0\x91\t\x90\x82\x82\x11\x90\x03`\xA0\x1B\x91\x03``\x1C\x17\x90V[PPP``\x1C\x90V[\x81\x81\x02\x90\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x82\t\x90\x82\x80\x83\x10\x92\x03\x91\x80\x83\x03\x92\x83b\x0FB@\x11\x15a\x030W\x14a@FW\x7F\xDE\x8Fl\xEF\xEDcEI\xB6,wWOr.\x1A\xC5~#\xF2M\x8F\xD5\xCBy\x0F\xB6Vh\xC2a9\x93b\x0FB@\x91\t\x90\x82\x82\x11\x90\x03`\xFA\x1B\x91\x03`\x06\x1C\x17\x02\x90V[PPb\x0FB@\x91P\x04\x90V[\x90\x81``\x1B\x90\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFl\x01\0\0\0\0\0\0\0\0\0\0\0\0\x84\t\x92\x82\x80\x85\x10\x94\x03\x93\x80\x85\x03\x94\x85\x84\x11\x15a\x030W\x14a>\xC4Wl\x01\0\0\0\0\0\0\0\0\0\0\0\0\x82\x91\t\x81\x80_\x03\x16\x80\x92\x04`\x02\x81`\x03\x02\x18\x80\x82\x02`\x02\x03\x02\x80\x82\x02`\x02\x03\x02\x80\x82\x02`\x02\x03\x02\x80\x82\x02`\x02\x03\x02\x80\x82\x02`\x02\x03\x02\x80\x91\x02`\x02\x03\x02\x93`\x01\x83\x80_\x03\x04\x01\x90\x84\x83\x11\x90\x03\x02\x92\x03\x04\x17\x02\x90V[\x91\x81\x83\x02\x91\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x85\t\x93\x83\x80\x86\x10\x95\x03\x94\x80\x86\x03\x95\x86\x85\x11\x15a\x030W\x14aA\x9BW\x90\x82\x91\t\x81\x80_\x03\x16\x80\x92\x04`\x02\x81`\x03\x02\x18\x80\x82\x02`\x02\x03\x02\x80\x82\x02`\x02\x03\x02\x80\x82\x02`\x02\x03\x02\x80\x82\x02`\x02\x03\x02\x80\x82\x02`\x02\x03\x02\x80\x91\x02`\x02\x03\x02\x93`\x01\x83\x80_\x03\x04\x01\x90\x84\x83\x11\x90\x03\x02\x92\x03\x04\x17\x02\x90V[PP\x91P\x04\x90V[\x91\x90\x81\x81\x07aA\xC9W\x05\x90\x81`\x08\x1D_R` R`\x01`\xFF`@_ \x92\x16\x1B\x81T\x18\x90UV[c\xD4\xD8\xF3\xE6_R` R`@R`D`\x1C\xFD[\x80`\xFF\x1D\x81\x81\x01\x18b\r\x89\xE8\x81\x11aE\x1DWc\xFF\xFF\xFF\xFF\x91`\x01\x82\x16p\x01\xFF\xFC\xB93\xBDo\xAD7\xAA-\x16-\x1AY@\x01\x02p\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x18\x91`\x02\x81\x16aE\x01W[`\x04\x81\x16aD\xE5W[`\x08\x81\x16aD\xC9W[`\x10\x81\x16aD\xADW[` \x81\x16aD\x91W[`@\x81\x16aDuW[`\x80\x81\x16aDYW[a\x01\0\x81\x16aD=W[a\x02\0\x81\x16aD!W[a\x04\0\x81\x16aD\x05W[a\x08\0\x81\x16aC\xE9W[a\x10\0\x81\x16aC\xCDW[a \0\x81\x16aC\xB1W[a@\0\x81\x16aC\x95W[a\x80\0\x81\x16aCyW[b\x01\0\0\x81\x16aC]W[b\x02\0\0\x81\x16aCBW[b\x04\0\0\x81\x16aC'W[b\x08\0\0\x16aC\x0EW[_\x12aB\xE7W[\x01` \x1C\x90V[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x04aB\xE0V[k\x04\x8A\x17\x03\x91\xF7\xDCBDN\x8F\xA2\x90\x91\x02`\x80\x1C\x90aB\xD9V[m\"\x16\xE5\x84\xF5\xFA\x1E\xA9&\x04\x1B\xED\xFE\x98\x90\x92\x02`\x80\x1C\x91aB\xCFV[\x91n]j\xF8\xDE\xDB\x81\x19f\x99\xC3)\"^\xE6\x04\x02`\x80\x1C\x91aB\xC4V[\x91o\t\xAAP\x8B[z\x84\xE1\xC6w\xDET\xF3\xE9\x9B\xC9\x02`\x80\x1C\x91aB\xB9V[\x91o1\xBE\x13_\x97\xD0\x8F\xD9\x81#\x15\x05T/\xCF\xA6\x02`\x80\x1C\x91aB\xAEV[\x91op\xD8i\xA1V\xD2\xA1\xB8\x90\xBB=\xF6+\xAF2\xF7\x02`\x80\x1C\x91aB\xA4V[\x91o\xA9\xF7FF-\x87\x0F\xDF\x8Ae\xDC\x1F\x90\xE0a\xE5\x02`\x80\x1C\x91aB\x9AV[\x91o\xD0\x97\xF3\xBD\xFD \"\xB8\x84Z\xD8\xF7\x92\xAAX%\x02`\x80\x1C\x91aB\x90V[\x91o\xE7\x15\x94u\xA2\xC2\x9BtC\xB2\x9C\x7F\xA6\xE8\x89\xD9\x02`\x80\x1C\x91aB\x86V[\x91o\xF39+\x08\"\xB7\0\x05\x94\x0Cz9\x8EKp\xF3\x02`\x80\x1C\x91aB|V[\x91o\xF9\x87\xA7%:\xC4\x13\x17o+\x07L\xF7\x81^T\x02`\x80\x1C\x91aBrV[\x91o\xFC\xBE\x86\xC7\x90\n\x88\xAE\xDC\xFF\xC8;G\x9A\xA3\xA4\x02`\x80\x1C\x91aBhV[\x91o\xFE]\xEE\x04j\x99\xA2\xA8\x11\xC4a\xF1\x96\x9C0S\x02`\x80\x1C\x91aB^V[\x91o\xFF.\xA1df\xC9j8C\xECx\xB3&\xB5(a\x02`\x80\x1C\x91aBUV[\x91o\xFF\x97;A\xFA\x98\xC0\x81G.h\x96\xDF\xB2T\xC0\x02`\x80\x1C\x91aBLV[\x91o\xFF\xCB\x98C\xD6\x0FaY\xC9\xDBX\x83\\\x92fD\x02`\x80\x1C\x91aBCV[\x91o\xFF\xE5\xCA\xCA~\x10\xE4\xE6\x1C6$\xEA\xA0\x94\x1C\xD0\x02`\x80\x1C\x91aB:V[\x91o\xFF\xF2\xE5\x0F_ei2\xEF\x125|\xF3\xC7\xFD\xCC\x02`\x80\x1C\x91aB1V[\x91o\xFF\xF9rr7=A2Y\xA4i\x90X\x0E!:\x02`\x80\x1C\x91aB(V[c\xCE\x8E\xF7\xFC_R`\x04`\x1C\xFD[_\x83`\x0F\x0B\x12_\x14aEgW\x91aEb\x91a3\r\x93\x03\x80`\xFF\x1D\x90\x81\x01\x18\x90_\x03o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a?MV[aZ&V[\x90l\x01\0\0\0\0\0\0\0\0\0\0\0\0`\x01\x91aE\xAE\x94o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x93\x03\x80`\xFF\x1D\x90\x81\x01\x18aE\xA3\x81\x85a?MV[\x93\t\x15\x15\x16\x01aZ&V[_\x03\x90V[\x91_\x81`\x0F\x0B\x12_\x14aE\xE3W\x91aEb\x91a3\r\x93_\x03o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x91aZ\xE0V[\x91aEb\x91aE\xAE\x93o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x91aZ;V[\x01\x90\x81`\x80\x1Ca06WV[\x90aF\x1A\x91a=GV[\x90\x15a7XW`@\x01Q\x90V[aFJ\x90aF<\x83`\x80\x1D\x82`\x80\x1D\x03a4AV[\x92`\x0F\x0B\x90`\x0F\x0B\x03a4AV[o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90`\x80\x1B\x17\x90V[s\xFF\xFD\x89c\xEF\xD1\xFCjPd\x88I]\x95\x1DQc\x96\x16\x82\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFE\xFF\xFD\x89]\x82\x01\x11aI\x93Ww\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\x81` \x1B\x16\x80o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11`\x07\x1B\x90\x81\x1Cg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11`\x06\x1B\x90\x81\x1Cc\xFF\xFF\xFF\xFF\x81\x11`\x05\x1B\x90\x81\x1Ca\xFF\xFF\x81\x11`\x04\x1B\x90\x81\x1C\x90`\xFF\x82\x11`\x03\x1B\x91\x82\x1C\x92`\x0F\x84\x11`\x02\x1B\x93\x84\x1C\x94`\x01`\x03\x87\x11\x81\x1B\x96\x87\x1C\x11\x96\x17\x17\x17\x17\x17\x17\x17\x90`\x80\x82\x10\x15_\x14aI\x89W\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x82\x01\x1C[\x80\x02\x80`\x7F\x1C\x81`\xFF\x1C\x1C\x80\x02\x80`\x7F\x1C\x81`\xFF\x1C\x1C\x80\x02\x80`\x7F\x1C\x81`\xFF\x1C\x1C\x80\x02\x80`\x7F\x1C\x81`\xFF\x1C\x1C\x80\x02\x80`\x7F\x1C\x81`\xFF\x1C\x1C\x80\x02\x80`\x7F\x1C\x81`\xFF\x1C\x1C\x80\x02\x90\x81`\x7F\x1C\x82`\xFF\x1C\x1C\x80\x02\x92\x83`\x7F\x1C\x84`\xFF\x1C\x1C\x80\x02\x94\x85`\x7F\x1C\x86`\xFF\x1C\x1C\x80\x02\x96\x87`\x7F\x1C\x88`\xFF\x1C\x1C\x80\x02\x98\x89`\x7F\x1C\x8A`\xFF\x1C\x1C\x80\x02\x9A\x8B`\x7F\x1C\x8C`\xFF\x1C\x1C\x80\x02\x9C\x8D\x80`\x7F\x1C\x90`\xFF\x1C\x1C\x80\x02`\xCD\x1Cf\x04\0\0\0\0\0\0\x16\x9D`\xCC\x1Cf\x08\0\0\0\0\0\0\x16\x9C`\xCB\x1Cf\x10\0\0\0\0\0\0\x16\x9B`\xCA\x1Cf \0\0\0\0\0\0\x16\x9A`\xC9\x1Cf@\0\0\0\0\0\0\x16\x99`\xC8\x1Cf\x80\0\0\0\0\0\0\x16\x98`\xC7\x1Cg\x01\0\0\0\0\0\0\0\x16\x97`\xC6\x1Cg\x02\0\0\0\0\0\0\0\x16\x96`\xC5\x1Cg\x04\0\0\0\0\0\0\0\x16\x95`\xC4\x1Cg\x08\0\0\0\0\0\0\0\x16\x94`\xC3\x1Cg\x10\0\0\0\0\0\0\0\x16\x93`\xC2\x1Cg \0\0\0\0\0\0\0\x16\x92`\xC1\x1Cg@\0\0\0\0\0\0\0\x16\x91`\xC0\x1Cg\x80\0\0\0\0\0\0\0\x16\x90\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x01`@\x1B\x17\x17\x17\x17\x17\x17\x17\x17\x17\x17\x17\x17\x17\x17i6'\xA3\x01\xD7\x10UwL\x85\x02\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFDp\x9B~T\x80\xFB\xA5\xA5\x0F\xED^b\xFF\xC5V\x81\x01`\x80\x1D`\x02\x0B\x90o\xDB-\xF0\x9E\x81\x95\x9A\x81E^&\x07\x99\xA0c/\x01`\x80\x1D`\x02\x0B\x91\x82\x82\x14_\x14aIFWP\x90P\x90V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFaIz\x84aA\xDCV[\x16\x11aI\x84WP\x90V[\x90P\x90V[\x81`\x7F\x03\x1BaG^V[c1\xEF\xAF\xE8_R`\x04`\x1C\xFD[\x81\x15aI\xAAW\x04\x90V[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x12`\x04R`$_\xFD[\x90_`@QaI\xE5\x81a,\xC1V[_\x81R` \x81\x01\x90_\x82R`@\x81\x01\x95_\x87R``\x82\x01\x94_\x86R`\x80\x83\x01\x91_\x83R_`\xA0\x85\x01R\x83\x98\x88T\x93` \x84\x01Q\x15\x98o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x03\x8C\x01T\x16\x92\x8A\x15_\x14aZ\x17W_a\x0F\xFF\x88`\xB8\x1C\x16\x99[`@\x88\x01Q\x8ARR\x86s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90R\x85`\xA0\x1C`\x02\x0B\x90R\x88\x15_\x14aZ\x0CW`\x01\x8A\x01T\x90[R`\xA0\x85\x01\x81\x90R`\x80\x83\x01Qb@\0\0\x81\x16\x15aY\xFDWb\xBF\xFF\xFF\x16aJ\xA4\x81a3NV[a\xFF\xFF\x87\x16aY\xDCW\x90[\x81\x94_`@\x86\x01Q\x12\x92\x83\x15\x97\x88\x80\x99aY\xCBW[aY\xA3W`@\x87\x01Q\x15aY\x8DWPP\x89aY\x19W``\x85\x01s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81Q\x16\x82s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81\x10\x15aX\xD4WPQs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16d\x01\0\x02v\xA3\x81\x11\x15aX\xA9WP[`@Q`\x80R`\xE0`\x80Q\x01`\x80Q\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x08gW`@R_`\x80QR_` `\x80Q\x01R_`@`\x80Q\x01R_```\x80Q\x01R_`\x80\x80Q\x01R_`\xA0`\x80Q\x01R_`\xC0`\x80Q\x01R[\x8BQ\x15\x80\x15aXlW[aW\x1CWs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@\x8D\x01Q\x16`\x80QR``\x8C\x01Q`\x02\x0B\x85Q`\x02\x0B\x90\x81_\x81\x83\x07\x12\x91\x05\x03\x8C\x8C\x15_\x14aT\x8EWP`\xFF\x81\x16\x91\x8D`\x05`\x01\x85\x1B\x91\x84`\x08\x1D`\x01\x0B_R\x01` R\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ \x91\x80\x01\x01\x90T\x16\x91\x82\x15\x92\x83\x15\x93\x84_\x14aTYW\x81\x95_\x91a\x030W\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xF2v\x18\x96\x83p\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\xFF\x95\x10\x15aTJW[P\x80h\x01\0\0\0\0\0\0\0\0`\x02\x92\x10\x15aT<W[d\x01\0\0\0\0\x81\x10\x15aT.W[b\x01\0\0\x81\x10\x15aT W[a\x01\0\x81\x10\x15aT\x12W[`\x10\x81\x10\x15aT\x04W[`\x04\x81\x10\x15aS\xF7W[\x10\x15aS\xEAW[\x03\x16`\x02\x0B\x90\x03`\x02\x0B\x02`\x02\x0B[\x90[\x15\x15`@`\x80Q\x01R`\x02\x0B\x80` `\x80Q\x01R\x13\x15aS\xBDW[b\r\x89\xE8` `\x80Q\x01Q`\x02\x0B\x12\x15aS\xADW[\x8Bs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@\x81aM>` `\x80Q\x01Q`\x02\x0BaA\xDCV[\x16\x92\x83```\x80Q\x01R\x01Q\x16\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF``\x88\x01Q\x16\x90\x81\x8D\x15\x81\x83\x10\x18\x91\x18\x02\x18\x90\x8Do\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\xA0\x82\x01Q\x16\x90Q\x90b\xFF\xFF\xFF\x8A\x16\x92s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x85\x16\x81\x10\x15\x91_\x84\x12_\x14aQ\xF3W\x84b\x0FB@\x03aM\xCC\x81\x86_\x03a?\xC7V[\x96\x84\x15aQ\xC1WaM\xDE\x83\x85\x83aZ;V[\x95[\x86\x89\x10aP\xC9WPs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x97P\x95\x86\x91b\x0FB@\x82\x03aP\xBAWPP\x84[\x93[\x15aP\xACW\x91aN+\x92\x03\x80`\xFF\x1D\x90\x81\x01\x18\x90a?MV[\x90[`\xC0`\x80Q\x01R`\xA0`\x80Q\x01R`\x80\x80Q\x01R\x16`@\x8D\x01R\x86_\x14aPlWaN]`\xA0`\x80Q\x01QaZ&V[\x8CQ\x03\x8CR` \x8C\x01\x80Q\x90aN\x82aEb`\x80\x80Q\x01Q`\xC0`\x80Q\x01Q\x90a.\xC5V[\x91_\x83\x82\x03\x93\x12\x81\x84\x12\x81\x16\x91\x84\x13\x90\x15\x16\x17a\x1D\x91WR[a\xFF\xFF\x88\x16aP9W[o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\xA0\x8D\x01Q\x16\x80aP\x19W[Ps\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@\x8D\x01Q\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF```\x80Q\x01Q\x16\x81\x14_\x14aO\xDBWP`@`\x80Q\x01QaO*W[\x89\x15` `\x80Q\x01Q`\x02\x0B\x03`\x02\x0B``\x8D\x01RaK\x93V[\x89aO\xB2Wo\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFaO\x99\x8D\x8D`\x80\x82\x01Q\x90`\x04`\x02\x82\x01T\x91[` `\x80Q\x01Q`\x02\x0B`\x02\x0B_R\x01` R`@_ \x91`\x01\x83\x01\x90\x81T\x90\x03\x90U`\x02\x82\x01\x90\x81T\x90\x03\x90UT`\x80\x1D\x90\x8D\x15aO\xA4W[`\xA0\x01Q\x83\x16aF\x04V[\x16`\xA0\x8D\x01RaO\x10V[_\x91\x90\x91\x03`\x0F\x0B\x90aO\x8EV[o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFaO\x99\x8D\x8D`\x01\x81\x01T\x90`\x04`\x80\x84\x01Q\x91aOTV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80QQ\x16\x81\x03aP\x02W[PaK\x93V[aP\x0B\x90aFdV[`\x02\x0B``\x8D\x01R_aO\xFCV[aP)\x90`\xC0`\x80Q\x01Qa>\nV[`\x80\x8D\x01\x90\x81Q\x01\x90R_aN\xC2V[\x97b\x0FB@`\x80\x80Q\x01Qa\xFF\xFF\x8A\x16\x90`\xC0`\x80Q\x01Q\x01\x02\x04\x90\x81`\xC0`\x80Q\x01Q\x03`\xC0`\x80Q\x01R\x01\x97aN\xA5V[aP\x82`\x80\x80Q\x01Q`\xC0`\x80Q\x01Q\x01aZ&V[\x8CQ\x01\x8CR` \x8C\x01aP\xA5\x81QaP\x9F`\xA0`\x80Q\x01QaZ&V[\x90a0CV[\x90RaN\x9BV[aP\xB5\x92aZ\xE0V[aN+V[aP\xC4\x91\x87a[uV[aN\x10V[\x95PPP\x80\x94P\x15\x81\x15\x17aQ\xB4Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x94\x82\x15aQPWaP\xFF\x90\x85\x83a\\\x13V[\x93[\x84\x80\x82\x84\x86\x15aQ\x1FWaQ\x14\x92aZ;V[\x80\x95\x01_\x03\x93aN\x12V[\x90P\x03\x80`\xFF\x1D\x90\x81\x01\x18`\x01l\x01\0\0\0\0\0\0\0\0\0\0\0\0aQD\x83\x86a?MV[\x92\x85\t\x15\x15\x16\x01aQ\x14V[aQ\x8C\x90aQ\x87\x90\x87\x81\x11aQ\x92WaQ\x7F\x90o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x88\x16\x90``\x1BaI\xA0V[\x87\x84\x16a.\xC5V[a\\\xA1V[\x93aQ\x01V[aQ\xAF\x90o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x88\x16\x90a@RV[aQ\x7FV[cO$a\xB8_R`\x04`\x1C\xFD[\x80\x84\x03\x80`\xFF\x1D\x90\x81\x01\x18`\x01l\x01\0\0\0\0\0\0\0\0\0\0\0\0aQ\xE6\x83\x87a?MV[\x92\x86\t\x15\x15\x16\x01\x95aM\xE0V[\x90\x94\x91\x93\x92\x91\x84\x15aS\x9CWaR\x13\x86\x82\x03\x80`\xFF\x1D\x90\x81\x01\x18\x83a?MV[\x92[\x83\x81\x10aR\x8EWP\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x95aRY\x92\x80\x96[\x15aR^W\x90aRK\x92\x91aZ;V[\x80\x93\x80b\x0FB@\x03\x91a[uV[aN-V[l\x01\0\0\0\0\0\0\0\0\0\0\0\0\x90`\x01\x92\x03\x80`\xFF\x1D\x90\x81\x01\x18aR\x83\x81\x85a?MV[\x93\t\x15\x15\x16\x01aRKV[\x92PP\x81\x81\x15\x86\x15\x17aQ\xB4W\x84\x15aSrWs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11aS\x19W``\x1Bo\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x80\x82\x06\x15\x15\x91\x04\x01\x90[\x81\x86\x11\x15aS\x0CW\x85s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFaRY\x93\x81\x80\x99\x16\x03\x16[\x80\x96aR;V[cC#\xA5U_R`\x04`\x1C\xFD[o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16aSD\x81l\x01\0\0\0\0\0\0\0\0\0\0\0\0\x84aA\x04V[\x91\x81\x15aI\xAAWl\x01\0\0\0\0\0\0\0\0\0\0\0\0\x90\taSfW[\x90aR\xDCV[`\x01\x01\x80aS`W_\x80\xFD[\x90\x85aS\x97aRY\x93\x83s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x99a[\x9EV[aS\x05V[aS\xA7\x82\x82\x88aZ\xE0V[\x92aR\x15V[b\r\x89\xE8` `\x80Q\x01RaM\x13V[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xF2v\x18` `\x80Q\x01RaL\xFEV[\x90`\x01\x83\x91\x01\x16\x90aL\xD2V[\x92\x81\x01\x84\x16\x92\x81\x1CaL\xCBV[`\x04\x93\x84\x01\x85\x16\x93\x1CaL\xC1V[`\x08\x93\x84\x01\x85\x16\x93\x1CaL\xB7V[`\x10\x93\x84\x01\x85\x16\x93\x1CaL\xACV[` \x93\x84\x01\x85\x16\x93\x1CaL\xA0V[`@\x93\x84\x01\x85\x16\x93\x1CaL\x92V[`\x80\x93P\x83\x1C\x90P`\x02aL|V[PP\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xF2v\x18\x93`\x02\x0B\x90\x03`\x02\x0B\x02`\x02\x0BaL\xE1V[\x90`\x01\x01\x91\x82`\x02\x0B\x92`\x05\x81`\xFF\x16\x93\x85`\x08\x1D`\x01\x0B_R\x01` R\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x01`\xFF`@_ \x93\x16\x1B\x01\x19\x90T\x16\x92\x83\x15\x93\x84\x15\x93\x84_\x14aV\xE2W\x81\x95a\x030W\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xF2v\x18\x95`\xFF\x92\x83\x90o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x15aV\xD8WPP`\x7F[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x15aV\xCEW\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xC0\x01\x83\x16[c\xFF\xFF\xFF\xFF\x82\x16\x15aV\xC4W\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x01\x83\x16[a\xFF\xFF\x82\x16\x15aV\xBAW\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xF0\x01\x83\x16[\x81\x84\x16\x15aV\xB0W\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xF8\x01\x83\x16[`\x0F\x82\x16\x15aV\xA6W\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC\x01\x83\x16[`\x03\x82\x16\x15aV\x9AW\x83\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFE`\x01\x92\x01\x16\x91[\x16aVqW[\x03\x16`\x02\x0B\x01`\x02\x0B\x02`\x02\x0B[\x90aL\xE3V[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x01\x82\x16aV]V[\x90`\x01\x90`\x02\x1CaVWV[\x90`\x04\x1C\x90aV%V[\x90`\x08\x1C\x90aU\xF7V[\x90`\x10\x1C\x90aU\xCAV[\x90` \x1C\x90aU\x9BV[\x90`@\x1C\x90aUjV[`\x80\x1C\x91PaU5V[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xF2v\x18\x95P`\xFF\x80\x92P\x03\x16`\x02\x0B\x01`\x02\x0B\x02`\x02\x0BaVkV[\x91\x95P\x91\x99\x96\x98\x92\x95P\x96\x92\x96``\x87\x01Q`\xA0\x1Bv\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@\x8A\x01Q\x16\x92\x16\x17\x17\x82Uo\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\xA0\x87\x01Q\x16\x80\x91\x03aX'W[P\x81\x15aX\x18W`\x02`\x80\x86\x01Q\x91\x01U[\x15\x14aW\xFBWaW\xE1`@aW\xD5` \x85\x01Qa4AV[\x92\x01Q\x83Q\x90\x03a4AV[o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90`\x80\x1B\x17\x93V[`@\x01Q\x81QaX\x0B\x91\x03a4AV[aW\xE1` \x83\x01Qa4AV[`\x01`\x80\x86\x01Q\x91\x01UaW\xBDV[o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x03\x83\x01T\x16\x17`\x03\x82\x01U_aW\xABV[Ps\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@\x8D\x01Q\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF``\x87\x01Q\x16\x14aK\x9DV[\x7F\x9EM|\xC7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04R`$_\xFD[\x82\x7F|\x9Cn\x8F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x04R`$R`D_\xFD[``\x85\x01s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81Q\x16\x82s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81\x11\x15aX\xD4WPQs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16s\xFF\xFD\x89c\xEF\xD1\xFCjPd\x88I]\x95\x1DRc\x98\x8D&\x81\x10\x15aX\xA9WPaK:V[\x9AP\x9APPPP\x97PPPPPP_\x92_\x92\x91\x90V[\x7F\x96 bF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[Pb\x0FB@b\xFF\xFF\xFF\x83\x16\x14aJ\xC4V[\x80a\xFF\xFF\x88\x16\x02b\x0FB@\x80\x82\x06\x15\x15\x91\x04\x01\x90a\xFF\xFF\x88\x16\x01\x03\x90aJ\xAFV[P\x83`\xD0\x1Cb\xFF\xFF\xFF\x16aJ\xA4V[`\x02\x8A\x01T\x90aJ~V[_a\x0F\xFF\x88`\xC4\x1C\x16\x99aJEV[_\x81\x12\x15a3\rWc\x93\xDA\xFD\xF1_R`\x04`\x1C\xFD[\x91s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x84\x16\x11aZ\xD8W[\x82\x15aZ\xCCWs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x91aZ\xBF\x91{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\x84\x86\x81\x85\x16\x94\x03\x16\x91``\x1B\x16a[uV[\x91\x16\x80\x82\x06\x15\x15\x91\x04\x01\x90V[b\xBF\xC9!_R`\x04`\x1C\xFD[\x91\x90\x91aZpV[\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x16\x11a[oW[\x81\x15aZ\xCCWa[gs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x91a3\r\x94{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\x84\x86\x81\x85\x16\x94\x03\x16\x91``\x1B\x16aA\x04V[\x91\x16\x90aI\xA0V[\x90a[\x15V[\x92\x91\x90a[\x83\x82\x82\x86aA\x04V[\x93\x82\x15aI\xAAW\ta[\x91WV[\x90`\x01\x01\x90\x81\x15a\x030WV[\x90\x82\x15a\\\rW{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\x90``\x1B\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x92\x83\x81\x02\x92\x83\x83\x11\x91\x84\x04\x14\x16\x15a\\\0Wa3\r\x92aQ\x87\x92\x82\x03\x91a[uV[c\xF5\xC7\x87\xF1_R`\x04`\x1C\xFD[P\x90P\x90V[\x90\x91\x80\x15a\\\rWs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\x81\x94``\x1B\x16\x92\x16\x80\x82\x02\x81a\\c\x84\x83aI\xA0V[\x14a\\\x89W[P\x90a\\xa\\}\x92\x84aI\xA0V[a.\xC5V[\x80\x82\x06\x15\x15\x91\x04\x01\x16\x90V[\x83\x01\x83\x81\x10a\\iW\x91Pa\\\x9D\x92a[uV[\x16\x90V[t\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81\x10\x15a06Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90V\xFE\xA2dipfsX\"\x12 l\xDB8\xC1\xD8P\x9Fk\xD2\x0B\xB1\xA6nI\x98>5\xDE\xA0\x9F,\x8Dm+\x81\xE8\xE5\x85'\xC8\xAC\x7FdsolcC\0\x08\x1A\x003",
    );
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct BalanceDelta(alloy::sol_types::private::I256);
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<BalanceDelta> for alloy::sol_types::private::I256 {
            #[inline]
            fn stv_to_tokens(
                &self,
            ) -> <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::Token<'_>
            {
                alloy_sol_types::private::SolTypeValue::<
                    alloy::sol_types::sol_data::Int<256>,
                >::stv_to_tokens(self)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::tokenize(self).0
            }
            #[inline]
            fn stv_abi_encode_packed_to(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
                <alloy::sol_types::sol_data::Int<
                    256,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(self, out)
            }
        }
        #[automatically_derived]
        impl BalanceDelta {
            /// The Solidity type name.
            pub const NAME: &'static str = stringify!(@ name);
            /// Convert from the underlying value type.
            #[inline]
            pub const fn from(value: alloy::sol_types::private::I256) -> Self {
                Self(value)
            }
            /// Return the underlying value.
            #[inline]
            pub const fn into(self) -> alloy::sol_types::private::I256 {
                self.0
            }
            /// Return the single encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode(&self.0)
            }
            /// Return the packed encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode_packed(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode_packed(&self.0)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for BalanceDelta {
            type RustType = alloy::sol_types::private::I256;
            type Token<'a> =
                <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = Self::NAME;
            const ENCODED_SIZE: Option<usize> =
                <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                Self::type_check(token).is_ok()
            }
            #[inline]
            fn type_check(token: &Self::Token<'_>) -> alloy_sol_types::Result<()> {
                <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::type_check(
                    token,
                )
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::detokenize(
                    token,
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for BalanceDelta {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                <alloy::sol_types::sol_data::Int<
                    256,
                > as alloy_sol_types::EventTopic>::topic_preimage_length(rust)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Int<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, out)
            }
            #[inline]
            fn encode_topic(rust: &Self::RustType) -> alloy_sol_types::abi::token::WordToken {
                <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::EventTopic>::encode_topic(
                    rust,
                )
            }
        }
    };
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct Currency(alloy::sol_types::private::Address);
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Currency> for alloy::sol_types::private::Address {
            #[inline]
            fn stv_to_tokens(
                &self,
            ) -> <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::Token<'_>
            {
                alloy_sol_types::private::SolTypeValue::<
                    alloy::sol_types::sol_data::Address,
                >::stv_to_tokens(self)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(self).0
            }
            #[inline]
            fn stv_abi_encode_packed_to(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
                <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::abi_encode_packed_to(
                    self,
                    out,
                )
            }
        }
        #[automatically_derived]
        impl Currency {
            /// The Solidity type name.
            pub const NAME: &'static str = stringify!(@ name);
            /// Convert from the underlying value type.
            #[inline]
            pub const fn from(value: alloy::sol_types::private::Address) -> Self {
                Self(value)
            }
            /// Return the underlying value.
            #[inline]
            pub const fn into(self) -> alloy::sol_types::private::Address {
                self.0
            }
            /// Return the single encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode(&self.0)
            }
            /// Return the packed encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode_packed(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode_packed(&self.0)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for Currency {
            type RustType = alloy::sol_types::private::Address;
            type Token<'a> =
                <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = Self::NAME;
            const ENCODED_SIZE: Option<usize> =
                <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                Self::type_check(token).is_ok()
            }
            #[inline]
            fn type_check(token: &Self::Token<'_>) -> alloy_sol_types::Result<()> {
                <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::type_check(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::detokenize(token)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for Currency {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                    rust,
                )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    out,
                )
            }
            #[inline]
            fn encode_topic(rust: &Self::RustType) -> alloy_sol_types::abi::token::WordToken {
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    rust,
                )
            }
        }
    };
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct PoolId(alloy::sol_types::private::FixedBytes<32>);
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<PoolId> for alloy::sol_types::private::FixedBytes<32> {
            #[inline]
            fn stv_to_tokens(
                &self,
            ) -> <alloy::sol_types::sol_data::FixedBytes<32> as alloy_sol_types::SolType>::Token<'_>
            {
                alloy_sol_types::private::SolTypeValue::<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >::stv_to_tokens(self)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <alloy::sol_types::sol_data::FixedBytes<32> as alloy_sol_types::SolType>::tokenize(
                    self,
                )
                .0
            }
            #[inline]
            fn stv_abi_encode_packed_to(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(self, out)
            }
        }
        #[automatically_derived]
        impl PoolId {
            /// The Solidity type name.
            pub const NAME: &'static str = stringify!(@ name);
            /// Convert from the underlying value type.
            #[inline]
            pub const fn from(value: alloy::sol_types::private::FixedBytes<32>) -> Self {
                Self(value)
            }
            /// Return the underlying value.
            #[inline]
            pub const fn into(self) -> alloy::sol_types::private::FixedBytes<32> {
                self.0
            }
            /// Return the single encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode(&self.0)
            }
            /// Return the packed encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode_packed(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode_packed(&self.0)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for PoolId {
            type RustType = alloy::sol_types::private::FixedBytes<32>;
            type Token<'a> =
                <alloy::sol_types::sol_data::FixedBytes<32> as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = Self::NAME;
            const ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::FixedBytes<
                32,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                Self::type_check(token).is_ok()
            }
            #[inline]
            fn type_check(token: &Self::Token<'_>) -> alloy_sol_types::Result<()> {
                <alloy::sol_types::sol_data::FixedBytes<32> as alloy_sol_types::SolType>::type_check(
                    token,
                )
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                <alloy::sol_types::sol_data::FixedBytes<32> as alloy_sol_types::SolType>::detokenize(
                    token,
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for PoolId {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::topic_preimage_length(rust)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, out)
            }
            #[inline]
            fn encode_topic(rust: &Self::RustType) -> alloy_sol_types::abi::token::WordToken {
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(rust)
            }
        }
    };
    /**```solidity
    struct ModifyLiquidityParams { int24 tickLower; int24 tickUpper; int256 liquidityDelta; bytes32 salt; }
    ```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct ModifyLiquidityParams {
        pub tickLower: <alloy::sol_types::sol_data::Int<24> as alloy::sol_types::SolType>::RustType,
        pub tickUpper: <alloy::sol_types::sol_data::Int<24> as alloy::sol_types::SolType>::RustType,
        pub liquidityDelta: alloy::sol_types::private::I256,
        pub salt: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Int<24>,
            alloy::sol_types::sol_data::Int<24>,
            alloy::sol_types::sol_data::Int<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            <alloy::sol_types::sol_data::Int<24> as alloy::sol_types::SolType>::RustType,
            <alloy::sol_types::sol_data::Int<24> as alloy::sol_types::SolType>::RustType,
            alloy::sol_types::private::I256,
            alloy::sol_types::private::FixedBytes<32>,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ModifyLiquidityParams> for UnderlyingRustTuple<'_> {
            fn from(value: ModifyLiquidityParams) -> Self {
                (
                    value.tickLower,
                    value.tickUpper,
                    value.liquidityDelta,
                    value.salt,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ModifyLiquidityParams {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    tickLower: tuple.0,
                    tickUpper: tuple.1,
                    liquidityDelta: tuple.2,
                    salt: tuple.3,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for ModifyLiquidityParams {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for ModifyLiquidityParams {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Int<
                        24,
                    > as alloy_sol_types::SolType>::tokenize(&self.tickLower),
                    <alloy::sol_types::sol_data::Int<
                        24,
                    > as alloy_sol_types::SolType>::tokenize(&self.tickUpper),
                    <alloy::sol_types::sol_data::Int<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.liquidityDelta),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.salt),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encode_packed_to(
                    &tuple, out,
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for ModifyLiquidityParams {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for ModifyLiquidityParams {
            const NAME: &'static str = "ModifyLiquidityParams";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "ModifyLiquidityParams(int24 tickLower,int24 tickUpper,int256 liquidityDelta,bytes32 salt)",
                )
            }
            #[inline]
            fn eip712_components(
            ) -> alloy_sol_types::private::Vec<alloy_sol_types::private::Cow<'static, str>>
            {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Int<
                        24,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.tickLower)
                        .0,
                    <alloy::sol_types::sol_data::Int<
                        24,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.tickUpper)
                        .0,
                    <alloy::sol_types::sol_data::Int<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.liquidityDelta,
                        )
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.salt)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for ModifyLiquidityParams {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Int<
                        24,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.tickLower,
                    )
                    + <alloy::sol_types::sol_data::Int<
                        24,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.tickUpper,
                    )
                    + <alloy::sol_types::sol_data::Int<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.liquidityDelta,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.salt)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(<Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust));
                <alloy::sol_types::sol_data::Int<
                    24,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.tickLower,
                    out,
                );
                <alloy::sol_types::sol_data::Int<
                    24,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.tickUpper,
                    out,
                );
                <alloy::sol_types::sol_data::Int<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.liquidityDelta,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.salt,
                    out,
                );
            }
            #[inline]
            fn encode_topic(rust: &Self::RustType) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, &mut out);
                alloy_sol_types::abi::token::WordToken(alloy_sol_types::private::keccak256(out))
            }
        }
    };
    /**```solidity
    struct PoolKey { Currency currency0; Currency currency1; uint24 fee; int24 tickSpacing; address hooks; }
    ```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct PoolKey {
        pub currency0: <Currency as alloy::sol_types::SolType>::RustType,
        pub currency1: <Currency as alloy::sol_types::SolType>::RustType,
        pub fee: <alloy::sol_types::sol_data::Uint<24> as alloy::sol_types::SolType>::RustType,
        pub tickSpacing:
            <alloy::sol_types::sol_data::Int<24> as alloy::sol_types::SolType>::RustType,
        pub hooks: alloy::sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            Currency,
            Currency,
            alloy::sol_types::sol_data::Uint<24>,
            alloy::sol_types::sol_data::Int<24>,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            <Currency as alloy::sol_types::SolType>::RustType,
            <Currency as alloy::sol_types::SolType>::RustType,
            <alloy::sol_types::sol_data::Uint<24> as alloy::sol_types::SolType>::RustType,
            <alloy::sol_types::sol_data::Int<24> as alloy::sol_types::SolType>::RustType,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<PoolKey> for UnderlyingRustTuple<'_> {
            fn from(value: PoolKey) -> Self {
                (
                    value.currency0,
                    value.currency1,
                    value.fee,
                    value.tickSpacing,
                    value.hooks,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for PoolKey {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    currency0: tuple.0,
                    currency1: tuple.1,
                    fee: tuple.2,
                    tickSpacing: tuple.3,
                    hooks: tuple.4,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for PoolKey {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for PoolKey {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <Currency as alloy_sol_types::SolType>::tokenize(&self.currency0),
                    <Currency as alloy_sol_types::SolType>::tokenize(&self.currency1),
                    <alloy::sol_types::sol_data::Uint<24> as alloy_sol_types::SolType>::tokenize(
                        &self.fee,
                    ),
                    <alloy::sol_types::sol_data::Int<24> as alloy_sol_types::SolType>::tokenize(
                        &self.tickSpacing,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.hooks,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encode_packed_to(
                    &tuple, out,
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for PoolKey {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for PoolKey {
            const NAME: &'static str = "PoolKey";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "PoolKey(address currency0,address currency1,uint24 fee,int24 tickSpacing,address hooks)",
                )
            }
            #[inline]
            fn eip712_components(
            ) -> alloy_sol_types::private::Vec<alloy_sol_types::private::Cow<'static, str>>
            {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <Currency as alloy_sol_types::SolType>::eip712_data_word(
                            &self.currency0,
                        )
                        .0,
                    <Currency as alloy_sol_types::SolType>::eip712_data_word(
                            &self.currency1,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        24,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.fee)
                        .0,
                    <alloy::sol_types::sol_data::Int<
                        24,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.tickSpacing)
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.hooks,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for PoolKey {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <Currency as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.currency0,
                    )
                    + <Currency as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.currency1,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        24,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.fee)
                    + <alloy::sol_types::sol_data::Int<
                        24,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.tickSpacing,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.hooks,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(<Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust));
                <Currency as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.currency0,
                    out,
                );
                <Currency as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.currency1,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    24,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.fee, out);
                <alloy::sol_types::sol_data::Int<
                    24,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.tickSpacing,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.hooks,
                    out,
                );
            }
            #[inline]
            fn encode_topic(rust: &Self::RustType) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, &mut out);
                alloy_sol_types::abi::token::WordToken(alloy_sol_types::private::keccak256(out))
            }
        }
    };
    /**```solidity
    struct SwapParams { bool zeroForOne; int256 amountSpecified; uint160 sqrtPriceLimitX96; }
    ```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct SwapParams {
        pub zeroForOne: bool,
        pub amountSpecified: alloy::sol_types::private::I256,
        pub sqrtPriceLimitX96:
            <alloy::sol_types::sol_data::Uint<160> as alloy::sol_types::SolType>::RustType,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bool,
            alloy::sol_types::sol_data::Int<256>,
            alloy::sol_types::sol_data::Uint<160>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            bool,
            alloy::sol_types::private::I256,
            <alloy::sol_types::sol_data::Uint<160> as alloy::sol_types::SolType>::RustType,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SwapParams> for UnderlyingRustTuple<'_> {
            fn from(value: SwapParams) -> Self {
                (
                    value.zeroForOne,
                    value.amountSpecified,
                    value.sqrtPriceLimitX96,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for SwapParams {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    zeroForOne: tuple.0,
                    amountSpecified: tuple.1,
                    sqrtPriceLimitX96: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for SwapParams {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for SwapParams {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.zeroForOne,
                    ),
                    <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::tokenize(
                        &self.amountSpecified,
                    ),
                    <alloy::sol_types::sol_data::Uint<160> as alloy_sol_types::SolType>::tokenize(
                        &self.sqrtPriceLimitX96,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encode_packed_to(
                    &tuple, out,
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for SwapParams {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for SwapParams {
            const NAME: &'static str = "SwapParams";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "SwapParams(bool zeroForOne,int256 amountSpecified,uint160 sqrtPriceLimitX96)",
                )
            }
            #[inline]
            fn eip712_components(
            ) -> alloy_sol_types::private::Vec<alloy_sol_types::private::Cow<'static, str>>
            {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::eip712_data_word(
                            &self.zeroForOne,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Int<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.amountSpecified,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        160,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.sqrtPriceLimitX96,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for SwapParams {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.zeroForOne,
                    )
                    + <alloy::sol_types::sol_data::Int<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.amountSpecified,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        160,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.sqrtPriceLimitX96,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(<Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust));
                <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.zeroForOne,
                    out,
                );
                <alloy::sol_types::sol_data::Int<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.amountSpecified,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    160,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.sqrtPriceLimitX96,
                    out,
                );
            }
            #[inline]
            fn encode_topic(rust: &Self::RustType) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, &mut out);
                alloy_sol_types::abi::token::WordToken(alloy_sol_types::private::keccak256(out))
            }
        }
    };
    /**Custom error with signature `AlreadyUnlocked()` and selector `0x5090d6c6`.
    ```solidity
    error AlreadyUnlocked();
    ```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct AlreadyUnlocked {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AlreadyUnlocked> for UnderlyingRustTuple<'_> {
            fn from(value: AlreadyUnlocked) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AlreadyUnlocked {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AlreadyUnlocked {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AlreadyUnlocked()";
            const SELECTOR: [u8; 4] = [80u8, 144u8, 214u8, 198u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `CurrenciesOutOfOrderOrEqual()` and selector `0xeaa6c6eb`.
    ```solidity
    error CurrenciesOutOfOrderOrEqual();
    ```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct CurrenciesOutOfOrderOrEqual {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<CurrenciesOutOfOrderOrEqual> for UnderlyingRustTuple<'_> {
            fn from(value: CurrenciesOutOfOrderOrEqual) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for CurrenciesOutOfOrderOrEqual {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for CurrenciesOutOfOrderOrEqual {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "CurrenciesOutOfOrderOrEqual()";
            const SELECTOR: [u8; 4] = [234u8, 166u8, 198u8, 235u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `CurrencyNotSettled()` and selector `0x5212cba1`.
    ```solidity
    error CurrencyNotSettled();
    ```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct CurrencyNotSettled {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<CurrencyNotSettled> for UnderlyingRustTuple<'_> {
            fn from(value: CurrencyNotSettled) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for CurrencyNotSettled {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for CurrencyNotSettled {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "CurrencyNotSettled()";
            const SELECTOR: [u8; 4] = [82u8, 18u8, 203u8, 161u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `DelegateCallNotAllowed()` and selector `0x0d89438e`.
    ```solidity
    error DelegateCallNotAllowed();
    ```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct DelegateCallNotAllowed {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<DelegateCallNotAllowed> for UnderlyingRustTuple<'_> {
            fn from(value: DelegateCallNotAllowed) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for DelegateCallNotAllowed {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for DelegateCallNotAllowed {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "DelegateCallNotAllowed()";
            const SELECTOR: [u8; 4] = [13u8, 137u8, 67u8, 142u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `InvalidCaller()` and selector `0x48f5c3ed`.
    ```solidity
    error InvalidCaller();
    ```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct InvalidCaller {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidCaller> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidCaller) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidCaller {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidCaller {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidCaller()";
            const SELECTOR: [u8; 4] = [72u8, 245u8, 195u8, 237u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `InvalidProtocolFee()` and selector `0xba97f838`.
    ```solidity
    error InvalidProtocolFee();
    ```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct InvalidProtocolFee {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidProtocolFee> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidProtocolFee) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidProtocolFee {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidProtocolFee {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidProtocolFee()";
            const SELECTOR: [u8; 4] = [186u8, 151u8, 248u8, 56u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `ManagerLocked()` and selector `0x54e3ca0d`.
    ```solidity
    error ManagerLocked();
    ```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct ManagerLocked {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ManagerLocked> for UnderlyingRustTuple<'_> {
            fn from(value: ManagerLocked) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ManagerLocked {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ManagerLocked {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ManagerLocked()";
            const SELECTOR: [u8; 4] = [84u8, 227u8, 202u8, 13u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `NonZeroNativeValue()` and selector `0x19d245cf`.
    ```solidity
    error NonZeroNativeValue();
    ```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct NonZeroNativeValue {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NonZeroNativeValue> for UnderlyingRustTuple<'_> {
            fn from(value: NonZeroNativeValue) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NonZeroNativeValue {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NonZeroNativeValue {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NonZeroNativeValue()";
            const SELECTOR: [u8; 4] = [25u8, 210u8, 69u8, 207u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `PoolNotInitialized()` and selector `0x486aa307`.
    ```solidity
    error PoolNotInitialized();
    ```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct PoolNotInitialized {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<PoolNotInitialized> for UnderlyingRustTuple<'_> {
            fn from(value: PoolNotInitialized) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for PoolNotInitialized {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for PoolNotInitialized {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "PoolNotInitialized()";
            const SELECTOR: [u8; 4] = [72u8, 106u8, 163u8, 7u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `ProtocolFeeCannotBeFetched()` and selector `0x1ee49702`.
    ```solidity
    error ProtocolFeeCannotBeFetched();
    ```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct ProtocolFeeCannotBeFetched {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ProtocolFeeCannotBeFetched> for UnderlyingRustTuple<'_> {
            fn from(value: ProtocolFeeCannotBeFetched) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ProtocolFeeCannotBeFetched {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ProtocolFeeCannotBeFetched {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ProtocolFeeCannotBeFetched()";
            const SELECTOR: [u8; 4] = [30u8, 228u8, 151u8, 2u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `SwapAmountCannotBeZero()` and selector `0xbe8b8507`.
    ```solidity
    error SwapAmountCannotBeZero();
    ```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct SwapAmountCannotBeZero {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SwapAmountCannotBeZero> for UnderlyingRustTuple<'_> {
            fn from(value: SwapAmountCannotBeZero) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for SwapAmountCannotBeZero {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for SwapAmountCannotBeZero {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SwapAmountCannotBeZero()";
            const SELECTOR: [u8; 4] = [190u8, 139u8, 133u8, 7u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `TickSpacingTooLarge()` and selector `0xb02b5dc2`.
    ```solidity
    error TickSpacingTooLarge();
    ```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct TickSpacingTooLarge {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<TickSpacingTooLarge> for UnderlyingRustTuple<'_> {
            fn from(value: TickSpacingTooLarge) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for TickSpacingTooLarge {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for TickSpacingTooLarge {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "TickSpacingTooLarge()";
            const SELECTOR: [u8; 4] = [176u8, 43u8, 93u8, 194u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `TickSpacingTooSmall()` and selector `0x16fe7696`.
    ```solidity
    error TickSpacingTooSmall();
    ```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct TickSpacingTooSmall {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<TickSpacingTooSmall> for UnderlyingRustTuple<'_> {
            fn from(value: TickSpacingTooSmall) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for TickSpacingTooSmall {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for TickSpacingTooSmall {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "TickSpacingTooSmall()";
            const SELECTOR: [u8; 4] = [22u8, 254u8, 118u8, 150u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `UnauthorizedDynamicLPFeeUpdate()` and selector `0x30d21641`.
    ```solidity
    error UnauthorizedDynamicLPFeeUpdate();
    ```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct UnauthorizedDynamicLPFeeUpdate {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnauthorizedDynamicLPFeeUpdate> for UnderlyingRustTuple<'_> {
            fn from(value: UnauthorizedDynamicLPFeeUpdate) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for UnauthorizedDynamicLPFeeUpdate {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for UnauthorizedDynamicLPFeeUpdate {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UnauthorizedDynamicLPFeeUpdate()";
            const SELECTOR: [u8; 4] = [48u8, 210u8, 22u8, 65u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Event with signature `Approval(address,address,uint256,uint256)` and selector `0xb3fd5071835887567a0671151121894ddccc2842f1d10bedad13e0d17cace9a7`.
    ```solidity
    event Approval(address indexed owner, address indexed spender, uint256 indexed id, uint256 amount);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    #[derive(Clone)]
    pub struct Approval {
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub spender: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub id: alloy::sol_types::private::U256,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Approval {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            const SIGNATURE: &'static str = "Approval(address,address,uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 =
                alloy_sol_types::private::B256::new([
                    179u8, 253u8, 80u8, 113u8, 131u8, 88u8, 135u8, 86u8, 122u8, 6u8, 113u8, 21u8,
                    17u8, 33u8, 137u8, 77u8, 220u8, 204u8, 40u8, 66u8, 241u8, 209u8, 11u8, 237u8,
                    173u8, 19u8, 224u8, 209u8, 124u8, 172u8, 233u8, 167u8,
                ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    owner: topics.1,
                    spender: topics.2,
                    id: topics.3,
                    amount: data.0,
                }
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.amount,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.owner.clone(),
                    self.spender.clone(),
                    self.id.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(Self::SIGNATURE_HASH);
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.owner,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.spender,
                );
                out[3usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.id);
                Ok(())
            }
        }
        impl From<&Approval> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Approval) -> alloy_sol_types::private::LogData {
                let topics = alloy_sol_types::SolEvent::encode_topics(this)
                    .into_iter()
                    .map(|t| t.into())
                    .collect();
                let data = alloy_sol_types::SolEvent::encode_data(this).into();
                alloy_sol_types::private::LogData::new_unchecked(topics, data)
            }
        }
    };
    /**Event with signature `Initialize(bytes32,address,address,uint24,int24,address)` and selector `0x3fd553db44f207b1f41348cfc4d251860814af9eadc470e8e7895e4d120511f4`.
    ```solidity
    event Initialize(PoolId id, Currency indexed currency0, Currency indexed currency1, uint24 fee, int24 tickSpacing, address hooks);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    #[derive(Clone)]
    pub struct Initialize {
        #[allow(missing_docs)]
        pub id: <PoolId as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub currency0: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub currency1: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub fee: <alloy::sol_types::sol_data::Uint<24> as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub tickSpacing:
            <alloy::sol_types::sol_data::Int<24> as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub hooks: alloy::sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Initialize {
            type DataTuple<'a> = (
                PoolId,
                alloy::sol_types::sol_data::Uint<24>,
                alloy::sol_types::sol_data::Int<24>,
                alloy::sol_types::sol_data::Address,
            );
            type DataToken<'a> = <Self::DataTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            const SIGNATURE: &'static str =
                "Initialize(bytes32,address,address,uint24,int24,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 =
                alloy_sol_types::private::B256::new([
                    63u8, 213u8, 83u8, 219u8, 68u8, 242u8, 7u8, 177u8, 244u8, 19u8, 72u8, 207u8,
                    196u8, 210u8, 81u8, 134u8, 8u8, 20u8, 175u8, 158u8, 173u8, 196u8, 112u8, 232u8,
                    231u8, 137u8, 94u8, 77u8, 18u8, 5u8, 17u8, 244u8,
                ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    id: data.0,
                    currency0: topics.1,
                    currency1: topics.2,
                    fee: data.1,
                    tickSpacing: data.2,
                    hooks: data.3,
                }
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <PoolId as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Uint<24> as alloy_sol_types::SolType>::tokenize(
                        &self.fee,
                    ),
                    <alloy::sol_types::sol_data::Int<24> as alloy_sol_types::SolType>::tokenize(
                        &self.tickSpacing,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.hooks,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.currency0.clone(),
                    self.currency1.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(Self::SIGNATURE_HASH);
                out[1usize] = <alloy_sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.currency0);
                out[2usize] = <alloy_sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.currency1);
                Ok(())
            }
        }
        impl From<&Initialize> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Initialize) -> alloy_sol_types::private::LogData {
                let topics = alloy_sol_types::SolEvent::encode_topics(this)
                    .into_iter()
                    .map(|t| t.into())
                    .collect();
                let data = alloy_sol_types::SolEvent::encode_data(this).into();
                alloy_sol_types::private::LogData::new_unchecked(topics, data)
            }
        }
    };
    /**Event with signature `ModifyLiquidity(bytes32,address,int24,int24,int256)` and selector `0x541c041c2cce48e614b3de043c9280f06b6164c0a1741649e2de3c3d375f7974`.
    ```solidity
    event ModifyLiquidity(PoolId indexed id, address indexed sender, int24 tickLower, int24 tickUpper, int256 liquidityDelta);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    #[derive(Clone)]
    pub struct ModifyLiquidity {
        #[allow(missing_docs)]
        pub id: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub tickLower: <alloy::sol_types::sol_data::Int<24> as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub tickUpper: <alloy::sol_types::sol_data::Int<24> as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub liquidityDelta: alloy::sol_types::private::I256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ModifyLiquidity {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Int<24>,
                alloy::sol_types::sol_data::Int<24>,
                alloy::sol_types::sol_data::Int<256>,
            );
            type DataToken<'a> = <Self::DataTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "ModifyLiquidity(bytes32,address,int24,int24,int256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 =
                alloy_sol_types::private::B256::new([
                    84u8, 28u8, 4u8, 28u8, 44u8, 206u8, 72u8, 230u8, 20u8, 179u8, 222u8, 4u8, 60u8,
                    146u8, 128u8, 240u8, 107u8, 97u8, 100u8, 192u8, 161u8, 116u8, 22u8, 73u8,
                    226u8, 222u8, 60u8, 61u8, 55u8, 95u8, 121u8, 116u8,
                ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    id: topics.1,
                    sender: topics.2,
                    tickLower: data.0,
                    tickUpper: data.1,
                    liquidityDelta: data.2,
                }
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Int<24> as alloy_sol_types::SolType>::tokenize(
                        &self.tickLower,
                    ),
                    <alloy::sol_types::sol_data::Int<24> as alloy_sol_types::SolType>::tokenize(
                        &self.tickUpper,
                    ),
                    <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::tokenize(
                        &self.liquidityDelta,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.id.clone(),
                    self.sender.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(Self::SIGNATURE_HASH);
                out[1usize] = <alloy_sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.id);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.sender,
                );
                Ok(())
            }
        }
        impl From<&ModifyLiquidity> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &ModifyLiquidity) -> alloy_sol_types::private::LogData {
                let topics = alloy_sol_types::SolEvent::encode_topics(this)
                    .into_iter()
                    .map(|t| t.into())
                    .collect();
                let data = alloy_sol_types::SolEvent::encode_data(this).into();
                alloy_sol_types::private::LogData::new_unchecked(topics, data)
            }
        }
    };
    /**Event with signature `OperatorSet(address,address,bool)` and selector `0xceb576d9f15e4e200fdb5096d64d5dfd667e16def20c1eefd14256d8e3faa267`.
    ```solidity
    event OperatorSet(address indexed owner, address indexed operator, bool approved);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    #[derive(Clone)]
    pub struct OperatorSet {
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub approved: bool,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for OperatorSet {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type DataToken<'a> = <Self::DataTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "OperatorSet(address,address,bool)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 =
                alloy_sol_types::private::B256::new([
                    206u8, 181u8, 118u8, 217u8, 241u8, 94u8, 78u8, 32u8, 15u8, 219u8, 80u8, 150u8,
                    214u8, 77u8, 93u8, 253u8, 102u8, 126u8, 22u8, 222u8, 242u8, 12u8, 30u8, 239u8,
                    209u8, 66u8, 86u8, 216u8, 227u8, 250u8, 162u8, 103u8,
                ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    owner: topics.1,
                    operator: topics.2,
                    approved: data.0,
                }
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.approved,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.owner.clone(),
                    self.operator.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(Self::SIGNATURE_HASH);
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.owner,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.operator,
                );
                Ok(())
            }
        }
        impl From<&OperatorSet> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &OperatorSet) -> alloy_sol_types::private::LogData {
                let topics = alloy_sol_types::SolEvent::encode_topics(this)
                    .into_iter()
                    .map(|t| t.into())
                    .collect();
                let data = alloy_sol_types::SolEvent::encode_data(this).into();
                alloy_sol_types::private::LogData::new_unchecked(topics, data)
            }
        }
    };
    /**Event with signature `OwnershipTransferred(address,address)` and selector `0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0`.
    ```solidity
    event OwnershipTransferred(address indexed user, address indexed newOwner);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    #[derive(Clone)]
    pub struct OwnershipTransferred {
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub newOwner: alloy::sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for OwnershipTransferred {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "OwnershipTransferred(address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 =
                alloy_sol_types::private::B256::new([
                    139u8, 224u8, 7u8, 156u8, 83u8, 22u8, 89u8, 20u8, 19u8, 68u8, 205u8, 31u8,
                    208u8, 164u8, 242u8, 132u8, 25u8, 73u8, 127u8, 151u8, 34u8, 163u8, 218u8,
                    175u8, 227u8, 180u8, 24u8, 111u8, 107u8, 100u8, 87u8, 224u8,
                ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    user: topics.1,
                    newOwner: topics.2,
                }
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.user.clone(),
                    self.newOwner.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(Self::SIGNATURE_HASH);
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.user,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.newOwner,
                );
                Ok(())
            }
        }
        impl From<&OwnershipTransferred> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &OwnershipTransferred) -> alloy_sol_types::private::LogData {
                let topics = alloy_sol_types::SolEvent::encode_topics(this)
                    .into_iter()
                    .map(|t| t.into())
                    .collect();
                let data = alloy_sol_types::SolEvent::encode_data(this).into();
                alloy_sol_types::private::LogData::new_unchecked(topics, data)
            }
        }
    };
    /**Event with signature `ProtocolFeeControllerUpdated(address)` and selector `0xb4bd8ef53df690b9943d3318996006dbb82a25f54719d8c8035b516a2a5b8acc`.
    ```solidity
    event ProtocolFeeControllerUpdated(address protocolFeeController);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    #[derive(Clone)]
    pub struct ProtocolFeeControllerUpdated {
        #[allow(missing_docs)]
        pub protocolFeeController: alloy::sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ProtocolFeeControllerUpdated {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type DataToken<'a> = <Self::DataTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "ProtocolFeeControllerUpdated(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 =
                alloy_sol_types::private::B256::new([
                    180u8, 189u8, 142u8, 245u8, 61u8, 246u8, 144u8, 185u8, 148u8, 61u8, 51u8, 24u8,
                    153u8, 96u8, 6u8, 219u8, 184u8, 42u8, 37u8, 245u8, 71u8, 25u8, 216u8, 200u8,
                    3u8, 91u8, 81u8, 106u8, 42u8, 91u8, 138u8, 204u8,
                ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    protocolFeeController: data.0,
                }
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.protocolFeeController,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(Self::SIGNATURE_HASH);
                Ok(())
            }
        }
        impl From<&ProtocolFeeControllerUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &ProtocolFeeControllerUpdated) -> alloy_sol_types::private::LogData {
                let topics = alloy_sol_types::SolEvent::encode_topics(this)
                    .into_iter()
                    .map(|t| t.into())
                    .collect();
                let data = alloy_sol_types::SolEvent::encode_data(this).into();
                alloy_sol_types::private::LogData::new_unchecked(topics, data)
            }
        }
    };
    /**Event with signature `ProtocolFeeUpdated(bytes32,uint24)` and selector `0xe9c42593e71f84403b84352cd168d693e2c9fcd1fdbcc3feb21d92b43e6696f9`.
    ```solidity
    event ProtocolFeeUpdated(PoolId indexed id, uint24 protocolFee);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    #[derive(Clone)]
    pub struct ProtocolFeeUpdated {
        #[allow(missing_docs)]
        pub id: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub protocolFee:
            <alloy::sol_types::sol_data::Uint<24> as alloy::sol_types::SolType>::RustType,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ProtocolFeeUpdated {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<24>,);
            type DataToken<'a> = <Self::DataTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            const SIGNATURE: &'static str = "ProtocolFeeUpdated(bytes32,uint24)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 =
                alloy_sol_types::private::B256::new([
                    233u8, 196u8, 37u8, 147u8, 231u8, 31u8, 132u8, 64u8, 59u8, 132u8, 53u8, 44u8,
                    209u8, 104u8, 214u8, 147u8, 226u8, 201u8, 252u8, 209u8, 253u8, 188u8, 195u8,
                    254u8, 178u8, 29u8, 146u8, 180u8, 62u8, 102u8, 150u8, 249u8,
                ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    id: topics.1,
                    protocolFee: data.0,
                }
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<24> as alloy_sol_types::SolType>::tokenize(
                        &self.protocolFee,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.id.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(Self::SIGNATURE_HASH);
                out[1usize] = <alloy_sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.id);
                Ok(())
            }
        }
        impl From<&ProtocolFeeUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &ProtocolFeeUpdated) -> alloy_sol_types::private::LogData {
                let topics = alloy_sol_types::SolEvent::encode_topics(this)
                    .into_iter()
                    .map(|t| t.into())
                    .collect();
                let data = alloy_sol_types::SolEvent::encode_data(this).into();
                alloy_sol_types::private::LogData::new_unchecked(topics, data)
            }
        }
    };
    /**Event with signature `Swap(bytes32,address,int128,int128,uint160,uint128,int24,uint24)` and selector `0x40e9cecb9f5f1f1c5b9c97dec2917b7ee92e57ba5563708daca94dd84ad7112f`.
    ```solidity
    event Swap(PoolId indexed id, address sender, int128 amount0, int128 amount1, uint160 sqrtPriceX96, uint128 liquidity, int24 tick, uint24 fee);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    #[derive(Clone)]
    pub struct Swap {
        #[allow(missing_docs)]
        pub id: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount0: i128,
        #[allow(missing_docs)]
        pub amount1: i128,
        #[allow(missing_docs)]
        pub sqrtPriceX96:
            <alloy::sol_types::sol_data::Uint<160> as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub liquidity: u128,
        #[allow(missing_docs)]
        pub tick: <alloy::sol_types::sol_data::Int<24> as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub fee: <alloy::sol_types::sol_data::Uint<24> as alloy::sol_types::SolType>::RustType,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Swap {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Int<128>,
                alloy::sol_types::sol_data::Int<128>,
                alloy::sol_types::sol_data::Uint<160>,
                alloy::sol_types::sol_data::Uint<128>,
                alloy::sol_types::sol_data::Int<24>,
                alloy::sol_types::sol_data::Uint<24>,
            );
            type DataToken<'a> = <Self::DataTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            const SIGNATURE: &'static str =
                "Swap(bytes32,address,int128,int128,uint160,uint128,int24,uint24)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 =
                alloy_sol_types::private::B256::new([
                    64u8, 233u8, 206u8, 203u8, 159u8, 95u8, 31u8, 28u8, 91u8, 156u8, 151u8, 222u8,
                    194u8, 145u8, 123u8, 126u8, 233u8, 46u8, 87u8, 186u8, 85u8, 99u8, 112u8, 141u8,
                    172u8, 169u8, 77u8, 216u8, 74u8, 215u8, 17u8, 47u8,
                ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    id: topics.1,
                    sender: data.0,
                    amount0: data.1,
                    amount1: data.2,
                    sqrtPriceX96: data.3,
                    liquidity: data.4,
                    tick: data.5,
                    fee: data.6,
                }
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sender,
                    ),
                    <alloy::sol_types::sol_data::Int<128> as alloy_sol_types::SolType>::tokenize(
                        &self.amount0,
                    ),
                    <alloy::sol_types::sol_data::Int<128> as alloy_sol_types::SolType>::tokenize(
                        &self.amount1,
                    ),
                    <alloy::sol_types::sol_data::Uint<160> as alloy_sol_types::SolType>::tokenize(
                        &self.sqrtPriceX96,
                    ),
                    <alloy::sol_types::sol_data::Uint<128> as alloy_sol_types::SolType>::tokenize(
                        &self.liquidity,
                    ),
                    <alloy::sol_types::sol_data::Int<24> as alloy_sol_types::SolType>::tokenize(
                        &self.tick,
                    ),
                    <alloy::sol_types::sol_data::Uint<24> as alloy_sol_types::SolType>::tokenize(
                        &self.fee,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.id.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(Self::SIGNATURE_HASH);
                out[1usize] = <alloy_sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.id);
                Ok(())
            }
        }
        impl From<&Swap> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Swap) -> alloy_sol_types::private::LogData {
                let topics = alloy_sol_types::SolEvent::encode_topics(this)
                    .into_iter()
                    .map(|t| t.into())
                    .collect();
                let data = alloy_sol_types::SolEvent::encode_data(this).into();
                alloy_sol_types::private::LogData::new_unchecked(topics, data)
            }
        }
    };
    /**Event with signature `Transfer(address,address,address,uint256,uint256)` and selector `0x1b3d7edb2e9c0b0e7c525b20aaaef0f5940d2ed71663c7d39266ecafac728859`.
    ```solidity
    event Transfer(address caller, address indexed from, address indexed to, uint256 indexed id, uint256 amount);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    #[derive(Clone)]
    pub struct Transfer {
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub from: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub id: alloy::sol_types::private::U256,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Transfer {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            const SIGNATURE: &'static str = "Transfer(address,address,address,uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 =
                alloy_sol_types::private::B256::new([
                    27u8, 61u8, 126u8, 219u8, 46u8, 156u8, 11u8, 14u8, 124u8, 82u8, 91u8, 32u8,
                    170u8, 174u8, 240u8, 245u8, 148u8, 13u8, 46u8, 215u8, 22u8, 99u8, 199u8, 211u8,
                    146u8, 102u8, 236u8, 175u8, 172u8, 114u8, 136u8, 89u8,
                ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    caller: data.0,
                    from: topics.1,
                    to: topics.2,
                    id: topics.3,
                    amount: data.1,
                }
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.caller,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.amount,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.from.clone(),
                    self.to.clone(),
                    self.id.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(Self::SIGNATURE_HASH);
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.from,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.to,
                );
                out[3usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.id);
                Ok(())
            }
        }
        impl From<&Transfer> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Transfer) -> alloy_sol_types::private::LogData {
                let topics = alloy_sol_types::SolEvent::encode_topics(this)
                    .into_iter()
                    .map(|t| t.into())
                    .collect();
                let data = alloy_sol_types::SolEvent::encode_data(this).into();
                alloy_sol_types::private::LogData::new_unchecked(topics, data)
            }
        }
    };
    /**Constructor`.
    ```solidity
    constructor(uint256 controllerGasLimit);
    ```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct constructorCall {
        pub controllerGasLimit: alloy::sol_types::private::U256,
    }
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    (value.controllerGasLimit,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        controllerGasLimit: tuple.0,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.controllerGasLimit,
                    ),
                )
            }
        }
    };
    /**Function with signature `MAX_TICK_SPACING()` and selector `0x60460f06`.
    ```solidity
    function MAX_TICK_SPACING() external view returns (int24);
    ```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct MAX_TICK_SPACINGCall {}
    ///Container type for the return parameters of the [`MAX_TICK_SPACING()`](MAX_TICK_SPACINGCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct MAX_TICK_SPACINGReturn {
        pub _0: <alloy::sol_types::sol_data::Int<24> as alloy::sol_types::SolType>::RustType,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<MAX_TICK_SPACINGCall> for UnderlyingRustTuple<'_> {
                fn from(value: MAX_TICK_SPACINGCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for MAX_TICK_SPACINGCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Int<24>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (<alloy::sol_types::sol_data::Int<24> as alloy::sol_types::SolType>::RustType,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<MAX_TICK_SPACINGReturn> for UnderlyingRustTuple<'_> {
                fn from(value: MAX_TICK_SPACINGReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for MAX_TICK_SPACINGReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for MAX_TICK_SPACINGCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = MAX_TICK_SPACINGReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Int<24>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "MAX_TICK_SPACING()";
            const SELECTOR: [u8; 4] = [96u8, 70u8, 15u8, 6u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `MIN_TICK_SPACING()` and selector `0x07eff0dd`.
    ```solidity
    function MIN_TICK_SPACING() external view returns (int24);
    ```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct MIN_TICK_SPACINGCall {}
    ///Container type for the return parameters of the [`MIN_TICK_SPACING()`](MIN_TICK_SPACINGCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct MIN_TICK_SPACINGReturn {
        pub _0: <alloy::sol_types::sol_data::Int<24> as alloy::sol_types::SolType>::RustType,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<MIN_TICK_SPACINGCall> for UnderlyingRustTuple<'_> {
                fn from(value: MIN_TICK_SPACINGCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for MIN_TICK_SPACINGCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Int<24>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (<alloy::sol_types::sol_data::Int<24> as alloy::sol_types::SolType>::RustType,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<MIN_TICK_SPACINGReturn> for UnderlyingRustTuple<'_> {
                fn from(value: MIN_TICK_SPACINGReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for MIN_TICK_SPACINGReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for MIN_TICK_SPACINGCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = MIN_TICK_SPACINGReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Int<24>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "MIN_TICK_SPACING()";
            const SELECTOR: [u8; 4] = [7u8, 239u8, 240u8, 221u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `allowance(address,address,uint256)` and selector `0x598af9e7`.
    ```solidity
    function allowance(address, address, uint256) external view returns (uint256);
    ```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct allowanceCall {
        pub _0: alloy::sol_types::private::Address,
        pub _1: alloy::sol_types::private::Address,
        pub _2: alloy::sol_types::private::U256,
    }
    ///Container type for the return parameters of the [`allowance(address,address,uint256)`](allowanceCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct allowanceReturn {
        pub _0: alloy::sol_types::private::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<allowanceCall> for UnderlyingRustTuple<'_> {
                fn from(value: allowanceCall) -> Self {
                    (value._0, value._1, value._2)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for allowanceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _0: tuple.0,
                        _1: tuple.1,
                        _2: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<allowanceReturn> for UnderlyingRustTuple<'_> {
                fn from(value: allowanceReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for allowanceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for allowanceCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = allowanceReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "allowance(address,address,uint256)";
            const SELECTOR: [u8; 4] = [89u8, 138u8, 249u8, 231u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._0,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._1,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self._2,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `approve(address,uint256,uint256)` and selector `0x426a8493`.
    ```solidity
    function approve(address spender, uint256 id, uint256 amount) external returns (bool);
    ```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct approveCall {
        pub spender: alloy::sol_types::private::Address,
        pub id: alloy::sol_types::private::U256,
        pub amount: alloy::sol_types::private::U256,
    }
    ///Container type for the return parameters of the [`approve(address,uint256,uint256)`](approveCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct approveReturn {
        pub _0: bool,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::U256,
                alloy::sol_types::private::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<approveCall> for UnderlyingRustTuple<'_> {
                fn from(value: approveCall) -> Self {
                    (value.spender, value.id, value.amount)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for approveCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        spender: tuple.0,
                        id: tuple.1,
                        amount: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<approveReturn> for UnderlyingRustTuple<'_> {
                fn from(value: approveReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for approveReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for approveCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = approveReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "approve(address,uint256,uint256)";
            const SELECTOR: [u8; 4] = [66u8, 106u8, 132u8, 147u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.spender,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.id,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.amount,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `balanceOf(address,uint256)` and selector `0x00fdd58e`.
    ```solidity
    function balanceOf(address, uint256) external view returns (uint256);
    ```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct balanceOfCall {
        pub _0: alloy::sol_types::private::Address,
        pub _1: alloy::sol_types::private::U256,
    }
    ///Container type for the return parameters of the [`balanceOf(address,uint256)`](balanceOfCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct balanceOfReturn {
        pub _0: alloy::sol_types::private::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<balanceOfCall> for UnderlyingRustTuple<'_> {
                fn from(value: balanceOfCall) -> Self {
                    (value._0, value._1)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for balanceOfCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _0: tuple.0,
                        _1: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<balanceOfReturn> for UnderlyingRustTuple<'_> {
                fn from(value: balanceOfReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for balanceOfReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for balanceOfCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = balanceOfReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "balanceOf(address,uint256)";
            const SELECTOR: [u8; 4] = [0u8, 253u8, 213u8, 142u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._0,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self._1,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `burn(address,uint256,uint256)` and selector `0xf5298aca`.
    ```solidity
    function burn(address from, uint256 id, uint256 amount) external;
    ```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct burnCall {
        pub from: alloy::sol_types::private::Address,
        pub id: alloy::sol_types::private::U256,
        pub amount: alloy::sol_types::private::U256,
    }
    ///Container type for the return parameters of the [`burn(address,uint256,uint256)`](burnCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct burnReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::U256,
                alloy::sol_types::private::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<burnCall> for UnderlyingRustTuple<'_> {
                fn from(value: burnCall) -> Self {
                    (value.from, value.id, value.amount)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for burnCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        from: tuple.0,
                        id: tuple.1,
                        amount: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<burnReturn> for UnderlyingRustTuple<'_> {
                fn from(value: burnReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for burnReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for burnCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = burnReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "burn(address,uint256,uint256)";
            const SELECTOR: [u8; 4] = [245u8, 41u8, 138u8, 202u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.from,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.id,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.amount,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `collectProtocolFees(address,address,uint256)` and selector `0x8161b874`.
    ```solidity
    function collectProtocolFees(address recipient, Currency currency, uint256 amount) external returns (uint256 amountCollected);
    ```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct collectProtocolFeesCall {
        pub recipient: alloy::sol_types::private::Address,
        pub currency: <Currency as alloy::sol_types::SolType>::RustType,
        pub amount: alloy::sol_types::private::U256,
    }
    ///Container type for the return parameters of the [`collectProtocolFees(address,address,uint256)`](collectProtocolFeesCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct collectProtocolFeesReturn {
        pub amountCollected: alloy::sol_types::private::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                Currency,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                <Currency as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<collectProtocolFeesCall> for UnderlyingRustTuple<'_> {
                fn from(value: collectProtocolFeesCall) -> Self {
                    (value.recipient, value.currency, value.amount)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for collectProtocolFeesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        recipient: tuple.0,
                        currency: tuple.1,
                        amount: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<collectProtocolFeesReturn> for UnderlyingRustTuple<'_> {
                fn from(value: collectProtocolFeesReturn) -> Self {
                    (value.amountCollected,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for collectProtocolFeesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        amountCollected: tuple.0,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for collectProtocolFeesCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                Currency,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = collectProtocolFeesReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "collectProtocolFees(address,address,uint256)";
            const SELECTOR: [u8; 4] = [129u8, 97u8, 184u8, 116u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.recipient,
                    ),
                    <Currency as alloy_sol_types::SolType>::tokenize(&self.currency),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.amount,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `donate((address,address,uint24,int24,address),uint256,uint256,bytes)` and selector `0x234266d7`.
    ```solidity
    function donate(PoolKey memory key, uint256 amount0, uint256 amount1, bytes memory hookData) external returns (BalanceDelta delta);
    ```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct donateCall {
        pub key: <PoolKey as alloy::sol_types::SolType>::RustType,
        pub amount0: alloy::sol_types::private::U256,
        pub amount1: alloy::sol_types::private::U256,
        pub hookData: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`donate((address,address,uint24,int24,address),uint256,uint256,bytes)`](donateCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct donateReturn {
        pub delta: <BalanceDelta as alloy::sol_types::SolType>::RustType,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                PoolKey,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <PoolKey as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::U256,
                alloy::sol_types::private::U256,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<donateCall> for UnderlyingRustTuple<'_> {
                fn from(value: donateCall) -> Self {
                    (value.key, value.amount0, value.amount1, value.hookData)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for donateCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        key: tuple.0,
                        amount0: tuple.1,
                        amount1: tuple.2,
                        hookData: tuple.3,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (BalanceDelta,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (<BalanceDelta as alloy::sol_types::SolType>::RustType,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<donateReturn> for UnderlyingRustTuple<'_> {
                fn from(value: donateReturn) -> Self {
                    (value.delta,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for donateReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { delta: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for donateCall {
            type Parameters<'a> = (
                PoolKey,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = donateReturn;
            type ReturnTuple<'a> = (BalanceDelta,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str =
                "donate((address,address,uint24,int24,address),uint256,uint256,bytes)";
            const SELECTOR: [u8; 4] = [35u8, 66u8, 102u8, 215u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <PoolKey as alloy_sol_types::SolType>::tokenize(&self.key),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.amount0,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.amount1,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.hookData,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `extsload(bytes32)` and selector `0x1e2eaeaf`.
    ```solidity
    function extsload(bytes32 slot) external view returns (bytes32);
    ```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct extsload_0Call {
        pub slot: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`extsload(bytes32)`](extsload_0Call) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct extsload_0Return {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<extsload_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: extsload_0Call) -> Self {
                    (value.slot,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for extsload_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { slot: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<extsload_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: extsload_0Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for extsload_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for extsload_0Call {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = extsload_0Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "extsload(bytes32)";
            const SELECTOR: [u8; 4] = [30u8, 46u8, 174u8, 175u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.slot),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `extsload(bytes32,uint256)` and selector `0x35fd631a`.
    ```solidity
    function extsload(bytes32 startSlot, uint256 nSlots) external view returns (bytes memory);
    ```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct extsload_1Call {
        pub startSlot: alloy::sol_types::private::FixedBytes<32>,
        pub nSlots: alloy::sol_types::private::U256,
    }
    ///Container type for the return parameters of the [`extsload(bytes32,uint256)`](extsload_1Call) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct extsload_1Return {
        pub _0: alloy::sol_types::private::Bytes,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<extsload_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: extsload_1Call) -> Self {
                    (value.startSlot, value.nSlots)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for extsload_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        startSlot: tuple.0,
                        nSlots: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<extsload_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: extsload_1Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for extsload_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for extsload_1Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = extsload_1Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "extsload(bytes32,uint256)";
            const SELECTOR: [u8; 4] = [53u8, 253u8, 99u8, 26u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.startSlot),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nSlots),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `extsload(bytes32[])` and selector `0xdbd035ff`.
    ```solidity
    function extsload(bytes32[] memory slots) external view returns (bytes32[] memory);
    ```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct extsload_2Call {
        pub slots: alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
    }
    ///Container type for the return parameters of the [`extsload(bytes32[])`](extsload_2Call) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct extsload_2Return {
        pub _0: alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::FixedBytes<32>>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<extsload_2Call> for UnderlyingRustTuple<'_> {
                fn from(value: extsload_2Call) -> Self {
                    (value.slots,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for extsload_2Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { slots: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::FixedBytes<32>>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<extsload_2Return> for UnderlyingRustTuple<'_> {
                fn from(value: extsload_2Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for extsload_2Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for extsload_2Call {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::FixedBytes<32>>,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = extsload_2Return;
            type ReturnTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::FixedBytes<32>>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "extsload(bytes32[])";
            const SELECTOR: [u8; 4] = [219u8, 208u8, 53u8, 255u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                > as alloy_sol_types::SolType>::tokenize(
                    &self.slots
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `exttload(bytes32[])` and selector `0x9bf6645f`.
    ```solidity
    function exttload(bytes32[] memory slots) external view returns (bytes32[] memory);
    ```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct exttload_0Call {
        pub slots: alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
    }
    ///Container type for the return parameters of the [`exttload(bytes32[])`](exttload_0Call) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct exttload_0Return {
        pub _0: alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::FixedBytes<32>>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<exttload_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: exttload_0Call) -> Self {
                    (value.slots,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for exttload_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { slots: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::FixedBytes<32>>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<exttload_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: exttload_0Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for exttload_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for exttload_0Call {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::FixedBytes<32>>,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = exttload_0Return;
            type ReturnTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::FixedBytes<32>>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "exttload(bytes32[])";
            const SELECTOR: [u8; 4] = [155u8, 246u8, 100u8, 95u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                > as alloy_sol_types::SolType>::tokenize(
                    &self.slots
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `exttload(bytes32)` and selector `0xf135baaa`.
    ```solidity
    function exttload(bytes32 slot) external view returns (bytes32);
    ```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct exttload_1Call {
        pub slot: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`exttload(bytes32)`](exttload_1Call) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct exttload_1Return {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<exttload_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: exttload_1Call) -> Self {
                    (value.slot,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for exttload_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { slot: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<exttload_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: exttload_1Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for exttload_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for exttload_1Call {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = exttload_1Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "exttload(bytes32)";
            const SELECTOR: [u8; 4] = [241u8, 53u8, 186u8, 170u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.slot),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `initialize((address,address,uint24,int24,address),uint160,bytes)` and selector `0x695c5bf5`.
    ```solidity
    function initialize(PoolKey memory key, uint160 sqrtPriceX96, bytes memory hookData) external returns (int24 tick);
    ```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct initializeCall {
        pub key: <PoolKey as alloy::sol_types::SolType>::RustType,
        pub sqrtPriceX96:
            <alloy::sol_types::sol_data::Uint<160> as alloy::sol_types::SolType>::RustType,
        pub hookData: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`initialize((address,address,uint24,int24,address),uint160,bytes)`](initializeCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct initializeReturn {
        pub tick: <alloy::sol_types::sol_data::Int<24> as alloy::sol_types::SolType>::RustType,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                PoolKey,
                alloy::sol_types::sol_data::Uint<160>,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <PoolKey as alloy::sol_types::SolType>::RustType,
                <alloy::sol_types::sol_data::Uint<160> as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeCall> for UnderlyingRustTuple<'_> {
                fn from(value: initializeCall) -> Self {
                    (value.key, value.sqrtPriceX96, value.hookData)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for initializeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        key: tuple.0,
                        sqrtPriceX96: tuple.1,
                        hookData: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Int<24>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (<alloy::sol_types::sol_data::Int<24> as alloy::sol_types::SolType>::RustType,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: initializeReturn) -> Self {
                    (value.tick,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for initializeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { tick: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for initializeCall {
            type Parameters<'a> = (
                PoolKey,
                alloy::sol_types::sol_data::Uint<160>,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = initializeReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Int<24>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str =
                "initialize((address,address,uint24,int24,address),uint160,bytes)";
            const SELECTOR: [u8; 4] = [105u8, 92u8, 91u8, 245u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <PoolKey as alloy_sol_types::SolType>::tokenize(&self.key),
                    <alloy::sol_types::sol_data::Uint<160> as alloy_sol_types::SolType>::tokenize(
                        &self.sqrtPriceX96,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.hookData,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `isOperator(address,address)` and selector `0xb6363cf2`.
    ```solidity
    function isOperator(address, address) external view returns (bool);
    ```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct isOperatorCall {
        pub _0: alloy::sol_types::private::Address,
        pub _1: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`isOperator(address,address)`](isOperatorCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct isOperatorReturn {
        pub _0: bool,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isOperatorCall> for UnderlyingRustTuple<'_> {
                fn from(value: isOperatorCall) -> Self {
                    (value._0, value._1)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for isOperatorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _0: tuple.0,
                        _1: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isOperatorReturn> for UnderlyingRustTuple<'_> {
                fn from(value: isOperatorReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for isOperatorReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for isOperatorCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = isOperatorReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "isOperator(address,address)";
            const SELECTOR: [u8; 4] = [182u8, 54u8, 60u8, 242u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._0,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._1,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `mint(address,uint256,uint256)` and selector `0x156e29f6`.
    ```solidity
    function mint(address to, uint256 id, uint256 amount) external;
    ```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct mintCall {
        pub to: alloy::sol_types::private::Address,
        pub id: alloy::sol_types::private::U256,
        pub amount: alloy::sol_types::private::U256,
    }
    ///Container type for the return parameters of the [`mint(address,uint256,uint256)`](mintCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct mintReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::U256,
                alloy::sol_types::private::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<mintCall> for UnderlyingRustTuple<'_> {
                fn from(value: mintCall) -> Self {
                    (value.to, value.id, value.amount)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for mintCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        to: tuple.0,
                        id: tuple.1,
                        amount: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<mintReturn> for UnderlyingRustTuple<'_> {
                fn from(value: mintReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for mintReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for mintCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = mintReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "mint(address,uint256,uint256)";
            const SELECTOR: [u8; 4] = [21u8, 110u8, 41u8, 246u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.id,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.amount,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `modifyLiquidity((address,address,uint24,int24,address),(int24,int24,int256,bytes32),bytes)` and selector `0x5a6bcfda`.
    ```solidity
    function modifyLiquidity(PoolKey memory key, ModifyLiquidityParams memory params, bytes memory hookData) external returns (BalanceDelta callerDelta, BalanceDelta feesAccrued);
    ```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct modifyLiquidityCall {
        pub key: <PoolKey as alloy::sol_types::SolType>::RustType,
        pub params: <ModifyLiquidityParams as alloy::sol_types::SolType>::RustType,
        pub hookData: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`modifyLiquidity((address,address,uint24,int24,address),(int24,int24,int256,bytes32),bytes)`](modifyLiquidityCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct modifyLiquidityReturn {
        pub callerDelta: <BalanceDelta as alloy::sol_types::SolType>::RustType,
        pub feesAccrued: <BalanceDelta as alloy::sol_types::SolType>::RustType,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                PoolKey,
                ModifyLiquidityParams,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <PoolKey as alloy::sol_types::SolType>::RustType,
                <ModifyLiquidityParams as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<modifyLiquidityCall> for UnderlyingRustTuple<'_> {
                fn from(value: modifyLiquidityCall) -> Self {
                    (value.key, value.params, value.hookData)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for modifyLiquidityCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        key: tuple.0,
                        params: tuple.1,
                        hookData: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (BalanceDelta, BalanceDelta);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <BalanceDelta as alloy::sol_types::SolType>::RustType,
                <BalanceDelta as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<modifyLiquidityReturn> for UnderlyingRustTuple<'_> {
                fn from(value: modifyLiquidityReturn) -> Self {
                    (value.callerDelta, value.feesAccrued)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for modifyLiquidityReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        callerDelta: tuple.0,
                        feesAccrued: tuple.1,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for modifyLiquidityCall {
            type Parameters<'a> = (
                PoolKey,
                ModifyLiquidityParams,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = modifyLiquidityReturn;
            type ReturnTuple<'a> = (BalanceDelta, BalanceDelta);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "modifyLiquidity((address,address,uint24,int24,address),(int24,int24,int256,bytes32),bytes)";
            const SELECTOR: [u8; 4] = [90u8, 107u8, 207u8, 218u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <PoolKey as alloy_sol_types::SolType>::tokenize(&self.key),
                    <ModifyLiquidityParams as alloy_sol_types::SolType>::tokenize(&self.params),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.hookData,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `owner()` and selector `0x8da5cb5b`.
    ```solidity
    function owner() external view returns (address);
    ```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct ownerCall {}
    ///Container type for the return parameters of the [`owner()`](ownerCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct ownerReturn {
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownerCall> for UnderlyingRustTuple<'_> {
                fn from(value: ownerCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownerReturn> for UnderlyingRustTuple<'_> {
                fn from(value: ownerReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for ownerCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = ownerReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "owner()";
            const SELECTOR: [u8; 4] = [141u8, 165u8, 203u8, 91u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `protocolFeeController()` and selector `0xf02de3b2`.
    ```solidity
    function protocolFeeController() external view returns (address);
    ```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct protocolFeeControllerCall {}
    ///Container type for the return parameters of the [`protocolFeeController()`](protocolFeeControllerCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct protocolFeeControllerReturn {
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<protocolFeeControllerCall> for UnderlyingRustTuple<'_> {
                fn from(value: protocolFeeControllerCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for protocolFeeControllerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<protocolFeeControllerReturn> for UnderlyingRustTuple<'_> {
                fn from(value: protocolFeeControllerReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for protocolFeeControllerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for protocolFeeControllerCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = protocolFeeControllerReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "protocolFeeController()";
            const SELECTOR: [u8; 4] = [240u8, 45u8, 227u8, 178u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `protocolFeesAccrued(address)` and selector `0x97e8cd4e`.
    ```solidity
    function protocolFeesAccrued(Currency currency) external view returns (uint256);
    ```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct protocolFeesAccruedCall {
        pub currency: <Currency as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`protocolFeesAccrued(address)`](protocolFeesAccruedCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct protocolFeesAccruedReturn {
        pub _0: alloy::sol_types::private::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (Currency,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (<Currency as alloy::sol_types::SolType>::RustType,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<protocolFeesAccruedCall> for UnderlyingRustTuple<'_> {
                fn from(value: protocolFeesAccruedCall) -> Self {
                    (value.currency,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for protocolFeesAccruedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { currency: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<protocolFeesAccruedReturn> for UnderlyingRustTuple<'_> {
                fn from(value: protocolFeesAccruedReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for protocolFeesAccruedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for protocolFeesAccruedCall {
            type Parameters<'a> = (Currency,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = protocolFeesAccruedReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "protocolFeesAccrued(address)";
            const SELECTOR: [u8; 4] = [151u8, 232u8, 205u8, 78u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<Currency as alloy_sol_types::SolType>::tokenize(
                    &self.currency,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `setOperator(address,bool)` and selector `0x558a7297`.
    ```solidity
    function setOperator(address operator, bool approved) external returns (bool);
    ```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct setOperatorCall {
        pub operator: alloy::sol_types::private::Address,
        pub approved: bool,
    }
    ///Container type for the return parameters of the [`setOperator(address,bool)`](setOperatorCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct setOperatorReturn {
        pub _0: bool,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bool,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address, bool);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setOperatorCall> for UnderlyingRustTuple<'_> {
                fn from(value: setOperatorCall) -> Self {
                    (value.operator, value.approved)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setOperatorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        operator: tuple.0,
                        approved: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setOperatorReturn> for UnderlyingRustTuple<'_> {
                fn from(value: setOperatorReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setOperatorReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setOperatorCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bool,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = setOperatorReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setOperator(address,bool)";
            const SELECTOR: [u8; 4] = [85u8, 138u8, 114u8, 151u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.approved,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `setProtocolFee((address,address,uint24,int24,address),uint24)` and selector `0x7e87ce7d`.
    ```solidity
    function setProtocolFee(PoolKey memory key, uint24 newProtocolFee) external;
    ```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct setProtocolFeeCall {
        pub key: <PoolKey as alloy::sol_types::SolType>::RustType,
        pub newProtocolFee:
            <alloy::sol_types::sol_data::Uint<24> as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`setProtocolFee((address,address,uint24,int24,address),uint24)`](setProtocolFeeCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct setProtocolFeeReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (PoolKey, alloy::sol_types::sol_data::Uint<24>);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <PoolKey as alloy::sol_types::SolType>::RustType,
                <alloy::sol_types::sol_data::Uint<24> as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setProtocolFeeCall> for UnderlyingRustTuple<'_> {
                fn from(value: setProtocolFeeCall) -> Self {
                    (value.key, value.newProtocolFee)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setProtocolFeeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        key: tuple.0,
                        newProtocolFee: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setProtocolFeeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: setProtocolFeeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setProtocolFeeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setProtocolFeeCall {
            type Parameters<'a> = (PoolKey, alloy::sol_types::sol_data::Uint<24>);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = setProtocolFeeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str =
                "setProtocolFee((address,address,uint24,int24,address),uint24)";
            const SELECTOR: [u8; 4] = [126u8, 135u8, 206u8, 125u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <PoolKey as alloy_sol_types::SolType>::tokenize(&self.key),
                    <alloy::sol_types::sol_data::Uint<24> as alloy_sol_types::SolType>::tokenize(
                        &self.newProtocolFee,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `setProtocolFeeController(address)` and selector `0x2d771389`.
    ```solidity
    function setProtocolFeeController(address controller) external;
    ```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct setProtocolFeeControllerCall {
        pub controller: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`setProtocolFeeController(address)`](setProtocolFeeControllerCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct setProtocolFeeControllerReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setProtocolFeeControllerCall> for UnderlyingRustTuple<'_> {
                fn from(value: setProtocolFeeControllerCall) -> Self {
                    (value.controller,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setProtocolFeeControllerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        controller: tuple.0,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setProtocolFeeControllerReturn> for UnderlyingRustTuple<'_> {
                fn from(value: setProtocolFeeControllerReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setProtocolFeeControllerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setProtocolFeeControllerCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = setProtocolFeeControllerReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setProtocolFeeController(address)";
            const SELECTOR: [u8; 4] = [45u8, 119u8, 19u8, 137u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.controller,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `settle(address)` and selector `0x6a256b29`.
    ```solidity
    function settle(Currency currency) external payable returns (uint256 paid);
    ```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct settleCall {
        pub currency: <Currency as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`settle(address)`](settleCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct settleReturn {
        pub paid: alloy::sol_types::private::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (Currency,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (<Currency as alloy::sol_types::SolType>::RustType,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<settleCall> for UnderlyingRustTuple<'_> {
                fn from(value: settleCall) -> Self {
                    (value.currency,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for settleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { currency: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<settleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: settleReturn) -> Self {
                    (value.paid,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for settleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { paid: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for settleCall {
            type Parameters<'a> = (Currency,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = settleReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "settle(address)";
            const SELECTOR: [u8; 4] = [106u8, 37u8, 107u8, 41u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<Currency as alloy_sol_types::SolType>::tokenize(
                    &self.currency,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `supportsInterface(bytes4)` and selector `0x01ffc9a7`.
    ```solidity
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
    ```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct supportsInterfaceCall {
        pub interfaceId: alloy::sol_types::private::FixedBytes<4>,
    }
    ///Container type for the return parameters of the [`supportsInterface(bytes4)`](supportsInterfaceCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct supportsInterfaceReturn {
        pub _0: bool,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<4>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<supportsInterfaceCall> for UnderlyingRustTuple<'_> {
                fn from(value: supportsInterfaceCall) -> Self {
                    (value.interfaceId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for supportsInterfaceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        interfaceId: tuple.0,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<supportsInterfaceReturn> for UnderlyingRustTuple<'_> {
                fn from(value: supportsInterfaceReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for supportsInterfaceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for supportsInterfaceCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = supportsInterfaceReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "supportsInterface(bytes4)";
            const SELECTOR: [u8; 4] = [1u8, 255u8, 201u8, 167u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        4,
                    > as alloy_sol_types::SolType>::tokenize(&self.interfaceId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `swap((address,address,uint24,int24,address),(bool,int256,uint160),bytes)` and selector `0xf3cd914c`.
    ```solidity
    function swap(PoolKey memory key, SwapParams memory params, bytes memory hookData) external returns (BalanceDelta swapDelta);
    ```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct swapCall {
        pub key: <PoolKey as alloy::sol_types::SolType>::RustType,
        pub params: <SwapParams as alloy::sol_types::SolType>::RustType,
        pub hookData: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`swap((address,address,uint24,int24,address),(bool,int256,uint160),bytes)`](swapCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct swapReturn {
        pub swapDelta: <BalanceDelta as alloy::sol_types::SolType>::RustType,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (PoolKey, SwapParams, alloy::sol_types::sol_data::Bytes);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <PoolKey as alloy::sol_types::SolType>::RustType,
                <SwapParams as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<swapCall> for UnderlyingRustTuple<'_> {
                fn from(value: swapCall) -> Self {
                    (value.key, value.params, value.hookData)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for swapCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        key: tuple.0,
                        params: tuple.1,
                        hookData: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (BalanceDelta,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (<BalanceDelta as alloy::sol_types::SolType>::RustType,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<swapReturn> for UnderlyingRustTuple<'_> {
                fn from(value: swapReturn) -> Self {
                    (value.swapDelta,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for swapReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { swapDelta: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for swapCall {
            type Parameters<'a> = (PoolKey, SwapParams, alloy::sol_types::sol_data::Bytes);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = swapReturn;
            type ReturnTuple<'a> = (BalanceDelta,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str =
                "swap((address,address,uint24,int24,address),(bool,int256,uint160),bytes)";
            const SELECTOR: [u8; 4] = [243u8, 205u8, 145u8, 76u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <PoolKey as alloy_sol_types::SolType>::tokenize(&self.key),
                    <SwapParams as alloy_sol_types::SolType>::tokenize(&self.params),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.hookData,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `sync(address)` and selector `0xa5841194`.
    ```solidity
    function sync(Currency currency) external returns (uint256 balance);
    ```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct syncCall {
        pub currency: <Currency as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`sync(address)`](syncCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct syncReturn {
        pub balance: alloy::sol_types::private::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (Currency,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (<Currency as alloy::sol_types::SolType>::RustType,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<syncCall> for UnderlyingRustTuple<'_> {
                fn from(value: syncCall) -> Self {
                    (value.currency,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for syncCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { currency: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<syncReturn> for UnderlyingRustTuple<'_> {
                fn from(value: syncReturn) -> Self {
                    (value.balance,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for syncReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { balance: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for syncCall {
            type Parameters<'a> = (Currency,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = syncReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "sync(address)";
            const SELECTOR: [u8; 4] = [165u8, 132u8, 17u8, 148u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<Currency as alloy_sol_types::SolType>::tokenize(
                    &self.currency,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `take(address,address,uint256)` and selector `0x0b0d9c09`.
    ```solidity
    function take(Currency currency, address to, uint256 amount) external;
    ```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct takeCall {
        pub currency: <Currency as alloy::sol_types::SolType>::RustType,
        pub to: alloy::sol_types::private::Address,
        pub amount: alloy::sol_types::private::U256,
    }
    ///Container type for the return parameters of the [`take(address,address,uint256)`](takeCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct takeReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                Currency,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <Currency as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<takeCall> for UnderlyingRustTuple<'_> {
                fn from(value: takeCall) -> Self {
                    (value.currency, value.to, value.amount)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for takeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        currency: tuple.0,
                        to: tuple.1,
                        amount: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<takeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: takeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for takeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for takeCall {
            type Parameters<'a> = (
                Currency,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = takeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "take(address,address,uint256)";
            const SELECTOR: [u8; 4] = [11u8, 13u8, 156u8, 9u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <Currency as alloy_sol_types::SolType>::tokenize(&self.currency),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.amount,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `transfer(address,uint256,uint256)` and selector `0x095bcdb6`.
    ```solidity
    function transfer(address receiver, uint256 id, uint256 amount) external returns (bool);
    ```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct transferCall {
        pub receiver: alloy::sol_types::private::Address,
        pub id: alloy::sol_types::private::U256,
        pub amount: alloy::sol_types::private::U256,
    }
    ///Container type for the return parameters of the [`transfer(address,uint256,uint256)`](transferCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct transferReturn {
        pub _0: bool,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::U256,
                alloy::sol_types::private::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferCall> for UnderlyingRustTuple<'_> {
                fn from(value: transferCall) -> Self {
                    (value.receiver, value.id, value.amount)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for transferCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        receiver: tuple.0,
                        id: tuple.1,
                        amount: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferReturn> for UnderlyingRustTuple<'_> {
                fn from(value: transferReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for transferReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for transferCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = transferReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "transfer(address,uint256,uint256)";
            const SELECTOR: [u8; 4] = [9u8, 91u8, 205u8, 182u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.receiver,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.id,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.amount,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `transferFrom(address,address,uint256,uint256)` and selector `0xfe99049a`.
    ```solidity
    function transferFrom(address sender, address receiver, uint256 id, uint256 amount) external returns (bool);
    ```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct transferFromCall {
        pub sender: alloy::sol_types::private::Address,
        pub receiver: alloy::sol_types::private::Address,
        pub id: alloy::sol_types::private::U256,
        pub amount: alloy::sol_types::private::U256,
    }
    ///Container type for the return parameters of the [`transferFrom(address,address,uint256,uint256)`](transferFromCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct transferFromReturn {
        pub _0: bool,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::U256,
                alloy::sol_types::private::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferFromCall> for UnderlyingRustTuple<'_> {
                fn from(value: transferFromCall) -> Self {
                    (value.sender, value.receiver, value.id, value.amount)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for transferFromCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        sender: tuple.0,
                        receiver: tuple.1,
                        id: tuple.2,
                        amount: tuple.3,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferFromReturn> for UnderlyingRustTuple<'_> {
                fn from(value: transferFromReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for transferFromReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for transferFromCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = transferFromReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "transferFrom(address,address,uint256,uint256)";
            const SELECTOR: [u8; 4] = [254u8, 153u8, 4u8, 154u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sender,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.receiver,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.id,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.amount,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `transferOwnership(address)` and selector `0xf2fde38b`.
    ```solidity
    function transferOwnership(address newOwner) external;
    ```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct transferOwnershipCall {
        pub newOwner: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`transferOwnership(address)`](transferOwnershipCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct transferOwnershipReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferOwnershipCall> for UnderlyingRustTuple<'_> {
                fn from(value: transferOwnershipCall) -> Self {
                    (value.newOwner,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for transferOwnershipCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { newOwner: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferOwnershipReturn> for UnderlyingRustTuple<'_> {
                fn from(value: transferOwnershipReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for transferOwnershipReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for transferOwnershipCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = transferOwnershipReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "transferOwnership(address)";
            const SELECTOR: [u8; 4] = [242u8, 253u8, 227u8, 139u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newOwner,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `unlock(bytes)` and selector `0x48c89491`.
    ```solidity
    function unlock(bytes memory data) external returns (bytes memory result);
    ```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct unlockCall {
        pub data: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`unlock(bytes)`](unlockCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct unlockReturn {
        pub result: alloy::sol_types::private::Bytes,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<unlockCall> for UnderlyingRustTuple<'_> {
                fn from(value: unlockCall) -> Self {
                    (value.data,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for unlockCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { data: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<unlockReturn> for UnderlyingRustTuple<'_> {
                fn from(value: unlockReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for unlockReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for unlockCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Bytes,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = unlockReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "unlock(bytes)";
            const SELECTOR: [u8; 4] = [72u8, 200u8, 148u8, 145u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.data,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `updateDynamicLPFee((address,address,uint24,int24,address),uint24)` and selector `0x52759651`.
    ```solidity
    function updateDynamicLPFee(PoolKey memory key, uint24 newDynamicLPFee) external;
    ```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct updateDynamicLPFeeCall {
        pub key: <PoolKey as alloy::sol_types::SolType>::RustType,
        pub newDynamicLPFee:
            <alloy::sol_types::sol_data::Uint<24> as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`updateDynamicLPFee((address,address,uint24,int24,address),uint24)`](updateDynamicLPFeeCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct updateDynamicLPFeeReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (PoolKey, alloy::sol_types::sol_data::Uint<24>);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <PoolKey as alloy::sol_types::SolType>::RustType,
                <alloy::sol_types::sol_data::Uint<24> as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateDynamicLPFeeCall> for UnderlyingRustTuple<'_> {
                fn from(value: updateDynamicLPFeeCall) -> Self {
                    (value.key, value.newDynamicLPFee)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for updateDynamicLPFeeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        key: tuple.0,
                        newDynamicLPFee: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateDynamicLPFeeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: updateDynamicLPFeeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for updateDynamicLPFeeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for updateDynamicLPFeeCall {
            type Parameters<'a> = (PoolKey, alloy::sol_types::sol_data::Uint<24>);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = updateDynamicLPFeeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str =
                "updateDynamicLPFee((address,address,uint24,int24,address),uint24)";
            const SELECTOR: [u8; 4] = [82u8, 117u8, 150u8, 81u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <PoolKey as alloy_sol_types::SolType>::tokenize(&self.key),
                    <alloy::sol_types::sol_data::Uint<24> as alloy_sol_types::SolType>::tokenize(
                        &self.newDynamicLPFee,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    ///Container for all the [`PoolManager`](self) function calls.
    pub enum PoolManagerCalls {
        MAX_TICK_SPACING(MAX_TICK_SPACINGCall),
        MIN_TICK_SPACING(MIN_TICK_SPACINGCall),
        allowance(allowanceCall),
        approve(approveCall),
        balanceOf(balanceOfCall),
        burn(burnCall),
        collectProtocolFees(collectProtocolFeesCall),
        donate(donateCall),
        extsload_0(extsload_0Call),
        extsload_1(extsload_1Call),
        extsload_2(extsload_2Call),
        exttload_0(exttload_0Call),
        exttload_1(exttload_1Call),
        initialize(initializeCall),
        isOperator(isOperatorCall),
        mint(mintCall),
        modifyLiquidity(modifyLiquidityCall),
        owner(ownerCall),
        protocolFeeController(protocolFeeControllerCall),
        protocolFeesAccrued(protocolFeesAccruedCall),
        setOperator(setOperatorCall),
        setProtocolFee(setProtocolFeeCall),
        setProtocolFeeController(setProtocolFeeControllerCall),
        settle(settleCall),
        supportsInterface(supportsInterfaceCall),
        swap(swapCall),
        sync(syncCall),
        take(takeCall),
        transfer(transferCall),
        transferFrom(transferFromCall),
        transferOwnership(transferOwnershipCall),
        unlock(unlockCall),
        updateDynamicLPFee(updateDynamicLPFeeCall),
    }
    #[automatically_derived]
    impl PoolManagerCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [0u8, 253u8, 213u8, 142u8],
            [1u8, 255u8, 201u8, 167u8],
            [7u8, 239u8, 240u8, 221u8],
            [9u8, 91u8, 205u8, 182u8],
            [11u8, 13u8, 156u8, 9u8],
            [21u8, 110u8, 41u8, 246u8],
            [30u8, 46u8, 174u8, 175u8],
            [35u8, 66u8, 102u8, 215u8],
            [45u8, 119u8, 19u8, 137u8],
            [53u8, 253u8, 99u8, 26u8],
            [66u8, 106u8, 132u8, 147u8],
            [72u8, 200u8, 148u8, 145u8],
            [82u8, 117u8, 150u8, 81u8],
            [85u8, 138u8, 114u8, 151u8],
            [89u8, 138u8, 249u8, 231u8],
            [90u8, 107u8, 207u8, 218u8],
            [96u8, 70u8, 15u8, 6u8],
            [105u8, 92u8, 91u8, 245u8],
            [106u8, 37u8, 107u8, 41u8],
            [126u8, 135u8, 206u8, 125u8],
            [129u8, 97u8, 184u8, 116u8],
            [141u8, 165u8, 203u8, 91u8],
            [151u8, 232u8, 205u8, 78u8],
            [155u8, 246u8, 100u8, 95u8],
            [165u8, 132u8, 17u8, 148u8],
            [182u8, 54u8, 60u8, 242u8],
            [219u8, 208u8, 53u8, 255u8],
            [240u8, 45u8, 227u8, 178u8],
            [241u8, 53u8, 186u8, 170u8],
            [242u8, 253u8, 227u8, 139u8],
            [243u8, 205u8, 145u8, 76u8],
            [245u8, 41u8, 138u8, 202u8],
            [254u8, 153u8, 4u8, 154u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for PoolManagerCalls {
        const NAME: &'static str = "PoolManagerCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 33usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::MAX_TICK_SPACING(_) => {
                    <MAX_TICK_SPACINGCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::MIN_TICK_SPACING(_) => {
                    <MIN_TICK_SPACINGCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::allowance(_) => <allowanceCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::approve(_) => <approveCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::balanceOf(_) => <balanceOfCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::burn(_) => <burnCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::collectProtocolFees(_) => {
                    <collectProtocolFeesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::donate(_) => <donateCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::extsload_0(_) => <extsload_0Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::extsload_1(_) => <extsload_1Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::extsload_2(_) => <extsload_2Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::exttload_0(_) => <exttload_0Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::exttload_1(_) => <exttload_1Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::initialize(_) => <initializeCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::isOperator(_) => <isOperatorCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::mint(_) => <mintCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::modifyLiquidity(_) => {
                    <modifyLiquidityCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::owner(_) => <ownerCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::protocolFeeController(_) => {
                    <protocolFeeControllerCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::protocolFeesAccrued(_) => {
                    <protocolFeesAccruedCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setOperator(_) => <setOperatorCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::setProtocolFee(_) => {
                    <setProtocolFeeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setProtocolFeeController(_) => {
                    <setProtocolFeeControllerCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::settle(_) => <settleCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::supportsInterface(_) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::swap(_) => <swapCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::sync(_) => <syncCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::take(_) => <takeCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::transfer(_) => <transferCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::transferFrom(_) => <transferFromCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::transferOwnership(_) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::unlock(_) => <unlockCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::updateDynamicLPFee(_) => {
                    <updateDynamicLPFeeCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(unsafe_code, non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(&[u8], bool) -> alloy_sol_types::Result<PoolManagerCalls>] =
                &[
                    {
                        fn balanceOf(
                            data: &[u8],
                            validate: bool,
                        ) -> alloy_sol_types::Result<PoolManagerCalls> {
                            <balanceOfCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data, validate,
                            )
                            .map(PoolManagerCalls::balanceOf)
                        }
                        balanceOf
                    },
                    {
                        fn supportsInterface(
                            data: &[u8],
                            validate: bool,
                        ) -> alloy_sol_types::Result<PoolManagerCalls> {
                            <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data, validate,
                            )
                            .map(PoolManagerCalls::supportsInterface)
                        }
                        supportsInterface
                    },
                    {
                        fn MIN_TICK_SPACING(
                            data: &[u8],
                            validate: bool,
                        ) -> alloy_sol_types::Result<PoolManagerCalls> {
                            <MIN_TICK_SPACINGCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data, validate,
                            )
                            .map(PoolManagerCalls::MIN_TICK_SPACING)
                        }
                        MIN_TICK_SPACING
                    },
                    {
                        fn transfer(
                            data: &[u8],
                            validate: bool,
                        ) -> alloy_sol_types::Result<PoolManagerCalls> {
                            <transferCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data, validate,
                            )
                            .map(PoolManagerCalls::transfer)
                        }
                        transfer
                    },
                    {
                        fn take(
                            data: &[u8],
                            validate: bool,
                        ) -> alloy_sol_types::Result<PoolManagerCalls> {
                            <takeCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                                .map(PoolManagerCalls::take)
                        }
                        take
                    },
                    {
                        fn mint(
                            data: &[u8],
                            validate: bool,
                        ) -> alloy_sol_types::Result<PoolManagerCalls> {
                            <mintCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                                .map(PoolManagerCalls::mint)
                        }
                        mint
                    },
                    {
                        fn extsload_0(
                            data: &[u8],
                            validate: bool,
                        ) -> alloy_sol_types::Result<PoolManagerCalls> {
                            <extsload_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data, validate,
                            )
                            .map(PoolManagerCalls::extsload_0)
                        }
                        extsload_0
                    },
                    {
                        fn donate(
                            data: &[u8],
                            validate: bool,
                        ) -> alloy_sol_types::Result<PoolManagerCalls> {
                            <donateCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                                .map(PoolManagerCalls::donate)
                        }
                        donate
                    },
                    {
                        fn setProtocolFeeController(
                            data: &[u8],
                            validate: bool,
                        ) -> alloy_sol_types::Result<PoolManagerCalls> {
                            <setProtocolFeeControllerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(PoolManagerCalls::setProtocolFeeController)
                        }
                        setProtocolFeeController
                    },
                    {
                        fn extsload_1(
                            data: &[u8],
                            validate: bool,
                        ) -> alloy_sol_types::Result<PoolManagerCalls> {
                            <extsload_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data, validate,
                            )
                            .map(PoolManagerCalls::extsload_1)
                        }
                        extsload_1
                    },
                    {
                        fn approve(
                            data: &[u8],
                            validate: bool,
                        ) -> alloy_sol_types::Result<PoolManagerCalls> {
                            <approveCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data, validate,
                            )
                            .map(PoolManagerCalls::approve)
                        }
                        approve
                    },
                    {
                        fn unlock(
                            data: &[u8],
                            validate: bool,
                        ) -> alloy_sol_types::Result<PoolManagerCalls> {
                            <unlockCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                                .map(PoolManagerCalls::unlock)
                        }
                        unlock
                    },
                    {
                        fn updateDynamicLPFee(
                            data: &[u8],
                            validate: bool,
                        ) -> alloy_sol_types::Result<PoolManagerCalls> {
                            <updateDynamicLPFeeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data, validate,
                            )
                            .map(PoolManagerCalls::updateDynamicLPFee)
                        }
                        updateDynamicLPFee
                    },
                    {
                        fn setOperator(
                            data: &[u8],
                            validate: bool,
                        ) -> alloy_sol_types::Result<PoolManagerCalls> {
                            <setOperatorCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data, validate,
                            )
                            .map(PoolManagerCalls::setOperator)
                        }
                        setOperator
                    },
                    {
                        fn allowance(
                            data: &[u8],
                            validate: bool,
                        ) -> alloy_sol_types::Result<PoolManagerCalls> {
                            <allowanceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data, validate,
                            )
                            .map(PoolManagerCalls::allowance)
                        }
                        allowance
                    },
                    {
                        fn modifyLiquidity(
                            data: &[u8],
                            validate: bool,
                        ) -> alloy_sol_types::Result<PoolManagerCalls> {
                            <modifyLiquidityCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data, validate,
                            )
                            .map(PoolManagerCalls::modifyLiquidity)
                        }
                        modifyLiquidity
                    },
                    {
                        fn MAX_TICK_SPACING(
                            data: &[u8],
                            validate: bool,
                        ) -> alloy_sol_types::Result<PoolManagerCalls> {
                            <MAX_TICK_SPACINGCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data, validate,
                            )
                            .map(PoolManagerCalls::MAX_TICK_SPACING)
                        }
                        MAX_TICK_SPACING
                    },
                    {
                        fn initialize(
                            data: &[u8],
                            validate: bool,
                        ) -> alloy_sol_types::Result<PoolManagerCalls> {
                            <initializeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data, validate,
                            )
                            .map(PoolManagerCalls::initialize)
                        }
                        initialize
                    },
                    {
                        fn settle(
                            data: &[u8],
                            validate: bool,
                        ) -> alloy_sol_types::Result<PoolManagerCalls> {
                            <settleCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                                .map(PoolManagerCalls::settle)
                        }
                        settle
                    },
                    {
                        fn setProtocolFee(
                            data: &[u8],
                            validate: bool,
                        ) -> alloy_sol_types::Result<PoolManagerCalls> {
                            <setProtocolFeeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data, validate,
                            )
                            .map(PoolManagerCalls::setProtocolFee)
                        }
                        setProtocolFee
                    },
                    {
                        fn collectProtocolFees(
                            data: &[u8],
                            validate: bool,
                        ) -> alloy_sol_types::Result<PoolManagerCalls> {
                            <collectProtocolFeesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data, validate,
                            )
                            .map(PoolManagerCalls::collectProtocolFees)
                        }
                        collectProtocolFees
                    },
                    {
                        fn owner(
                            data: &[u8],
                            validate: bool,
                        ) -> alloy_sol_types::Result<PoolManagerCalls> {
                            <ownerCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                                .map(PoolManagerCalls::owner)
                        }
                        owner
                    },
                    {
                        fn protocolFeesAccrued(
                            data: &[u8],
                            validate: bool,
                        ) -> alloy_sol_types::Result<PoolManagerCalls> {
                            <protocolFeesAccruedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data, validate,
                            )
                            .map(PoolManagerCalls::protocolFeesAccrued)
                        }
                        protocolFeesAccrued
                    },
                    {
                        fn exttload_0(
                            data: &[u8],
                            validate: bool,
                        ) -> alloy_sol_types::Result<PoolManagerCalls> {
                            <exttload_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data, validate,
                            )
                            .map(PoolManagerCalls::exttload_0)
                        }
                        exttload_0
                    },
                    {
                        fn sync(
                            data: &[u8],
                            validate: bool,
                        ) -> alloy_sol_types::Result<PoolManagerCalls> {
                            <syncCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                                .map(PoolManagerCalls::sync)
                        }
                        sync
                    },
                    {
                        fn isOperator(
                            data: &[u8],
                            validate: bool,
                        ) -> alloy_sol_types::Result<PoolManagerCalls> {
                            <isOperatorCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data, validate,
                            )
                            .map(PoolManagerCalls::isOperator)
                        }
                        isOperator
                    },
                    {
                        fn extsload_2(
                            data: &[u8],
                            validate: bool,
                        ) -> alloy_sol_types::Result<PoolManagerCalls> {
                            <extsload_2Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data, validate,
                            )
                            .map(PoolManagerCalls::extsload_2)
                        }
                        extsload_2
                    },
                    {
                        fn protocolFeeController(
                            data: &[u8],
                            validate: bool,
                        ) -> alloy_sol_types::Result<PoolManagerCalls> {
                            <protocolFeeControllerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data, validate,
                            )
                            .map(PoolManagerCalls::protocolFeeController)
                        }
                        protocolFeeController
                    },
                    {
                        fn exttload_1(
                            data: &[u8],
                            validate: bool,
                        ) -> alloy_sol_types::Result<PoolManagerCalls> {
                            <exttload_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data, validate,
                            )
                            .map(PoolManagerCalls::exttload_1)
                        }
                        exttload_1
                    },
                    {
                        fn transferOwnership(
                            data: &[u8],
                            validate: bool,
                        ) -> alloy_sol_types::Result<PoolManagerCalls> {
                            <transferOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data, validate,
                            )
                            .map(PoolManagerCalls::transferOwnership)
                        }
                        transferOwnership
                    },
                    {
                        fn swap(
                            data: &[u8],
                            validate: bool,
                        ) -> alloy_sol_types::Result<PoolManagerCalls> {
                            <swapCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                                .map(PoolManagerCalls::swap)
                        }
                        swap
                    },
                    {
                        fn burn(
                            data: &[u8],
                            validate: bool,
                        ) -> alloy_sol_types::Result<PoolManagerCalls> {
                            <burnCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                                .map(PoolManagerCalls::burn)
                        }
                        burn
                    },
                    {
                        fn transferFrom(
                            data: &[u8],
                            validate: bool,
                        ) -> alloy_sol_types::Result<PoolManagerCalls> {
                            <transferFromCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data, validate,
                            )
                            .map(PoolManagerCalls::transferFrom)
                        }
                        transferFrom
                    },
                ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(alloy_sol_types::Error::unknown_selector(
                    <Self as alloy_sol_types::SolInterface>::NAME,
                    selector,
                ));
            };
            (unsafe { DECODE_SHIMS.get_unchecked(idx) })(data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::MAX_TICK_SPACING(inner) => {
                    <MAX_TICK_SPACINGCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::MIN_TICK_SPACING(inner) => {
                    <MIN_TICK_SPACINGCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::allowance(inner) => {
                    <allowanceCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::approve(inner) => {
                    <approveCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::balanceOf(inner) => {
                    <balanceOfCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::burn(inner) => {
                    <burnCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::collectProtocolFees(inner) => {
                    <collectProtocolFeesCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::donate(inner) => {
                    <donateCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::extsload_0(inner) => {
                    <extsload_0Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::extsload_1(inner) => {
                    <extsload_1Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::extsload_2(inner) => {
                    <extsload_2Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::exttload_0(inner) => {
                    <exttload_0Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::exttload_1(inner) => {
                    <exttload_1Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::initialize(inner) => {
                    <initializeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::isOperator(inner) => {
                    <isOperatorCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::mint(inner) => {
                    <mintCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::modifyLiquidity(inner) => {
                    <modifyLiquidityCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::owner(inner) => {
                    <ownerCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::protocolFeeController(inner) => {
                    <protocolFeeControllerCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::protocolFeesAccrued(inner) => {
                    <protocolFeesAccruedCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::setOperator(inner) => {
                    <setOperatorCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::setProtocolFee(inner) => {
                    <setProtocolFeeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::setProtocolFeeController(inner) => {
                    <setProtocolFeeControllerCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::settle(inner) => {
                    <settleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::supportsInterface(inner) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::swap(inner) => {
                    <swapCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::sync(inner) => {
                    <syncCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::take(inner) => {
                    <takeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::transfer(inner) => {
                    <transferCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::transferFrom(inner) => {
                    <transferFromCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::transferOwnership(inner) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::unlock(inner) => {
                    <unlockCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::updateDynamicLPFee(inner) => {
                    <updateDynamicLPFeeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::MAX_TICK_SPACING(inner) => {
                    <MAX_TICK_SPACINGCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::MIN_TICK_SPACING(inner) => {
                    <MIN_TICK_SPACINGCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::allowance(inner) => {
                    <allowanceCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::approve(inner) => {
                    <approveCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::balanceOf(inner) => {
                    <balanceOfCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::burn(inner) => {
                    <burnCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::collectProtocolFees(inner) => {
                    <collectProtocolFeesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner, out,
                    )
                }
                Self::donate(inner) => {
                    <donateCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::extsload_0(inner) => {
                    <extsload_0Call as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::extsload_1(inner) => {
                    <extsload_1Call as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::extsload_2(inner) => {
                    <extsload_2Call as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::exttload_0(inner) => {
                    <exttload_0Call as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::exttload_1(inner) => {
                    <exttload_1Call as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::initialize(inner) => {
                    <initializeCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::isOperator(inner) => {
                    <isOperatorCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::mint(inner) => {
                    <mintCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::modifyLiquidity(inner) => {
                    <modifyLiquidityCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::owner(inner) => {
                    <ownerCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::protocolFeeController(inner) => {
                    <protocolFeeControllerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner, out,
                    )
                }
                Self::protocolFeesAccrued(inner) => {
                    <protocolFeesAccruedCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner, out,
                    )
                }
                Self::setOperator(inner) => {
                    <setOperatorCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::setProtocolFee(inner) => {
                    <setProtocolFeeCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::setProtocolFeeController(inner) => {
                    <setProtocolFeeControllerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner, out,
                    )
                }
                Self::settle(inner) => {
                    <settleCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::supportsInterface(inner) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::swap(inner) => {
                    <swapCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::sync(inner) => {
                    <syncCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::take(inner) => {
                    <takeCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::transfer(inner) => {
                    <transferCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::transferFrom(inner) => {
                    <transferFromCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::transferOwnership(inner) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::unlock(inner) => {
                    <unlockCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::updateDynamicLPFee(inner) => {
                    <updateDynamicLPFeeCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
            }
        }
    }
    ///Container for all the [`PoolManager`](self) custom errors.
    pub enum PoolManagerErrors {
        AlreadyUnlocked(AlreadyUnlocked),
        CurrenciesOutOfOrderOrEqual(CurrenciesOutOfOrderOrEqual),
        CurrencyNotSettled(CurrencyNotSettled),
        DelegateCallNotAllowed(DelegateCallNotAllowed),
        InvalidCaller(InvalidCaller),
        InvalidProtocolFee(InvalidProtocolFee),
        ManagerLocked(ManagerLocked),
        NonZeroNativeValue(NonZeroNativeValue),
        PoolNotInitialized(PoolNotInitialized),
        ProtocolFeeCannotBeFetched(ProtocolFeeCannotBeFetched),
        SwapAmountCannotBeZero(SwapAmountCannotBeZero),
        TickSpacingTooLarge(TickSpacingTooLarge),
        TickSpacingTooSmall(TickSpacingTooSmall),
        UnauthorizedDynamicLPFeeUpdate(UnauthorizedDynamicLPFeeUpdate),
    }
    #[automatically_derived]
    impl PoolManagerErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [13u8, 137u8, 67u8, 142u8],
            [22u8, 254u8, 118u8, 150u8],
            [25u8, 210u8, 69u8, 207u8],
            [30u8, 228u8, 151u8, 2u8],
            [48u8, 210u8, 22u8, 65u8],
            [72u8, 106u8, 163u8, 7u8],
            [72u8, 245u8, 195u8, 237u8],
            [80u8, 144u8, 214u8, 198u8],
            [82u8, 18u8, 203u8, 161u8],
            [84u8, 227u8, 202u8, 13u8],
            [176u8, 43u8, 93u8, 194u8],
            [186u8, 151u8, 248u8, 56u8],
            [190u8, 139u8, 133u8, 7u8],
            [234u8, 166u8, 198u8, 235u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for PoolManagerErrors {
        const NAME: &'static str = "PoolManagerErrors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 14usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::AlreadyUnlocked(_) => {
                    <AlreadyUnlocked as alloy_sol_types::SolError>::SELECTOR
                }
                Self::CurrenciesOutOfOrderOrEqual(_) => {
                    <CurrenciesOutOfOrderOrEqual as alloy_sol_types::SolError>::SELECTOR
                }
                Self::CurrencyNotSettled(_) => {
                    <CurrencyNotSettled as alloy_sol_types::SolError>::SELECTOR
                }
                Self::DelegateCallNotAllowed(_) => {
                    <DelegateCallNotAllowed as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidCaller(_) => <InvalidCaller as alloy_sol_types::SolError>::SELECTOR,
                Self::InvalidProtocolFee(_) => {
                    <InvalidProtocolFee as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ManagerLocked(_) => <ManagerLocked as alloy_sol_types::SolError>::SELECTOR,
                Self::NonZeroNativeValue(_) => {
                    <NonZeroNativeValue as alloy_sol_types::SolError>::SELECTOR
                }
                Self::PoolNotInitialized(_) => {
                    <PoolNotInitialized as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ProtocolFeeCannotBeFetched(_) => {
                    <ProtocolFeeCannotBeFetched as alloy_sol_types::SolError>::SELECTOR
                }
                Self::SwapAmountCannotBeZero(_) => {
                    <SwapAmountCannotBeZero as alloy_sol_types::SolError>::SELECTOR
                }
                Self::TickSpacingTooLarge(_) => {
                    <TickSpacingTooLarge as alloy_sol_types::SolError>::SELECTOR
                }
                Self::TickSpacingTooSmall(_) => {
                    <TickSpacingTooSmall as alloy_sol_types::SolError>::SELECTOR
                }
                Self::UnauthorizedDynamicLPFeeUpdate(_) => {
                    <UnauthorizedDynamicLPFeeUpdate as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(unsafe_code, non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            )
                -> alloy_sol_types::Result<PoolManagerErrors>] = &[
                {
                    fn DelegateCallNotAllowed(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolManagerErrors> {
                        <DelegateCallNotAllowed as alloy_sol_types::SolError>::abi_decode_raw(
                            data, validate,
                        )
                        .map(PoolManagerErrors::DelegateCallNotAllowed)
                    }
                    DelegateCallNotAllowed
                },
                {
                    fn TickSpacingTooSmall(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolManagerErrors> {
                        <TickSpacingTooSmall as alloy_sol_types::SolError>::abi_decode_raw(
                            data, validate,
                        )
                        .map(PoolManagerErrors::TickSpacingTooSmall)
                    }
                    TickSpacingTooSmall
                },
                {
                    fn NonZeroNativeValue(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolManagerErrors> {
                        <NonZeroNativeValue as alloy_sol_types::SolError>::abi_decode_raw(
                            data, validate,
                        )
                        .map(PoolManagerErrors::NonZeroNativeValue)
                    }
                    NonZeroNativeValue
                },
                {
                    fn ProtocolFeeCannotBeFetched(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolManagerErrors> {
                        <ProtocolFeeCannotBeFetched as alloy_sol_types::SolError>::abi_decode_raw(
                            data, validate,
                        )
                        .map(PoolManagerErrors::ProtocolFeeCannotBeFetched)
                    }
                    ProtocolFeeCannotBeFetched
                },
                {
                    fn UnauthorizedDynamicLPFeeUpdate(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolManagerErrors> {
                        <UnauthorizedDynamicLPFeeUpdate as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(PoolManagerErrors::UnauthorizedDynamicLPFeeUpdate)
                    }
                    UnauthorizedDynamicLPFeeUpdate
                },
                {
                    fn PoolNotInitialized(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolManagerErrors> {
                        <PoolNotInitialized as alloy_sol_types::SolError>::abi_decode_raw(
                            data, validate,
                        )
                        .map(PoolManagerErrors::PoolNotInitialized)
                    }
                    PoolNotInitialized
                },
                {
                    fn InvalidCaller(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolManagerErrors> {
                        <InvalidCaller as alloy_sol_types::SolError>::abi_decode_raw(data, validate)
                            .map(PoolManagerErrors::InvalidCaller)
                    }
                    InvalidCaller
                },
                {
                    fn AlreadyUnlocked(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolManagerErrors> {
                        <AlreadyUnlocked as alloy_sol_types::SolError>::abi_decode_raw(
                            data, validate,
                        )
                        .map(PoolManagerErrors::AlreadyUnlocked)
                    }
                    AlreadyUnlocked
                },
                {
                    fn CurrencyNotSettled(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolManagerErrors> {
                        <CurrencyNotSettled as alloy_sol_types::SolError>::abi_decode_raw(
                            data, validate,
                        )
                        .map(PoolManagerErrors::CurrencyNotSettled)
                    }
                    CurrencyNotSettled
                },
                {
                    fn ManagerLocked(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolManagerErrors> {
                        <ManagerLocked as alloy_sol_types::SolError>::abi_decode_raw(data, validate)
                            .map(PoolManagerErrors::ManagerLocked)
                    }
                    ManagerLocked
                },
                {
                    fn TickSpacingTooLarge(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolManagerErrors> {
                        <TickSpacingTooLarge as alloy_sol_types::SolError>::abi_decode_raw(
                            data, validate,
                        )
                        .map(PoolManagerErrors::TickSpacingTooLarge)
                    }
                    TickSpacingTooLarge
                },
                {
                    fn InvalidProtocolFee(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolManagerErrors> {
                        <InvalidProtocolFee as alloy_sol_types::SolError>::abi_decode_raw(
                            data, validate,
                        )
                        .map(PoolManagerErrors::InvalidProtocolFee)
                    }
                    InvalidProtocolFee
                },
                {
                    fn SwapAmountCannotBeZero(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolManagerErrors> {
                        <SwapAmountCannotBeZero as alloy_sol_types::SolError>::abi_decode_raw(
                            data, validate,
                        )
                        .map(PoolManagerErrors::SwapAmountCannotBeZero)
                    }
                    SwapAmountCannotBeZero
                },
                {
                    fn CurrenciesOutOfOrderOrEqual(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<PoolManagerErrors> {
                        <CurrenciesOutOfOrderOrEqual as alloy_sol_types::SolError>::abi_decode_raw(
                            data, validate,
                        )
                        .map(PoolManagerErrors::CurrenciesOutOfOrderOrEqual)
                    }
                    CurrenciesOutOfOrderOrEqual
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(alloy_sol_types::Error::unknown_selector(
                    <Self as alloy_sol_types::SolInterface>::NAME,
                    selector,
                ));
            };
            (unsafe { DECODE_SHIMS.get_unchecked(idx) })(data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::AlreadyUnlocked(inner) => {
                    <AlreadyUnlocked as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::CurrenciesOutOfOrderOrEqual(inner) => {
                    <CurrenciesOutOfOrderOrEqual as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::CurrencyNotSettled(inner) => {
                    <CurrencyNotSettled as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::DelegateCallNotAllowed(inner) => {
                    <DelegateCallNotAllowed as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::InvalidCaller(inner) => {
                    <InvalidCaller as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::InvalidProtocolFee(inner) => {
                    <InvalidProtocolFee as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::ManagerLocked(inner) => {
                    <ManagerLocked as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::NonZeroNativeValue(inner) => {
                    <NonZeroNativeValue as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::PoolNotInitialized(inner) => {
                    <PoolNotInitialized as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::ProtocolFeeCannotBeFetched(inner) => {
                    <ProtocolFeeCannotBeFetched as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::SwapAmountCannotBeZero(inner) => {
                    <SwapAmountCannotBeZero as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::TickSpacingTooLarge(inner) => {
                    <TickSpacingTooLarge as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::TickSpacingTooSmall(inner) => {
                    <TickSpacingTooSmall as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::UnauthorizedDynamicLPFeeUpdate(inner) => {
                    <UnauthorizedDynamicLPFeeUpdate as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::AlreadyUnlocked(inner) => {
                    <AlreadyUnlocked as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::CurrenciesOutOfOrderOrEqual(inner) => {
                    <CurrenciesOutOfOrderOrEqual as alloy_sol_types::SolError>::abi_encode_raw(
                        inner, out,
                    )
                }
                Self::CurrencyNotSettled(inner) => {
                    <CurrencyNotSettled as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::DelegateCallNotAllowed(inner) => {
                    <DelegateCallNotAllowed as alloy_sol_types::SolError>::abi_encode_raw(
                        inner, out,
                    )
                }
                Self::InvalidCaller(inner) => {
                    <InvalidCaller as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::InvalidProtocolFee(inner) => {
                    <InvalidProtocolFee as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::ManagerLocked(inner) => {
                    <ManagerLocked as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::NonZeroNativeValue(inner) => {
                    <NonZeroNativeValue as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::PoolNotInitialized(inner) => {
                    <PoolNotInitialized as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::ProtocolFeeCannotBeFetched(inner) => {
                    <ProtocolFeeCannotBeFetched as alloy_sol_types::SolError>::abi_encode_raw(
                        inner, out,
                    )
                }
                Self::SwapAmountCannotBeZero(inner) => {
                    <SwapAmountCannotBeZero as alloy_sol_types::SolError>::abi_encode_raw(
                        inner, out,
                    )
                }
                Self::TickSpacingTooLarge(inner) => {
                    <TickSpacingTooLarge as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::TickSpacingTooSmall(inner) => {
                    <TickSpacingTooSmall as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::UnauthorizedDynamicLPFeeUpdate(inner) => {
                    <UnauthorizedDynamicLPFeeUpdate as alloy_sol_types::SolError>::abi_encode_raw(
                        inner, out,
                    )
                }
            }
        }
    }
    ///Container for all the [`PoolManager`](self) events.
    pub enum PoolManagerEvents {
        Approval(Approval),
        Initialize(Initialize),
        ModifyLiquidity(ModifyLiquidity),
        OperatorSet(OperatorSet),
        OwnershipTransferred(OwnershipTransferred),
        ProtocolFeeControllerUpdated(ProtocolFeeControllerUpdated),
        ProtocolFeeUpdated(ProtocolFeeUpdated),
        Swap(Swap),
        Transfer(Transfer),
    }
    #[automatically_derived]
    impl PoolManagerEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                27u8, 61u8, 126u8, 219u8, 46u8, 156u8, 11u8, 14u8, 124u8, 82u8, 91u8, 32u8, 170u8,
                174u8, 240u8, 245u8, 148u8, 13u8, 46u8, 215u8, 22u8, 99u8, 199u8, 211u8, 146u8,
                102u8, 236u8, 175u8, 172u8, 114u8, 136u8, 89u8,
            ],
            [
                63u8, 213u8, 83u8, 219u8, 68u8, 242u8, 7u8, 177u8, 244u8, 19u8, 72u8, 207u8, 196u8,
                210u8, 81u8, 134u8, 8u8, 20u8, 175u8, 158u8, 173u8, 196u8, 112u8, 232u8, 231u8,
                137u8, 94u8, 77u8, 18u8, 5u8, 17u8, 244u8,
            ],
            [
                64u8, 233u8, 206u8, 203u8, 159u8, 95u8, 31u8, 28u8, 91u8, 156u8, 151u8, 222u8,
                194u8, 145u8, 123u8, 126u8, 233u8, 46u8, 87u8, 186u8, 85u8, 99u8, 112u8, 141u8,
                172u8, 169u8, 77u8, 216u8, 74u8, 215u8, 17u8, 47u8,
            ],
            [
                84u8, 28u8, 4u8, 28u8, 44u8, 206u8, 72u8, 230u8, 20u8, 179u8, 222u8, 4u8, 60u8,
                146u8, 128u8, 240u8, 107u8, 97u8, 100u8, 192u8, 161u8, 116u8, 22u8, 73u8, 226u8,
                222u8, 60u8, 61u8, 55u8, 95u8, 121u8, 116u8,
            ],
            [
                139u8, 224u8, 7u8, 156u8, 83u8, 22u8, 89u8, 20u8, 19u8, 68u8, 205u8, 31u8, 208u8,
                164u8, 242u8, 132u8, 25u8, 73u8, 127u8, 151u8, 34u8, 163u8, 218u8, 175u8, 227u8,
                180u8, 24u8, 111u8, 107u8, 100u8, 87u8, 224u8,
            ],
            [
                179u8, 253u8, 80u8, 113u8, 131u8, 88u8, 135u8, 86u8, 122u8, 6u8, 113u8, 21u8, 17u8,
                33u8, 137u8, 77u8, 220u8, 204u8, 40u8, 66u8, 241u8, 209u8, 11u8, 237u8, 173u8,
                19u8, 224u8, 209u8, 124u8, 172u8, 233u8, 167u8,
            ],
            [
                180u8, 189u8, 142u8, 245u8, 61u8, 246u8, 144u8, 185u8, 148u8, 61u8, 51u8, 24u8,
                153u8, 96u8, 6u8, 219u8, 184u8, 42u8, 37u8, 245u8, 71u8, 25u8, 216u8, 200u8, 3u8,
                91u8, 81u8, 106u8, 42u8, 91u8, 138u8, 204u8,
            ],
            [
                206u8, 181u8, 118u8, 217u8, 241u8, 94u8, 78u8, 32u8, 15u8, 219u8, 80u8, 150u8,
                214u8, 77u8, 93u8, 253u8, 102u8, 126u8, 22u8, 222u8, 242u8, 12u8, 30u8, 239u8,
                209u8, 66u8, 86u8, 216u8, 227u8, 250u8, 162u8, 103u8,
            ],
            [
                233u8, 196u8, 37u8, 147u8, 231u8, 31u8, 132u8, 64u8, 59u8, 132u8, 53u8, 44u8,
                209u8, 104u8, 214u8, 147u8, 226u8, 201u8, 252u8, 209u8, 253u8, 188u8, 195u8, 254u8,
                178u8, 29u8, 146u8, 180u8, 62u8, 102u8, 150u8, 249u8,
            ],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for PoolManagerEvents {
        const NAME: &'static str = "PoolManagerEvents";
        const COUNT: usize = 9usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(<Approval as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Approval as alloy_sol_types::SolEvent>::decode_raw_log(topics, data, validate)
                        .map(Self::Approval)
                }
                Some(<Initialize as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Initialize as alloy_sol_types::SolEvent>::decode_raw_log(
                        topics, data, validate,
                    )
                    .map(Self::Initialize)
                }
                Some(<ModifyLiquidity as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <ModifyLiquidity as alloy_sol_types::SolEvent>::decode_raw_log(
                        topics, data, validate,
                    )
                    .map(Self::ModifyLiquidity)
                }
                Some(<OperatorSet as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <OperatorSet as alloy_sol_types::SolEvent>::decode_raw_log(
                        topics, data, validate,
                    )
                    .map(Self::OperatorSet)
                }
                Some(<OwnershipTransferred as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <OwnershipTransferred as alloy_sol_types::SolEvent>::decode_raw_log(
                        topics, data, validate,
                    )
                    .map(Self::OwnershipTransferred)
                }
                Some(
                    <ProtocolFeeControllerUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => <ProtocolFeeControllerUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                    topics, data, validate,
                )
                .map(Self::ProtocolFeeControllerUpdated),
                Some(<ProtocolFeeUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <ProtocolFeeUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                        topics, data, validate,
                    )
                    .map(Self::ProtocolFeeUpdated)
                }
                Some(<Swap as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Swap as alloy_sol_types::SolEvent>::decode_raw_log(topics, data, validate)
                        .map(Self::Swap)
                }
                Some(<Transfer as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Transfer as alloy_sol_types::SolEvent>::decode_raw_log(topics, data, validate)
                        .map(Self::Transfer)
                }
                _ => alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                    name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                    log: alloy_sol_types::private::Box::new(
                        alloy_sol_types::private::LogData::new_unchecked(
                            topics.to_vec(),
                            data.to_vec().into(),
                        ),
                    ),
                }),
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`PoolManager`](self) contract instance.

    See the [wrapper's documentation](`PoolManagerInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> PoolManagerInstance<T, P, N> {
        PoolManagerInstance::<T, P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

    Returns a new instance of the contract, if the deployment was successful.

    For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        controllerGasLimit: alloy::sol_types::private::U256,
    ) -> impl ::core::future::Future<Output = alloy_contract::Result<PoolManagerInstance<T, P, N>>>
    {
        PoolManagerInstance::<T, P, N>::deploy(provider, controllerGasLimit)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
    and constructor arguments, if any.

    This is a simple wrapper around creating a `RawCallBuilder` with the data set to
    the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        controllerGasLimit: alloy::sol_types::private::U256,
    ) -> alloy_contract::RawCallBuilder<T, P, N> {
        PoolManagerInstance::<T, P, N>::deploy_builder(provider, controllerGasLimit)
    }
    /**A [`PoolManager`](self) instance.

    Contains type-safe methods for interacting with an on-chain instance of the
    [`PoolManager`](self) contract located at a given `address`, using a given
    provider `P`.

    If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
    documentation on how to provide it), the `deploy` and `deploy_builder` methods can
    be used to deploy a new instance of the contract.

    See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct PoolManagerInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for PoolManagerInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("PoolManagerInstance")
                .field(&self.address)
                .finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
            T: alloy_contract::private::Transport + ::core::clone::Clone,
            P: alloy_contract::private::Provider<T, N>,
            N: alloy_contract::private::Network,
        > PoolManagerInstance<T, P, N>
    {
        /**Creates a new wrapper around an on-chain [`PoolManager`](self) contract instance.

        See the [wrapper's documentation](`PoolManagerInstance`) for more details.*/
        #[inline]
        pub const fn new(address: alloy_sol_types::private::Address, provider: P) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

        Returns a new instance of the contract, if the deployment was successful.

        For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
            controllerGasLimit: alloy::sol_types::private::U256,
        ) -> alloy_contract::Result<PoolManagerInstance<T, P, N>> {
            let call_builder = Self::deploy_builder(provider, controllerGasLimit);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
        and constructor arguments, if any.

        This is a simple wrapper around creating a `RawCallBuilder` with the data set to
        the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(
            provider: P,
            controllerGasLimit: alloy::sol_types::private::U256,
        ) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                [
                    &BYTECODE[..],
                    &alloy_sol_types::SolConstructor::abi_encode(&constructorCall {
                        controllerGasLimit,
                    })[..],
                ]
                .concat()
                .into(),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> PoolManagerInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> PoolManagerInstance<T, P, N> {
            PoolManagerInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
            T: alloy_contract::private::Transport + ::core::clone::Clone,
            P: alloy_contract::private::Provider<T, N>,
            N: alloy_contract::private::Network,
        > PoolManagerInstance<T, P, N>
    {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`MAX_TICK_SPACING`] function.
        pub fn MAX_TICK_SPACING(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, MAX_TICK_SPACINGCall, N> {
            self.call_builder(&MAX_TICK_SPACINGCall {})
        }
        ///Creates a new call builder for the [`MIN_TICK_SPACING`] function.
        pub fn MIN_TICK_SPACING(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, MIN_TICK_SPACINGCall, N> {
            self.call_builder(&MIN_TICK_SPACINGCall {})
        }
        ///Creates a new call builder for the [`allowance`] function.
        pub fn allowance(
            &self,
            _0: alloy::sol_types::private::Address,
            _1: alloy::sol_types::private::Address,
            _2: alloy::sol_types::private::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, allowanceCall, N> {
            self.call_builder(&allowanceCall { _0, _1, _2 })
        }
        ///Creates a new call builder for the [`approve`] function.
        pub fn approve(
            &self,
            spender: alloy::sol_types::private::Address,
            id: alloy::sol_types::private::U256,
            amount: alloy::sol_types::private::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, approveCall, N> {
            self.call_builder(&approveCall {
                spender,
                id,
                amount,
            })
        }
        ///Creates a new call builder for the [`balanceOf`] function.
        pub fn balanceOf(
            &self,
            _0: alloy::sol_types::private::Address,
            _1: alloy::sol_types::private::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, balanceOfCall, N> {
            self.call_builder(&balanceOfCall { _0, _1 })
        }
        ///Creates a new call builder for the [`burn`] function.
        pub fn burn(
            &self,
            from: alloy::sol_types::private::Address,
            id: alloy::sol_types::private::U256,
            amount: alloy::sol_types::private::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, burnCall, N> {
            self.call_builder(&burnCall { from, id, amount })
        }
        ///Creates a new call builder for the [`collectProtocolFees`] function.
        pub fn collectProtocolFees(
            &self,
            recipient: alloy::sol_types::private::Address,
            currency: <Currency as alloy::sol_types::SolType>::RustType,
            amount: alloy::sol_types::private::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, collectProtocolFeesCall, N> {
            self.call_builder(&collectProtocolFeesCall {
                recipient,
                currency,
                amount,
            })
        }
        ///Creates a new call builder for the [`donate`] function.
        pub fn donate(
            &self,
            key: <PoolKey as alloy::sol_types::SolType>::RustType,
            amount0: alloy::sol_types::private::U256,
            amount1: alloy::sol_types::private::U256,
            hookData: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, donateCall, N> {
            self.call_builder(&donateCall {
                key,
                amount0,
                amount1,
                hookData,
            })
        }
        ///Creates a new call builder for the [`extsload_0`] function.
        pub fn extsload_0(
            &self,
            slot: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, extsload_0Call, N> {
            self.call_builder(&extsload_0Call { slot })
        }
        ///Creates a new call builder for the [`extsload_1`] function.
        pub fn extsload_1(
            &self,
            startSlot: alloy::sol_types::private::FixedBytes<32>,
            nSlots: alloy::sol_types::private::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, extsload_1Call, N> {
            self.call_builder(&extsload_1Call { startSlot, nSlots })
        }
        ///Creates a new call builder for the [`extsload_2`] function.
        pub fn extsload_2(
            &self,
            slots: alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
        ) -> alloy_contract::SolCallBuilder<T, &P, extsload_2Call, N> {
            self.call_builder(&extsload_2Call { slots })
        }
        ///Creates a new call builder for the [`exttload_0`] function.
        pub fn exttload_0(
            &self,
            slots: alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
        ) -> alloy_contract::SolCallBuilder<T, &P, exttload_0Call, N> {
            self.call_builder(&exttload_0Call { slots })
        }
        ///Creates a new call builder for the [`exttload_1`] function.
        pub fn exttload_1(
            &self,
            slot: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, exttload_1Call, N> {
            self.call_builder(&exttload_1Call { slot })
        }
        ///Creates a new call builder for the [`initialize`] function.
        pub fn initialize(
            &self,
            key: <PoolKey as alloy::sol_types::SolType>::RustType,
            sqrtPriceX96: <alloy::sol_types::sol_data::Uint<
                160,
            > as alloy::sol_types::SolType>::RustType,
            hookData: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, initializeCall, N> {
            self.call_builder(&initializeCall {
                key,
                sqrtPriceX96,
                hookData,
            })
        }
        ///Creates a new call builder for the [`isOperator`] function.
        pub fn isOperator(
            &self,
            _0: alloy::sol_types::private::Address,
            _1: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, isOperatorCall, N> {
            self.call_builder(&isOperatorCall { _0, _1 })
        }
        ///Creates a new call builder for the [`mint`] function.
        pub fn mint(
            &self,
            to: alloy::sol_types::private::Address,
            id: alloy::sol_types::private::U256,
            amount: alloy::sol_types::private::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, mintCall, N> {
            self.call_builder(&mintCall { to, id, amount })
        }
        ///Creates a new call builder for the [`modifyLiquidity`] function.
        pub fn modifyLiquidity(
            &self,
            key: <PoolKey as alloy::sol_types::SolType>::RustType,
            params: <ModifyLiquidityParams as alloy::sol_types::SolType>::RustType,
            hookData: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, modifyLiquidityCall, N> {
            self.call_builder(&modifyLiquidityCall {
                key,
                params,
                hookData,
            })
        }
        ///Creates a new call builder for the [`owner`] function.
        pub fn owner(&self) -> alloy_contract::SolCallBuilder<T, &P, ownerCall, N> {
            self.call_builder(&ownerCall {})
        }
        ///Creates a new call builder for the [`protocolFeeController`] function.
        pub fn protocolFeeController(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, protocolFeeControllerCall, N> {
            self.call_builder(&protocolFeeControllerCall {})
        }
        ///Creates a new call builder for the [`protocolFeesAccrued`] function.
        pub fn protocolFeesAccrued(
            &self,
            currency: <Currency as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, protocolFeesAccruedCall, N> {
            self.call_builder(&protocolFeesAccruedCall { currency })
        }
        ///Creates a new call builder for the [`setOperator`] function.
        pub fn setOperator(
            &self,
            operator: alloy::sol_types::private::Address,
            approved: bool,
        ) -> alloy_contract::SolCallBuilder<T, &P, setOperatorCall, N> {
            self.call_builder(&setOperatorCall { operator, approved })
        }
        ///Creates a new call builder for the [`setProtocolFee`] function.
        pub fn setProtocolFee(
            &self,
            key: <PoolKey as alloy::sol_types::SolType>::RustType,
            newProtocolFee: <alloy::sol_types::sol_data::Uint<
                24,
            > as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, setProtocolFeeCall, N> {
            self.call_builder(&setProtocolFeeCall {
                key,
                newProtocolFee,
            })
        }
        ///Creates a new call builder for the [`setProtocolFeeController`] function.
        pub fn setProtocolFeeController(
            &self,
            controller: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, setProtocolFeeControllerCall, N> {
            self.call_builder(&setProtocolFeeControllerCall { controller })
        }
        ///Creates a new call builder for the [`settle`] function.
        pub fn settle(
            &self,
            currency: <Currency as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, settleCall, N> {
            self.call_builder(&settleCall { currency })
        }
        ///Creates a new call builder for the [`supportsInterface`] function.
        pub fn supportsInterface(
            &self,
            interfaceId: alloy::sol_types::private::FixedBytes<4>,
        ) -> alloy_contract::SolCallBuilder<T, &P, supportsInterfaceCall, N> {
            self.call_builder(&supportsInterfaceCall { interfaceId })
        }
        ///Creates a new call builder for the [`swap`] function.
        pub fn swap(
            &self,
            key: <PoolKey as alloy::sol_types::SolType>::RustType,
            params: <SwapParams as alloy::sol_types::SolType>::RustType,
            hookData: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, swapCall, N> {
            self.call_builder(&swapCall {
                key,
                params,
                hookData,
            })
        }
        ///Creates a new call builder for the [`sync`] function.
        pub fn sync(
            &self,
            currency: <Currency as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, syncCall, N> {
            self.call_builder(&syncCall { currency })
        }
        ///Creates a new call builder for the [`take`] function.
        pub fn take(
            &self,
            currency: <Currency as alloy::sol_types::SolType>::RustType,
            to: alloy::sol_types::private::Address,
            amount: alloy::sol_types::private::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, takeCall, N> {
            self.call_builder(&takeCall {
                currency,
                to,
                amount,
            })
        }
        ///Creates a new call builder for the [`transfer`] function.
        pub fn transfer(
            &self,
            receiver: alloy::sol_types::private::Address,
            id: alloy::sol_types::private::U256,
            amount: alloy::sol_types::private::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, transferCall, N> {
            self.call_builder(&transferCall {
                receiver,
                id,
                amount,
            })
        }
        ///Creates a new call builder for the [`transferFrom`] function.
        pub fn transferFrom(
            &self,
            sender: alloy::sol_types::private::Address,
            receiver: alloy::sol_types::private::Address,
            id: alloy::sol_types::private::U256,
            amount: alloy::sol_types::private::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, transferFromCall, N> {
            self.call_builder(&transferFromCall {
                sender,
                receiver,
                id,
                amount,
            })
        }
        ///Creates a new call builder for the [`transferOwnership`] function.
        pub fn transferOwnership(
            &self,
            newOwner: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, transferOwnershipCall, N> {
            self.call_builder(&transferOwnershipCall { newOwner })
        }
        ///Creates a new call builder for the [`unlock`] function.
        pub fn unlock(
            &self,
            data: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, unlockCall, N> {
            self.call_builder(&unlockCall { data })
        }
        ///Creates a new call builder for the [`updateDynamicLPFee`] function.
        pub fn updateDynamicLPFee(
            &self,
            key: <PoolKey as alloy::sol_types::SolType>::RustType,
            newDynamicLPFee: <alloy::sol_types::sol_data::Uint<
                24,
            > as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, updateDynamicLPFeeCall, N> {
            self.call_builder(&updateDynamicLPFeeCall {
                key,
                newDynamicLPFee,
            })
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
            T: alloy_contract::private::Transport + ::core::clone::Clone,
            P: alloy_contract::private::Provider<T, N>,
            N: alloy_contract::private::Network,
        > PoolManagerInstance<T, P, N>
    {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`Approval`] event.
        pub fn Approval_filter(&self) -> alloy_contract::Event<T, &P, Approval, N> {
            self.event_filter::<Approval>()
        }
        ///Creates a new event filter for the [`Initialize`] event.
        pub fn Initialize_filter(&self) -> alloy_contract::Event<T, &P, Initialize, N> {
            self.event_filter::<Initialize>()
        }
        ///Creates a new event filter for the [`ModifyLiquidity`] event.
        pub fn ModifyLiquidity_filter(&self) -> alloy_contract::Event<T, &P, ModifyLiquidity, N> {
            self.event_filter::<ModifyLiquidity>()
        }
        ///Creates a new event filter for the [`OperatorSet`] event.
        pub fn OperatorSet_filter(&self) -> alloy_contract::Event<T, &P, OperatorSet, N> {
            self.event_filter::<OperatorSet>()
        }
        ///Creates a new event filter for the [`OwnershipTransferred`] event.
        pub fn OwnershipTransferred_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, OwnershipTransferred, N> {
            self.event_filter::<OwnershipTransferred>()
        }
        ///Creates a new event filter for the [`ProtocolFeeControllerUpdated`] event.
        pub fn ProtocolFeeControllerUpdated_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, ProtocolFeeControllerUpdated, N> {
            self.event_filter::<ProtocolFeeControllerUpdated>()
        }
        ///Creates a new event filter for the [`ProtocolFeeUpdated`] event.
        pub fn ProtocolFeeUpdated_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, ProtocolFeeUpdated, N> {
            self.event_filter::<ProtocolFeeUpdated>()
        }
        ///Creates a new event filter for the [`Swap`] event.
        pub fn Swap_filter(&self) -> alloy_contract::Event<T, &P, Swap, N> {
            self.event_filter::<Swap>()
        }
        ///Creates a new event filter for the [`Transfer`] event.
        pub fn Transfer_filter(&self) -> alloy_contract::Event<T, &P, Transfer, N> {
            self.event_filter::<Transfer>()
        }
    }
}
