/**

Generated by the following Solidity interface...
```solidity
interface MockContract {
    fallback() external payable;

    receive() external payable;

    function callParams(bytes32, bytes memory) external view returns (uint256);
    function calledWith(string memory fnSig, bytes memory params) external view returns (bool);
    function calledWithSelector(bytes32 selector, bytes memory params) external view returns (bool);
    function calls(bytes32) external view returns (uint256);
    function setImplementation(address _impl) external;
    function timesCalled(string memory fnSig) external view returns (uint256);
    function timesCalledSelector(bytes32 selector) external view returns (uint256);
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "fallback",
    "stateMutability": "payable"
  },
  {
    "type": "receive",
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "callParams",
    "inputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "calledWith",
    "inputs": [
      {
        "name": "fnSig",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "params",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "calledWithSelector",
    "inputs": [
      {
        "name": "selector",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "params",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "calls",
    "inputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "setImplementation",
    "inputs": [
      {
        "name": "_impl",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "timesCalled",
    "inputs": [
      {
        "name": "fnSig",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "timesCalledSelector",
    "inputs": [
      {
        "name": "selector",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  }
]
```*/
#[allow(non_camel_case_types, non_snake_case, clippy::style)]
pub mod MockContract {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x60808060405234601557610717908161001a8239f35b5f80fdfe60806040526004361015610018575b3661052e5761052e565b5f3560e01c80633e43e5e5146100825780635837e5b714610073578063891725b11461007d578063bbd7fc9a14610078578063cff1026514610073578063d784d4261461006e5763d80a40770361000e5761047f565b610402565b610159565b610365565b6101a0565b346101275760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126101275760043567ffffffffffffffff8111610127576100fc6100f57fffffffff0000000000000000000000000000000000000000000000000000000092369060040161012b565b36916102cc565b60208151910120165f525f60205261012360405f2054604051918291829190602083019252565b0390f35b5f80fd5b9181601f840112156101275782359167ffffffffffffffff8311610127576020838186019501011161012757565b346101275760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610127576004355f525f602052602060405f2054604051908152f35b346101275760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126101275760043567ffffffffffffffff8111610127576101ef90369060040161012b565b9060243567ffffffffffffffff81116101275761023e6102347fffffffff0000000000000000000000000000000000000000000000000000000092369060040161012b565b93909436916102cc565b60208151910120165f52600160205260405f2081600111610127576101239260017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff61028c94019101610515565b5460405190151581529081906020820190565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b92919267ffffffffffffffff821161034157604051917fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0603f81601f8401160116830183811067ffffffffffffffff82111761034157604052829481845281830111610127578281602093845f960137010152565b61029f565b6040518151909260209284929081908501845e82019081520301902090565b346101275760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126101275760243560043567ffffffffffffffff8211610127573660238301121561012757602080916103cf6101239436906024816004013591016102cc565b905f526001825260405f20604051938285935191829101845e820190815203019020546040519081529081906020820190565b346101275760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126101275760043573ffffffffffffffffffffffffffffffffffffffff8116809103610127577fffffffffffffffffffffffff000000000000000000000000000000000000000060025416176002555f80f35b346101275760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126101275760043560243567ffffffffffffffff8111610127576104d190369060040161012b565b90915f52600160205260405f2081600111610127576101239260017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff61028c940191015b6020919283604051948593843782019081520301902090565b36600511610127577fffffffffff0000000000000000000000000000000000000000000000000000005f35167ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffb360167ffffffffffffffff811161034157604051907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0603f81601a3601160116820182811067ffffffffffffffff821117610341576040528082526106409261063a91600560208501375f60207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffb368601010152610620815f525f60205260405f2090565b61062a815461066a565b90555f52600160205260405f2090565b90610346565b61064a815461066a565b905560025473ffffffffffffffffffffffffffffffffffffffff166106c4565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff81146106975760010190565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f8091368280378136915af43d5f803e156106dd573d5ff35b3d5ffdfea26469706673582212206740a97415c602ebd51c57acb287426f732a967a35e7e799090c64637dd6bcf464736f6c634300081a0033
    /// ```
    #[rustfmt::skip]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80\x80`@R4`\x15Wa\x07\x17\x90\x81a\0\x1A\x829\xF3[_\x80\xFD\xFE`\x80`@R`\x046\x10\x15a\0\x18W[6a\x05.Wa\x05.V[_5`\xE0\x1C\x80c>C\xE5\xE5\x14a\0\x82W\x80cX7\xE5\xB7\x14a\0sW\x80c\x89\x17%\xB1\x14a\0}W\x80c\xBB\xD7\xFC\x9A\x14a\0xW\x80c\xCF\xF1\x02e\x14a\0sW\x80c\xD7\x84\xD4&\x14a\0nWc\xD8\n@w\x03a\0\x0EWa\x04\x7FV[a\x04\x02V[a\x01YV[a\x03eV[a\x01\xA0V[4a\x01'W` \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x01'W`\x045g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x01'Wa\0\xFCa\0\xF5\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x926\x90`\x04\x01a\x01+V[6\x91a\x02\xCCV[` \x81Q\x91\x01 \x16_R_` Ra\x01#`@_ T`@Q\x91\x82\x91\x82\x91\x90` \x83\x01\x92RV[\x03\x90\xF3[_\x80\xFD[\x91\x81`\x1F\x84\x01\x12\x15a\x01'W\x825\x91g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11a\x01'W` \x83\x81\x86\x01\x95\x01\x01\x11a\x01'WV[4a\x01'W` \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x01'W`\x045_R_` R` `@_ T`@Q\x90\x81R\xF3[4a\x01'W`@\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x01'W`\x045g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x01'Wa\x01\xEF\x906\x90`\x04\x01a\x01+V[\x90`$5g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x01'Wa\x02>a\x024\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x926\x90`\x04\x01a\x01+V[\x93\x90\x946\x91a\x02\xCCV[` \x81Q\x91\x01 \x16_R`\x01` R`@_ \x81`\x01\x11a\x01'Wa\x01#\x92`\x01\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x02\x8C\x94\x01\x91\x01a\x05\x15V[T`@Q\x90\x15\x15\x81R\x90\x81\x90` \x82\x01\x90V[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`A`\x04R`$_\xFD[\x92\x91\x92g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x03AW`@Q\x91\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0`?\x81`\x1F\x84\x01\x16\x01\x16\x83\x01\x83\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x03AW`@R\x82\x94\x81\x84R\x81\x83\x01\x11a\x01'W\x82\x81` \x93\x84_\x96\x017\x01\x01RV[a\x02\x9FV[`@Q\x81Q\x90\x92` \x92\x84\x92\x90\x81\x90\x85\x01\x84^\x82\x01\x90\x81R\x03\x01\x90 \x90V[4a\x01'W`@\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x01'W`$5`\x045g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x01'W6`#\x83\x01\x12\x15a\x01'W` \x80\x91a\x03\xCFa\x01#\x946\x90`$\x81`\x04\x015\x91\x01a\x02\xCCV[\x90_R`\x01\x82R`@_ `@Q\x93\x82\x85\x93Q\x91\x82\x91\x01\x84^\x82\x01\x90\x81R\x03\x01\x90 T`@Q\x90\x81R\x90\x81\x90` \x82\x01\x90V[4a\x01'W` \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x01'W`\x045s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x80\x91\x03a\x01'W\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x02T\x16\x17`\x02U_\x80\xF3[4a\x01'W`@\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x01'W`\x045`$5g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x01'Wa\x04\xD1\x906\x90`\x04\x01a\x01+V[\x90\x91_R`\x01` R`@_ \x81`\x01\x11a\x01'Wa\x01#\x92`\x01\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x02\x8C\x94\x01\x91\x01[` \x91\x92\x83`@Q\x94\x85\x93\x847\x82\x01\x90\x81R\x03\x01\x90 \x90V[6`\x05\x11a\x01'W\x7F\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_5\x16\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFB6\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x03AW`@Q\x90\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0`?\x81`\x1A6\x01\x16\x01\x16\x82\x01\x82\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x03AW`@R\x80\x82Ra\x06@\x92a\x06:\x91`\x05` \x85\x017_` \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFB6\x86\x01\x01\x01Ra\x06 \x81_R_` R`@_ \x90V[a\x06*\x81Ta\x06jV[\x90U_R`\x01` R`@_ \x90V[\x90a\x03FV[a\x06J\x81Ta\x06jV[\x90U`\x02Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x06\xC4V[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x14a\x06\x97W`\x01\x01\x90V[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x11`\x04R`$_\xFD[_\x80\x916\x82\x807\x816\x91Z\xF4=_\x80>\x15a\x06\xDDW=_\xF3[=_\xFD\xFE\xA2dipfsX\"\x12 g@\xA9t\x15\xC6\x02\xEB\xD5\x1CW\xAC\xB2\x87Bos*\x96z5\xE7\xE7\x99\t\x0Cdc}\xD6\xBC\xF4dsolcC\0\x08\x1A\x003",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x60806040526004361015610018575b3661052e5761052e565b5f3560e01c80633e43e5e5146100825780635837e5b714610073578063891725b11461007d578063bbd7fc9a14610078578063cff1026514610073578063d784d4261461006e5763d80a40770361000e5761047f565b610402565b610159565b610365565b6101a0565b346101275760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126101275760043567ffffffffffffffff8111610127576100fc6100f57fffffffff0000000000000000000000000000000000000000000000000000000092369060040161012b565b36916102cc565b60208151910120165f525f60205261012360405f2054604051918291829190602083019252565b0390f35b5f80fd5b9181601f840112156101275782359167ffffffffffffffff8311610127576020838186019501011161012757565b346101275760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610127576004355f525f602052602060405f2054604051908152f35b346101275760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126101275760043567ffffffffffffffff8111610127576101ef90369060040161012b565b9060243567ffffffffffffffff81116101275761023e6102347fffffffff0000000000000000000000000000000000000000000000000000000092369060040161012b565b93909436916102cc565b60208151910120165f52600160205260405f2081600111610127576101239260017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff61028c94019101610515565b5460405190151581529081906020820190565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b92919267ffffffffffffffff821161034157604051917fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0603f81601f8401160116830183811067ffffffffffffffff82111761034157604052829481845281830111610127578281602093845f960137010152565b61029f565b6040518151909260209284929081908501845e82019081520301902090565b346101275760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126101275760243560043567ffffffffffffffff8211610127573660238301121561012757602080916103cf6101239436906024816004013591016102cc565b905f526001825260405f20604051938285935191829101845e820190815203019020546040519081529081906020820190565b346101275760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126101275760043573ffffffffffffffffffffffffffffffffffffffff8116809103610127577fffffffffffffffffffffffff000000000000000000000000000000000000000060025416176002555f80f35b346101275760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126101275760043560243567ffffffffffffffff8111610127576104d190369060040161012b565b90915f52600160205260405f2081600111610127576101239260017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff61028c940191015b6020919283604051948593843782019081520301902090565b36600511610127577fffffffffff0000000000000000000000000000000000000000000000000000005f35167ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffb360167ffffffffffffffff811161034157604051907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0603f81601a3601160116820182811067ffffffffffffffff821117610341576040528082526106409261063a91600560208501375f60207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffb368601010152610620815f525f60205260405f2090565b61062a815461066a565b90555f52600160205260405f2090565b90610346565b61064a815461066a565b905560025473ffffffffffffffffffffffffffffffffffffffff166106c4565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff81146106975760010190565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f8091368280378136915af43d5f803e156106dd573d5ff35b3d5ffdfea26469706673582212206740a97415c602ebd51c57acb287426f732a967a35e7e799090c64637dd6bcf464736f6c634300081a0033
    /// ```
    #[rustfmt::skip]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R`\x046\x10\x15a\0\x18W[6a\x05.Wa\x05.V[_5`\xE0\x1C\x80c>C\xE5\xE5\x14a\0\x82W\x80cX7\xE5\xB7\x14a\0sW\x80c\x89\x17%\xB1\x14a\0}W\x80c\xBB\xD7\xFC\x9A\x14a\0xW\x80c\xCF\xF1\x02e\x14a\0sW\x80c\xD7\x84\xD4&\x14a\0nWc\xD8\n@w\x03a\0\x0EWa\x04\x7FV[a\x04\x02V[a\x01YV[a\x03eV[a\x01\xA0V[4a\x01'W` \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x01'W`\x045g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x01'Wa\0\xFCa\0\xF5\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x926\x90`\x04\x01a\x01+V[6\x91a\x02\xCCV[` \x81Q\x91\x01 \x16_R_` Ra\x01#`@_ T`@Q\x91\x82\x91\x82\x91\x90` \x83\x01\x92RV[\x03\x90\xF3[_\x80\xFD[\x91\x81`\x1F\x84\x01\x12\x15a\x01'W\x825\x91g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11a\x01'W` \x83\x81\x86\x01\x95\x01\x01\x11a\x01'WV[4a\x01'W` \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x01'W`\x045_R_` R` `@_ T`@Q\x90\x81R\xF3[4a\x01'W`@\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x01'W`\x045g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x01'Wa\x01\xEF\x906\x90`\x04\x01a\x01+V[\x90`$5g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x01'Wa\x02>a\x024\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x926\x90`\x04\x01a\x01+V[\x93\x90\x946\x91a\x02\xCCV[` \x81Q\x91\x01 \x16_R`\x01` R`@_ \x81`\x01\x11a\x01'Wa\x01#\x92`\x01\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x02\x8C\x94\x01\x91\x01a\x05\x15V[T`@Q\x90\x15\x15\x81R\x90\x81\x90` \x82\x01\x90V[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`A`\x04R`$_\xFD[\x92\x91\x92g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x03AW`@Q\x91\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0`?\x81`\x1F\x84\x01\x16\x01\x16\x83\x01\x83\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x03AW`@R\x82\x94\x81\x84R\x81\x83\x01\x11a\x01'W\x82\x81` \x93\x84_\x96\x017\x01\x01RV[a\x02\x9FV[`@Q\x81Q\x90\x92` \x92\x84\x92\x90\x81\x90\x85\x01\x84^\x82\x01\x90\x81R\x03\x01\x90 \x90V[4a\x01'W`@\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x01'W`$5`\x045g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x01'W6`#\x83\x01\x12\x15a\x01'W` \x80\x91a\x03\xCFa\x01#\x946\x90`$\x81`\x04\x015\x91\x01a\x02\xCCV[\x90_R`\x01\x82R`@_ `@Q\x93\x82\x85\x93Q\x91\x82\x91\x01\x84^\x82\x01\x90\x81R\x03\x01\x90 T`@Q\x90\x81R\x90\x81\x90` \x82\x01\x90V[4a\x01'W` \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x01'W`\x045s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x80\x91\x03a\x01'W\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x02T\x16\x17`\x02U_\x80\xF3[4a\x01'W`@\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x01'W`\x045`$5g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x01'Wa\x04\xD1\x906\x90`\x04\x01a\x01+V[\x90\x91_R`\x01` R`@_ \x81`\x01\x11a\x01'Wa\x01#\x92`\x01\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x02\x8C\x94\x01\x91\x01[` \x91\x92\x83`@Q\x94\x85\x93\x847\x82\x01\x90\x81R\x03\x01\x90 \x90V[6`\x05\x11a\x01'W\x7F\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_5\x16\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFB6\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x03AW`@Q\x90\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0`?\x81`\x1A6\x01\x16\x01\x16\x82\x01\x82\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x03AW`@R\x80\x82Ra\x06@\x92a\x06:\x91`\x05` \x85\x017_` \x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFB6\x86\x01\x01\x01Ra\x06 \x81_R_` R`@_ \x90V[a\x06*\x81Ta\x06jV[\x90U_R`\x01` R`@_ \x90V[\x90a\x03FV[a\x06J\x81Ta\x06jV[\x90U`\x02Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x06\xC4V[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x14a\x06\x97W`\x01\x01\x90V[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x11`\x04R`$_\xFD[_\x80\x916\x82\x807\x816\x91Z\xF4=_\x80>\x15a\x06\xDDW=_\xF3[=_\xFD\xFE\xA2dipfsX\"\x12 g@\xA9t\x15\xC6\x02\xEB\xD5\x1CW\xAC\xB2\x87Bos*\x96z5\xE7\xE7\x99\t\x0Cdc}\xD6\xBC\xF4dsolcC\0\x08\x1A\x003",
    );
    /**Function with signature `callParams(bytes32,bytes)` and selector `0xbbd7fc9a`.
```solidity
function callParams(bytes32, bytes memory) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct callParamsCall {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
        pub _1: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`callParams(bytes32,bytes)`](callParamsCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct callParamsReturn {
        pub _0: alloy::sol_types::private::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<callParamsCall> for UnderlyingRustTuple<'_> {
                fn from(value: callParamsCall) -> Self {
                    (value._0, value._1)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for callParamsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0, _1: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<callParamsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: callParamsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for callParamsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for callParamsCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = callParamsReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "callParams(bytes32,bytes)";
            const SELECTOR: [u8; 4] = [187u8, 215u8, 252u8, 154u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self._1,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `calledWith(string,bytes)` and selector `0x891725b1`.
```solidity
function calledWith(string memory fnSig, bytes memory params) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct calledWithCall {
        pub fnSig: alloy::sol_types::private::String,
        pub params: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`calledWith(string,bytes)`](calledWithCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct calledWithReturn {
        pub _0: bool,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::String,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<calledWithCall> for UnderlyingRustTuple<'_> {
                fn from(value: calledWithCall) -> Self {
                    (value.fnSig, value.params)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for calledWithCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        fnSig: tuple.0,
                        params: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<calledWithReturn> for UnderlyingRustTuple<'_> {
                fn from(value: calledWithReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for calledWithReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for calledWithCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = calledWithReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "calledWith(string,bytes)";
            const SELECTOR: [u8; 4] = [137u8, 23u8, 37u8, 177u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.fnSig,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.params,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `calledWithSelector(bytes32,bytes)` and selector `0xd80a4077`.
```solidity
function calledWithSelector(bytes32 selector, bytes memory params) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct calledWithSelectorCall {
        pub selector: alloy::sol_types::private::FixedBytes<32>,
        pub params: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`calledWithSelector(bytes32,bytes)`](calledWithSelectorCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct calledWithSelectorReturn {
        pub _0: bool,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<calledWithSelectorCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: calledWithSelectorCall) -> Self {
                    (value.selector, value.params)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for calledWithSelectorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        selector: tuple.0,
                        params: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<calledWithSelectorReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: calledWithSelectorReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for calledWithSelectorReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for calledWithSelectorCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = calledWithSelectorReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "calledWithSelector(bytes32,bytes)";
            const SELECTOR: [u8; 4] = [216u8, 10u8, 64u8, 119u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.selector),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.params,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `calls(bytes32)` and selector `0xcff10265`.
```solidity
function calls(bytes32) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct callsCall {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`calls(bytes32)`](callsCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct callsReturn {
        pub _0: alloy::sol_types::private::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<callsCall> for UnderlyingRustTuple<'_> {
                fn from(value: callsCall) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for callsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<callsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: callsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for callsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for callsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = callsReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "calls(bytes32)";
            const SELECTOR: [u8; 4] = [207u8, 241u8, 2u8, 101u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setImplementation(address)` and selector `0xd784d426`.
```solidity
function setImplementation(address _impl) external;
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct setImplementationCall {
        pub _impl: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`setImplementation(address)`](setImplementationCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct setImplementationReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setImplementationCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setImplementationCall) -> Self {
                    (value._impl,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setImplementationCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _impl: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setImplementationReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setImplementationReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setImplementationReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setImplementationCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setImplementationReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setImplementation(address)";
            const SELECTOR: [u8; 4] = [215u8, 132u8, 212u8, 38u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._impl,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `timesCalled(string)` and selector `0x3e43e5e5`.
```solidity
function timesCalled(string memory fnSig) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct timesCalledCall {
        pub fnSig: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`timesCalled(string)`](timesCalledCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct timesCalledReturn {
        pub _0: alloy::sol_types::private::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<timesCalledCall> for UnderlyingRustTuple<'_> {
                fn from(value: timesCalledCall) -> Self {
                    (value.fnSig,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for timesCalledCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { fnSig: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<timesCalledReturn> for UnderlyingRustTuple<'_> {
                fn from(value: timesCalledReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for timesCalledReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for timesCalledCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::String,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = timesCalledReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "timesCalled(string)";
            const SELECTOR: [u8; 4] = [62u8, 67u8, 229u8, 229u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.fnSig,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `timesCalledSelector(bytes32)` and selector `0x5837e5b7`.
```solidity
function timesCalledSelector(bytes32 selector) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct timesCalledSelectorCall {
        pub selector: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`timesCalledSelector(bytes32)`](timesCalledSelectorCall) function.
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct timesCalledSelectorReturn {
        pub _0: alloy::sol_types::private::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<timesCalledSelectorCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: timesCalledSelectorCall) -> Self {
                    (value.selector,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for timesCalledSelectorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { selector: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<timesCalledSelectorReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: timesCalledSelectorReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for timesCalledSelectorReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for timesCalledSelectorCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = timesCalledSelectorReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "timesCalledSelector(bytes32)";
            const SELECTOR: [u8; 4] = [88u8, 55u8, 229u8, 183u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.selector),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`MockContract`](self) function calls.
    pub enum MockContractCalls {
        callParams(callParamsCall),
        calledWith(calledWithCall),
        calledWithSelector(calledWithSelectorCall),
        calls(callsCall),
        setImplementation(setImplementationCall),
        timesCalled(timesCalledCall),
        timesCalledSelector(timesCalledSelectorCall),
    }
    #[automatically_derived]
    impl MockContractCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [62u8, 67u8, 229u8, 229u8],
            [88u8, 55u8, 229u8, 183u8],
            [137u8, 23u8, 37u8, 177u8],
            [187u8, 215u8, 252u8, 154u8],
            [207u8, 241u8, 2u8, 101u8],
            [215u8, 132u8, 212u8, 38u8],
            [216u8, 10u8, 64u8, 119u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for MockContractCalls {
        const NAME: &'static str = "MockContractCalls";
        const MIN_DATA_LENGTH: usize = 32usize;
        const COUNT: usize = 7usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::callParams(_) => {
                    <callParamsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::calledWith(_) => {
                    <calledWithCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::calledWithSelector(_) => {
                    <calledWithSelectorCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::calls(_) => <callsCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::setImplementation(_) => {
                    <setImplementationCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::timesCalled(_) => {
                    <timesCalledCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::timesCalledSelector(_) => {
                    <timesCalledSelectorCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(unsafe_code, non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<MockContractCalls>] = &[
                {
                    fn timesCalled(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockContractCalls> {
                        <timesCalledCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockContractCalls::timesCalled)
                    }
                    timesCalled
                },
                {
                    fn timesCalledSelector(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockContractCalls> {
                        <timesCalledSelectorCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockContractCalls::timesCalledSelector)
                    }
                    timesCalledSelector
                },
                {
                    fn calledWith(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockContractCalls> {
                        <calledWithCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockContractCalls::calledWith)
                    }
                    calledWith
                },
                {
                    fn callParams(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockContractCalls> {
                        <callParamsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockContractCalls::callParams)
                    }
                    callParams
                },
                {
                    fn calls(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockContractCalls> {
                        <callsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockContractCalls::calls)
                    }
                    calls
                },
                {
                    fn setImplementation(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockContractCalls> {
                        <setImplementationCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockContractCalls::setImplementation)
                    }
                    setImplementation
                },
                {
                    fn calledWithSelector(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockContractCalls> {
                        <calledWithSelectorCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockContractCalls::calledWithSelector)
                    }
                    calledWithSelector
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            (unsafe { DECODE_SHIMS.get_unchecked(idx) })(data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::callParams(inner) => {
                    <callParamsCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::calledWith(inner) => {
                    <calledWithCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::calledWithSelector(inner) => {
                    <calledWithSelectorCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::calls(inner) => {
                    <callsCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::setImplementation(inner) => {
                    <setImplementationCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::timesCalled(inner) => {
                    <timesCalledCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::timesCalledSelector(inner) => {
                    <timesCalledSelectorCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::callParams(inner) => {
                    <callParamsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::calledWith(inner) => {
                    <calledWithCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::calledWithSelector(inner) => {
                    <calledWithSelectorCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::calls(inner) => {
                    <callsCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::setImplementation(inner) => {
                    <setImplementationCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::timesCalled(inner) => {
                    <timesCalledCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::timesCalledSelector(inner) => {
                    <timesCalledSelectorCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`MockContract`](self) contract instance.

See the [wrapper's documentation](`MockContractInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> MockContractInstance<T, P, N> {
        MockContractInstance::<T, P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<MockContractInstance<T, P, N>>,
    > {
        MockContractInstance::<T, P, N>::deploy(provider)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
        MockContractInstance::<T, P, N>::deploy_builder(provider)
    }
    /**A [`MockContract`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`MockContract`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct MockContractInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for MockContractInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("MockContractInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > MockContractInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`MockContract`](self) contract instance.

See the [wrapper's documentation](`MockContractInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
        ) -> alloy_contract::Result<MockContractInstance<T, P, N>> {
            let call_builder = Self::deploy_builder(provider);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                ::core::clone::Clone::clone(&BYTECODE),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> MockContractInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> MockContractInstance<T, P, N> {
            MockContractInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > MockContractInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`callParams`] function.
        pub fn callParams(
            &self,
            _0: alloy::sol_types::private::FixedBytes<32>,
            _1: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, callParamsCall, N> {
            self.call_builder(&callParamsCall { _0, _1 })
        }
        ///Creates a new call builder for the [`calledWith`] function.
        pub fn calledWith(
            &self,
            fnSig: alloy::sol_types::private::String,
            params: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, calledWithCall, N> {
            self.call_builder(&calledWithCall { fnSig, params })
        }
        ///Creates a new call builder for the [`calledWithSelector`] function.
        pub fn calledWithSelector(
            &self,
            selector: alloy::sol_types::private::FixedBytes<32>,
            params: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, calledWithSelectorCall, N> {
            self.call_builder(
                &calledWithSelectorCall {
                    selector,
                    params,
                },
            )
        }
        ///Creates a new call builder for the [`calls`] function.
        pub fn calls(
            &self,
            _0: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, callsCall, N> {
            self.call_builder(&callsCall { _0 })
        }
        ///Creates a new call builder for the [`setImplementation`] function.
        pub fn setImplementation(
            &self,
            _impl: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, setImplementationCall, N> {
            self.call_builder(&setImplementationCall { _impl })
        }
        ///Creates a new call builder for the [`timesCalled`] function.
        pub fn timesCalled(
            &self,
            fnSig: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, timesCalledCall, N> {
            self.call_builder(&timesCalledCall { fnSig })
        }
        ///Creates a new call builder for the [`timesCalledSelector`] function.
        pub fn timesCalledSelector(
            &self,
            selector: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, timesCalledSelectorCall, N> {
            self.call_builder(
                &timesCalledSelectorCall {
                    selector,
                },
            )
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > MockContractInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
    }
}
